import {
  AxisAlignedBoundingBox,
  CullingVolume,
  GLTFLoader,
  Plane,
  TILE_TYPE,
  Tiles3DLoader,
  Tileset3D,
  getMeshBoundingBox,
  makeOrientedBoundingBoxFromPoints
} from "./chunk-AXK4NH5X.js";
import {
  ArcLayer,
  BitmapLayer,
  ColumnLayer,
  GeoJsonLayer,
  PathLayer,
  PointCloudLayer,
  PolygonLayer,
  earcut,
  getPolygonSignedArea,
  require_earcut
} from "./chunk-YMAH5GZT.js";
import {
  Accessor,
  Buffer,
  COORDINATE_SYSTEM,
  CompositeLayer,
  FEATURES,
  Framebuffer,
  Geometry,
  GlobeViewport,
  Layer,
  LayerExtension,
  LayersPass,
  Model,
  OrthographicViewport,
  PickLayersPass,
  ProgramManager,
  Renderbuffer,
  Texture2D,
  WebMercatorViewport,
  assert,
  clear,
  createIterable,
  cssToDeviceRatio,
  deepEqual,
  flatten,
  fp64,
  fp64LowPart,
  hasFeature,
  isWebGL2,
  lngLatToWorld,
  log,
  log_default,
  memoize,
  mergeShaders,
  pbr,
  phongLighting,
  picking_default,
  project32_default,
  project_default,
  readPixelsToArray,
  uid,
  withParameters,
  worldToLngLat
} from "./chunk-6PCG52W4.js";
import {
  ImageLoader,
  Matrix4,
  Quaternion,
  RequestScheduler,
  Vector3,
  _defineProperty,
  concatenateTypedArrays,
  dist,
  equals,
  lerp,
  load,
  mergeLoaderOptions
} from "./chunk-CARTGOKD.js";
import {
  __commonJS,
  __require,
  __toESM
} from "./chunk-HM4MQYWN.js";

// node_modules/fast-xml-parser/src/util.js
var require_util = __commonJS({
  "node_modules/fast-xml-parser/src/util.js"(exports) {
    "use strict";
    var nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
    var nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
    var nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";
    var regexName = new RegExp("^" + nameRegexp + "$");
    var getAllMatches = function(string, regex) {
      const matches = [];
      let match = regex.exec(string);
      while (match) {
        const allmatches = [];
        allmatches.startIndex = regex.lastIndex - match[0].length;
        const len = match.length;
        for (let index = 0; index < len; index++) {
          allmatches.push(match[index]);
        }
        matches.push(allmatches);
        match = regex.exec(string);
      }
      return matches;
    };
    var isName = function(string) {
      const match = regexName.exec(string);
      return !(match === null || typeof match === "undefined");
    };
    exports.isExist = function(v) {
      return typeof v !== "undefined";
    };
    exports.isEmptyObject = function(obj) {
      return Object.keys(obj).length === 0;
    };
    exports.merge = function(target, a, arrayMode) {
      if (a) {
        const keys = Object.keys(a);
        const len = keys.length;
        for (let i2 = 0; i2 < len; i2++) {
          if (arrayMode === "strict") {
            target[keys[i2]] = [a[keys[i2]]];
          } else {
            target[keys[i2]] = a[keys[i2]];
          }
        }
      }
    };
    exports.getValue = function(v) {
      if (exports.isExist(v)) {
        return v;
      } else {
        return "";
      }
    };
    exports.isName = isName;
    exports.getAllMatches = getAllMatches;
    exports.nameRegexp = nameRegexp;
  }
});

// node_modules/fast-xml-parser/src/validator.js
var require_validator = __commonJS({
  "node_modules/fast-xml-parser/src/validator.js"(exports) {
    "use strict";
    var util = require_util();
    var defaultOptions = {
      allowBooleanAttributes: false,
      //A tag can have attributes without any value
      unpairedTags: []
    };
    exports.validate = function(xmlData, options) {
      options = Object.assign({}, defaultOptions, options);
      const tags = [];
      let tagFound = false;
      let reachedRoot = false;
      if (xmlData[0] === "\uFEFF") {
        xmlData = xmlData.substr(1);
      }
      for (let i2 = 0; i2 < xmlData.length; i2++) {
        if (xmlData[i2] === "<" && xmlData[i2 + 1] === "?") {
          i2 += 2;
          i2 = readPI(xmlData, i2);
          if (i2.err)
            return i2;
        } else if (xmlData[i2] === "<") {
          let tagStartPos = i2;
          i2++;
          if (xmlData[i2] === "!") {
            i2 = readCommentAndCDATA(xmlData, i2);
            continue;
          } else {
            let closingTag = false;
            if (xmlData[i2] === "/") {
              closingTag = true;
              i2++;
            }
            let tagName = "";
            for (; i2 < xmlData.length && xmlData[i2] !== ">" && xmlData[i2] !== " " && xmlData[i2] !== "	" && xmlData[i2] !== "\n" && xmlData[i2] !== "\r"; i2++) {
              tagName += xmlData[i2];
            }
            tagName = tagName.trim();
            if (tagName[tagName.length - 1] === "/") {
              tagName = tagName.substring(0, tagName.length - 1);
              i2--;
            }
            if (!validateTagName(tagName)) {
              let msg;
              if (tagName.trim().length === 0) {
                msg = "Invalid space after '<'.";
              } else {
                msg = "Tag '" + tagName + "' is an invalid name.";
              }
              return getErrorObject("InvalidTag", msg, getLineNumberForPosition(xmlData, i2));
            }
            const result = readAttributeStr(xmlData, i2);
            if (result === false) {
              return getErrorObject("InvalidAttr", "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i2));
            }
            let attrStr = result.value;
            i2 = result.index;
            if (attrStr[attrStr.length - 1] === "/") {
              const attrStrStart = i2 - attrStr.length;
              attrStr = attrStr.substring(0, attrStr.length - 1);
              const isValid = validateAttributeString(attrStr, options);
              if (isValid === true) {
                tagFound = true;
              } else {
                return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
              }
            } else if (closingTag) {
              if (!result.tagClosed) {
                return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i2));
              } else if (attrStr.trim().length > 0) {
                return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
              } else {
                const otg = tags.pop();
                if (tagName !== otg.tagName) {
                  let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
                  return getErrorObject(
                    "InvalidTag",
                    "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.",
                    getLineNumberForPosition(xmlData, tagStartPos)
                  );
                }
                if (tags.length == 0) {
                  reachedRoot = true;
                }
              }
            } else {
              const isValid = validateAttributeString(attrStr, options);
              if (isValid !== true) {
                return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i2 - attrStr.length + isValid.err.line));
              }
              if (reachedRoot === true) {
                return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition(xmlData, i2));
              } else if (options.unpairedTags.indexOf(tagName) !== -1) {
              } else {
                tags.push({ tagName, tagStartPos });
              }
              tagFound = true;
            }
            for (i2++; i2 < xmlData.length; i2++) {
              if (xmlData[i2] === "<") {
                if (xmlData[i2 + 1] === "!") {
                  i2++;
                  i2 = readCommentAndCDATA(xmlData, i2);
                  continue;
                } else if (xmlData[i2 + 1] === "?") {
                  i2 = readPI(xmlData, ++i2);
                  if (i2.err)
                    return i2;
                } else {
                  break;
                }
              } else if (xmlData[i2] === "&") {
                const afterAmp = validateAmpersand(xmlData, i2);
                if (afterAmp == -1)
                  return getErrorObject("InvalidChar", "char '&' is not expected.", getLineNumberForPosition(xmlData, i2));
                i2 = afterAmp;
              } else {
                if (reachedRoot === true && !isWhiteSpace(xmlData[i2])) {
                  return getErrorObject("InvalidXml", "Extra text at the end", getLineNumberForPosition(xmlData, i2));
                }
              }
            }
            if (xmlData[i2] === "<") {
              i2--;
            }
          }
        } else {
          if (isWhiteSpace(xmlData[i2])) {
            continue;
          }
          return getErrorObject("InvalidChar", "char '" + xmlData[i2] + "' is not expected.", getLineNumberForPosition(xmlData, i2));
        }
      }
      if (!tagFound) {
        return getErrorObject("InvalidXml", "Start tag expected.", 1);
      } else if (tags.length == 1) {
        return getErrorObject("InvalidTag", "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
      } else if (tags.length > 0) {
        return getErrorObject("InvalidXml", "Invalid '" + JSON.stringify(tags.map((t) => t.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
      }
      return true;
    };
    function isWhiteSpace(char) {
      return char === " " || char === "	" || char === "\n" || char === "\r";
    }
    function readPI(xmlData, i2) {
      const start = i2;
      for (; i2 < xmlData.length; i2++) {
        if (xmlData[i2] == "?" || xmlData[i2] == " ") {
          const tagname = xmlData.substr(start, i2 - start);
          if (i2 > 5 && tagname === "xml") {
            return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition(xmlData, i2));
          } else if (xmlData[i2] == "?" && xmlData[i2 + 1] == ">") {
            i2++;
            break;
          } else {
            continue;
          }
        }
      }
      return i2;
    }
    function readCommentAndCDATA(xmlData, i2) {
      if (xmlData.length > i2 + 5 && xmlData[i2 + 1] === "-" && xmlData[i2 + 2] === "-") {
        for (i2 += 3; i2 < xmlData.length; i2++) {
          if (xmlData[i2] === "-" && xmlData[i2 + 1] === "-" && xmlData[i2 + 2] === ">") {
            i2 += 2;
            break;
          }
        }
      } else if (xmlData.length > i2 + 8 && xmlData[i2 + 1] === "D" && xmlData[i2 + 2] === "O" && xmlData[i2 + 3] === "C" && xmlData[i2 + 4] === "T" && xmlData[i2 + 5] === "Y" && xmlData[i2 + 6] === "P" && xmlData[i2 + 7] === "E") {
        let angleBracketsCount = 1;
        for (i2 += 8; i2 < xmlData.length; i2++) {
          if (xmlData[i2] === "<") {
            angleBracketsCount++;
          } else if (xmlData[i2] === ">") {
            angleBracketsCount--;
            if (angleBracketsCount === 0) {
              break;
            }
          }
        }
      } else if (xmlData.length > i2 + 9 && xmlData[i2 + 1] === "[" && xmlData[i2 + 2] === "C" && xmlData[i2 + 3] === "D" && xmlData[i2 + 4] === "A" && xmlData[i2 + 5] === "T" && xmlData[i2 + 6] === "A" && xmlData[i2 + 7] === "[") {
        for (i2 += 8; i2 < xmlData.length; i2++) {
          if (xmlData[i2] === "]" && xmlData[i2 + 1] === "]" && xmlData[i2 + 2] === ">") {
            i2 += 2;
            break;
          }
        }
      }
      return i2;
    }
    var doubleQuote = '"';
    var singleQuote = "'";
    function readAttributeStr(xmlData, i2) {
      let attrStr = "";
      let startChar = "";
      let tagClosed = false;
      for (; i2 < xmlData.length; i2++) {
        if (xmlData[i2] === doubleQuote || xmlData[i2] === singleQuote) {
          if (startChar === "") {
            startChar = xmlData[i2];
          } else if (startChar !== xmlData[i2]) {
          } else {
            startChar = "";
          }
        } else if (xmlData[i2] === ">") {
          if (startChar === "") {
            tagClosed = true;
            break;
          }
        }
        attrStr += xmlData[i2];
      }
      if (startChar !== "") {
        return false;
      }
      return {
        value: attrStr,
        index: i2,
        tagClosed
      };
    }
    var validAttrStrRegxp = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
    function validateAttributeString(attrStr, options) {
      const matches = util.getAllMatches(attrStr, validAttrStrRegxp);
      const attrNames = {};
      for (let i2 = 0; i2 < matches.length; i2++) {
        if (matches[i2][1].length === 0) {
          return getErrorObject("InvalidAttr", "Attribute '" + matches[i2][2] + "' has no space in starting.", getPositionFromMatch(matches[i2]));
        } else if (matches[i2][3] !== void 0 && matches[i2][4] === void 0) {
          return getErrorObject("InvalidAttr", "Attribute '" + matches[i2][2] + "' is without value.", getPositionFromMatch(matches[i2]));
        } else if (matches[i2][3] === void 0 && !options.allowBooleanAttributes) {
          return getErrorObject("InvalidAttr", "boolean attribute '" + matches[i2][2] + "' is not allowed.", getPositionFromMatch(matches[i2]));
        }
        const attrName = matches[i2][2];
        if (!validateAttrName(attrName)) {
          return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches[i2]));
        }
        if (!attrNames.hasOwnProperty(attrName)) {
          attrNames[attrName] = 1;
        } else {
          return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches[i2]));
        }
      }
      return true;
    }
    function validateNumberAmpersand(xmlData, i2) {
      let re = /\d/;
      if (xmlData[i2] === "x") {
        i2++;
        re = /[\da-fA-F]/;
      }
      for (; i2 < xmlData.length; i2++) {
        if (xmlData[i2] === ";")
          return i2;
        if (!xmlData[i2].match(re))
          break;
      }
      return -1;
    }
    function validateAmpersand(xmlData, i2) {
      i2++;
      if (xmlData[i2] === ";")
        return -1;
      if (xmlData[i2] === "#") {
        i2++;
        return validateNumberAmpersand(xmlData, i2);
      }
      let count = 0;
      for (; i2 < xmlData.length; i2++, count++) {
        if (xmlData[i2].match(/\w/) && count < 20)
          continue;
        if (xmlData[i2] === ";")
          break;
        return -1;
      }
      return i2;
    }
    function getErrorObject(code, message, lineNumber) {
      return {
        err: {
          code,
          msg: message,
          line: lineNumber.line || lineNumber,
          col: lineNumber.col
        }
      };
    }
    function validateAttrName(attrName) {
      return util.isName(attrName);
    }
    function validateTagName(tagname) {
      return util.isName(tagname);
    }
    function getLineNumberForPosition(xmlData, index) {
      const lines = xmlData.substring(0, index).split(/\r?\n/);
      return {
        line: lines.length,
        // column number is last line's length + 1, because column numbering starts at 1:
        col: lines[lines.length - 1].length + 1
      };
    }
    function getPositionFromMatch(match) {
      return match.startIndex + match[1].length;
    }
  }
});

// node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js
var require_OptionsBuilder = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js"(exports) {
    var defaultOptions = {
      preserveOrder: false,
      attributeNamePrefix: "@_",
      attributesGroupName: false,
      textNodeName: "#text",
      ignoreAttributes: true,
      removeNSPrefix: false,
      // remove NS from tag name or attribute name if true
      allowBooleanAttributes: false,
      //a tag can have attributes without any value
      //ignoreRootElement : false,
      parseTagValue: true,
      parseAttributeValue: false,
      trimValues: true,
      //Trim string values of tag and attributes
      cdataPropName: false,
      numberParseOptions: {
        hex: true,
        leadingZeros: true,
        eNotation: true
      },
      tagValueProcessor: function(tagName, val2) {
        return val2;
      },
      attributeValueProcessor: function(attrName, val2) {
        return val2;
      },
      stopNodes: [],
      //nested tags will not be parsed even for errors
      alwaysCreateTextNode: false,
      isArray: () => false,
      commentPropName: false,
      unpairedTags: [],
      processEntities: true,
      htmlEntities: false,
      ignoreDeclaration: false,
      ignorePiTags: false,
      transformTagName: false,
      transformAttributeName: false,
      updateTag: function(tagName, jPath, attrs) {
        return tagName;
      }
      // skipEmptyListItem: false
    };
    var buildOptions = function(options) {
      return Object.assign({}, defaultOptions, options);
    };
    exports.buildOptions = buildOptions;
    exports.defaultOptions = defaultOptions;
  }
});

// node_modules/fast-xml-parser/src/xmlparser/xmlNode.js
var require_xmlNode = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/xmlNode.js"(exports, module) {
    "use strict";
    var XmlNode = class {
      constructor(tagname) {
        this.tagname = tagname;
        this.child = [];
        this[":@"] = {};
      }
      add(key, val2) {
        if (key === "__proto__")
          key = "#__proto__";
        this.child.push({ [key]: val2 });
      }
      addChild(node) {
        if (node.tagname === "__proto__")
          node.tagname = "#__proto__";
        if (node[":@"] && Object.keys(node[":@"]).length > 0) {
          this.child.push({ [node.tagname]: node.child, [":@"]: node[":@"] });
        } else {
          this.child.push({ [node.tagname]: node.child });
        }
      }
    };
    module.exports = XmlNode;
  }
});

// node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js
var require_DocTypeReader = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js"(exports, module) {
    var util = require_util();
    function readDocType(xmlData, i2) {
      const entities = {};
      if (xmlData[i2 + 3] === "O" && xmlData[i2 + 4] === "C" && xmlData[i2 + 5] === "T" && xmlData[i2 + 6] === "Y" && xmlData[i2 + 7] === "P" && xmlData[i2 + 8] === "E") {
        i2 = i2 + 9;
        let angleBracketsCount = 1;
        let hasBody = false, comment = false;
        let exp = "";
        for (; i2 < xmlData.length; i2++) {
          if (xmlData[i2] === "<" && !comment) {
            if (hasBody && isEntity(xmlData, i2)) {
              i2 += 7;
              [entityName, val, i2] = readEntityExp(xmlData, i2 + 1);
              if (val.indexOf("&") === -1)
                entities[validateEntityName(entityName)] = {
                  regx: RegExp(`&${entityName};`, "g"),
                  val
                };
            } else if (hasBody && isElement(xmlData, i2))
              i2 += 8;
            else if (hasBody && isAttlist(xmlData, i2))
              i2 += 8;
            else if (hasBody && isNotation(xmlData, i2))
              i2 += 9;
            else if (isComment)
              comment = true;
            else
              throw new Error("Invalid DOCTYPE");
            angleBracketsCount++;
            exp = "";
          } else if (xmlData[i2] === ">") {
            if (comment) {
              if (xmlData[i2 - 1] === "-" && xmlData[i2 - 2] === "-") {
                comment = false;
                angleBracketsCount--;
              }
            } else {
              angleBracketsCount--;
            }
            if (angleBracketsCount === 0) {
              break;
            }
          } else if (xmlData[i2] === "[") {
            hasBody = true;
          } else {
            exp += xmlData[i2];
          }
        }
        if (angleBracketsCount !== 0) {
          throw new Error(`Unclosed DOCTYPE`);
        }
      } else {
        throw new Error(`Invalid Tag instead of DOCTYPE`);
      }
      return { entities, i: i2 };
    }
    function readEntityExp(xmlData, i2) {
      let entityName2 = "";
      for (; i2 < xmlData.length && (xmlData[i2] !== "'" && xmlData[i2] !== '"'); i2++) {
        entityName2 += xmlData[i2];
      }
      entityName2 = entityName2.trim();
      if (entityName2.indexOf(" ") !== -1)
        throw new Error("External entites are not supported");
      const startChar = xmlData[i2++];
      let val2 = "";
      for (; i2 < xmlData.length && xmlData[i2] !== startChar; i2++) {
        val2 += xmlData[i2];
      }
      return [entityName2, val2, i2];
    }
    function isComment(xmlData, i2) {
      if (xmlData[i2 + 1] === "!" && xmlData[i2 + 2] === "-" && xmlData[i2 + 3] === "-")
        return true;
      return false;
    }
    function isEntity(xmlData, i2) {
      if (xmlData[i2 + 1] === "!" && xmlData[i2 + 2] === "E" && xmlData[i2 + 3] === "N" && xmlData[i2 + 4] === "T" && xmlData[i2 + 5] === "I" && xmlData[i2 + 6] === "T" && xmlData[i2 + 7] === "Y")
        return true;
      return false;
    }
    function isElement(xmlData, i2) {
      if (xmlData[i2 + 1] === "!" && xmlData[i2 + 2] === "E" && xmlData[i2 + 3] === "L" && xmlData[i2 + 4] === "E" && xmlData[i2 + 5] === "M" && xmlData[i2 + 6] === "E" && xmlData[i2 + 7] === "N" && xmlData[i2 + 8] === "T")
        return true;
      return false;
    }
    function isAttlist(xmlData, i2) {
      if (xmlData[i2 + 1] === "!" && xmlData[i2 + 2] === "A" && xmlData[i2 + 3] === "T" && xmlData[i2 + 4] === "T" && xmlData[i2 + 5] === "L" && xmlData[i2 + 6] === "I" && xmlData[i2 + 7] === "S" && xmlData[i2 + 8] === "T")
        return true;
      return false;
    }
    function isNotation(xmlData, i2) {
      if (xmlData[i2 + 1] === "!" && xmlData[i2 + 2] === "N" && xmlData[i2 + 3] === "O" && xmlData[i2 + 4] === "T" && xmlData[i2 + 5] === "A" && xmlData[i2 + 6] === "T" && xmlData[i2 + 7] === "I" && xmlData[i2 + 8] === "O" && xmlData[i2 + 9] === "N")
        return true;
      return false;
    }
    function validateEntityName(name) {
      if (util.isName(name))
        return name;
      else
        throw new Error(`Invalid entity name ${name}`);
    }
    module.exports = readDocType;
  }
});

// node_modules/strnum/strnum.js
var require_strnum = __commonJS({
  "node_modules/strnum/strnum.js"(exports, module) {
    var hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
    var numRegex = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
    if (!Number.parseInt && window.parseInt) {
      Number.parseInt = window.parseInt;
    }
    if (!Number.parseFloat && window.parseFloat) {
      Number.parseFloat = window.parseFloat;
    }
    var consider = {
      hex: true,
      leadingZeros: true,
      decimalPoint: ".",
      eNotation: true
      //skipLike: /regex/
    };
    function toNumber(str, options = {}) {
      options = Object.assign({}, consider, options);
      if (!str || typeof str !== "string")
        return str;
      let trimmedStr = str.trim();
      if (options.skipLike !== void 0 && options.skipLike.test(trimmedStr))
        return str;
      else if (options.hex && hexRegex.test(trimmedStr)) {
        return Number.parseInt(trimmedStr, 16);
      } else {
        const match = numRegex.exec(trimmedStr);
        if (match) {
          const sign = match[1];
          const leadingZeros = match[2];
          let numTrimmedByZeros = trimZeros(match[3]);
          const eNotation = match[4] || match[6];
          if (!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== ".")
            return str;
          else if (!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== ".")
            return str;
          else {
            const num = Number(trimmedStr);
            const numStr = "" + num;
            if (numStr.search(/[eE]/) !== -1) {
              if (options.eNotation)
                return num;
              else
                return str;
            } else if (eNotation) {
              if (options.eNotation)
                return num;
              else
                return str;
            } else if (trimmedStr.indexOf(".") !== -1) {
              if (numStr === "0" && numTrimmedByZeros === "")
                return num;
              else if (numStr === numTrimmedByZeros)
                return num;
              else if (sign && numStr === "-" + numTrimmedByZeros)
                return num;
              else
                return str;
            }
            if (leadingZeros) {
              if (numTrimmedByZeros === numStr)
                return num;
              else if (sign + numTrimmedByZeros === numStr)
                return num;
              else
                return str;
            }
            if (trimmedStr === numStr)
              return num;
            else if (trimmedStr === sign + numStr)
              return num;
            return str;
          }
        } else {
          return str;
        }
      }
    }
    function trimZeros(numStr) {
      if (numStr && numStr.indexOf(".") !== -1) {
        numStr = numStr.replace(/0+$/, "");
        if (numStr === ".")
          numStr = "0";
        else if (numStr[0] === ".")
          numStr = "0" + numStr;
        else if (numStr[numStr.length - 1] === ".")
          numStr = numStr.substr(0, numStr.length - 1);
        return numStr;
      }
      return numStr;
    }
    module.exports = toNumber;
  }
});

// node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js
var require_OrderedObjParser = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js"(exports, module) {
    "use strict";
    var util = require_util();
    var xmlNode = require_xmlNode();
    var readDocType = require_DocTypeReader();
    var toNumber = require_strnum();
    var regx = "<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)".replace(/NAME/g, util.nameRegexp);
    var OrderedObjParser = class {
      constructor(options) {
        this.options = options;
        this.currentNode = null;
        this.tagsNodeStack = [];
        this.docTypeEntities = {};
        this.lastEntities = {
          "apos": { regex: /&(apos|#39|#x27);/g, val: "'" },
          "gt": { regex: /&(gt|#62|#x3E);/g, val: ">" },
          "lt": { regex: /&(lt|#60|#x3C);/g, val: "<" },
          "quot": { regex: /&(quot|#34|#x22);/g, val: '"' }
        };
        this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" };
        this.htmlEntities = {
          "space": { regex: /&(nbsp|#160);/g, val: " " },
          // "lt" : { regex: /&(lt|#60);/g, val: "<" },
          // "gt" : { regex: /&(gt|#62);/g, val: ">" },
          // "amp" : { regex: /&(amp|#38);/g, val: "&" },
          // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
          // "apos" : { regex: /&(apos|#39);/g, val: "'" },
          "cent": { regex: /&(cent|#162);/g, val: "¢" },
          "pound": { regex: /&(pound|#163);/g, val: "£" },
          "yen": { regex: /&(yen|#165);/g, val: "¥" },
          "euro": { regex: /&(euro|#8364);/g, val: "€" },
          "copyright": { regex: /&(copy|#169);/g, val: "©" },
          "reg": { regex: /&(reg|#174);/g, val: "®" },
          "inr": { regex: /&(inr|#8377);/g, val: "₹" }
        };
        this.addExternalEntities = addExternalEntities;
        this.parseXml = parseXml;
        this.parseTextData = parseTextData;
        this.resolveNameSpace = resolveNameSpace;
        this.buildAttributesMap = buildAttributesMap;
        this.isItStopNode = isItStopNode;
        this.replaceEntitiesValue = replaceEntitiesValue;
        this.readStopNodeData = readStopNodeData;
        this.saveTextToParentTag = saveTextToParentTag;
        this.addChild = addChild;
      }
    };
    function addExternalEntities(externalEntities) {
      const entKeys = Object.keys(externalEntities);
      for (let i2 = 0; i2 < entKeys.length; i2++) {
        const ent = entKeys[i2];
        this.lastEntities[ent] = {
          regex: new RegExp("&" + ent + ";", "g"),
          val: externalEntities[ent]
        };
      }
    }
    function parseTextData(val2, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
      if (val2 !== void 0) {
        if (this.options.trimValues && !dontTrim) {
          val2 = val2.trim();
        }
        if (val2.length > 0) {
          if (!escapeEntities)
            val2 = this.replaceEntitiesValue(val2);
          const newval = this.options.tagValueProcessor(tagName, val2, jPath, hasAttributes, isLeafNode);
          if (newval === null || newval === void 0) {
            return val2;
          } else if (typeof newval !== typeof val2 || newval !== val2) {
            return newval;
          } else if (this.options.trimValues) {
            return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
          } else {
            const trimmedVal = val2.trim();
            if (trimmedVal === val2) {
              return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
            } else {
              return val2;
            }
          }
        }
      }
    }
    function resolveNameSpace(tagname) {
      if (this.options.removeNSPrefix) {
        const tags = tagname.split(":");
        const prefix = tagname.charAt(0) === "/" ? "/" : "";
        if (tags[0] === "xmlns") {
          return "";
        }
        if (tags.length === 2) {
          tagname = prefix + tags[1];
        }
      }
      return tagname;
    }
    var attrsRegx = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
    function buildAttributesMap(attrStr, jPath, tagName) {
      if (!this.options.ignoreAttributes && typeof attrStr === "string") {
        const matches = util.getAllMatches(attrStr, attrsRegx);
        const len = matches.length;
        const attrs = {};
        for (let i2 = 0; i2 < len; i2++) {
          const attrName = this.resolveNameSpace(matches[i2][1]);
          let oldVal = matches[i2][4];
          let aName = this.options.attributeNamePrefix + attrName;
          if (attrName.length) {
            if (this.options.transformAttributeName) {
              aName = this.options.transformAttributeName(aName);
            }
            if (aName === "__proto__")
              aName = "#__proto__";
            if (oldVal !== void 0) {
              if (this.options.trimValues) {
                oldVal = oldVal.trim();
              }
              oldVal = this.replaceEntitiesValue(oldVal);
              const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
              if (newVal === null || newVal === void 0) {
                attrs[aName] = oldVal;
              } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {
                attrs[aName] = newVal;
              } else {
                attrs[aName] = parseValue(
                  oldVal,
                  this.options.parseAttributeValue,
                  this.options.numberParseOptions
                );
              }
            } else if (this.options.allowBooleanAttributes) {
              attrs[aName] = true;
            }
          }
        }
        if (!Object.keys(attrs).length) {
          return;
        }
        if (this.options.attributesGroupName) {
          const attrCollection = {};
          attrCollection[this.options.attributesGroupName] = attrs;
          return attrCollection;
        }
        return attrs;
      }
    }
    var parseXml = function(xmlData) {
      xmlData = xmlData.replace(/\r\n?/g, "\n");
      const xmlObj = new xmlNode("!xml");
      let currentNode = xmlObj;
      let textData = "";
      let jPath = "";
      for (let i2 = 0; i2 < xmlData.length; i2++) {
        const ch = xmlData[i2];
        if (ch === "<") {
          if (xmlData[i2 + 1] === "/") {
            const closeIndex = findClosingIndex(xmlData, ">", i2, "Closing Tag is not closed.");
            let tagName = xmlData.substring(i2 + 2, closeIndex).trim();
            if (this.options.removeNSPrefix) {
              const colonIndex = tagName.indexOf(":");
              if (colonIndex !== -1) {
                tagName = tagName.substr(colonIndex + 1);
              }
            }
            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }
            if (currentNode) {
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
            }
            const lastTagName = jPath.substring(jPath.lastIndexOf(".") + 1);
            if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {
              throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
            }
            let propIndex = 0;
            if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {
              propIndex = jPath.lastIndexOf(".", jPath.lastIndexOf(".") - 1);
              this.tagsNodeStack.pop();
            } else {
              propIndex = jPath.lastIndexOf(".");
            }
            jPath = jPath.substring(0, propIndex);
            currentNode = this.tagsNodeStack.pop();
            textData = "";
            i2 = closeIndex;
          } else if (xmlData[i2 + 1] === "?") {
            let tagData = readTagExp(xmlData, i2, false, "?>");
            if (!tagData)
              throw new Error("Pi Tag is not closed.");
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags) {
            } else {
              const childNode = new xmlNode(tagData.tagName);
              childNode.add(this.options.textNodeName, "");
              if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
              }
              this.addChild(currentNode, childNode, jPath);
            }
            i2 = tagData.closeIndex + 1;
          } else if (xmlData.substr(i2 + 1, 3) === "!--") {
            const endIndex = findClosingIndex(xmlData, "-->", i2 + 4, "Comment is not closed.");
            if (this.options.commentPropName) {
              const comment = xmlData.substring(i2 + 4, endIndex - 2);
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
              currentNode.add(this.options.commentPropName, [{ [this.options.textNodeName]: comment }]);
            }
            i2 = endIndex;
          } else if (xmlData.substr(i2 + 1, 2) === "!D") {
            const result = readDocType(xmlData, i2);
            this.docTypeEntities = result.entities;
            i2 = result.i;
          } else if (xmlData.substr(i2 + 1, 2) === "![") {
            const closeIndex = findClosingIndex(xmlData, "]]>", i2, "CDATA is not closed.") - 2;
            const tagExp = xmlData.substring(i2 + 9, closeIndex);
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            if (this.options.cdataPropName) {
              currentNode.add(this.options.cdataPropName, [{ [this.options.textNodeName]: tagExp }]);
            } else {
              let val2 = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true);
              if (val2 == void 0)
                val2 = "";
              currentNode.add(this.options.textNodeName, val2);
            }
            i2 = closeIndex + 2;
          } else {
            let result = readTagExp(xmlData, i2, this.options.removeNSPrefix);
            let tagName = result.tagName;
            let tagExp = result.tagExp;
            let attrExpPresent = result.attrExpPresent;
            let closeIndex = result.closeIndex;
            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }
            if (currentNode && textData) {
              if (currentNode.tagname !== "!xml") {
                textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
              }
            }
            const lastTag = currentNode;
            if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {
              currentNode = this.tagsNodeStack.pop();
              jPath = jPath.substring(0, jPath.lastIndexOf("."));
            }
            if (tagName !== xmlObj.tagname) {
              jPath += jPath ? "." + tagName : tagName;
            }
            if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
              let tagContent = "";
              if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                i2 = result.closeIndex;
              } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {
                i2 = result.closeIndex;
              } else {
                const result2 = this.readStopNodeData(xmlData, tagName, closeIndex + 1);
                if (!result2)
                  throw new Error(`Unexpected end of ${tagName}`);
                i2 = result2.i;
                tagContent = result2.tagContent;
              }
              const childNode = new xmlNode(tagName);
              if (tagName !== tagExp && attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
              }
              if (tagContent) {
                tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
              }
              jPath = jPath.substr(0, jPath.lastIndexOf("."));
              childNode.add(this.options.textNodeName, tagContent);
              this.addChild(currentNode, childNode, jPath);
            } else {
              if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                if (tagName[tagName.length - 1] === "/") {
                  tagName = tagName.substr(0, tagName.length - 1);
                  jPath = jPath.substr(0, jPath.length - 1);
                  tagExp = tagName;
                } else {
                  tagExp = tagExp.substr(0, tagExp.length - 1);
                }
                if (this.options.transformTagName) {
                  tagName = this.options.transformTagName(tagName);
                }
                const childNode = new xmlNode(tagName);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                }
                this.addChild(currentNode, childNode, jPath);
                jPath = jPath.substr(0, jPath.lastIndexOf("."));
              } else {
                const childNode = new xmlNode(tagName);
                this.tagsNodeStack.push(currentNode);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                }
                this.addChild(currentNode, childNode, jPath);
                currentNode = childNode;
              }
              textData = "";
              i2 = closeIndex;
            }
          }
        } else {
          textData += xmlData[i2];
        }
      }
      return xmlObj.child;
    };
    function addChild(currentNode, childNode, jPath) {
      const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"]);
      if (result === false) {
      } else if (typeof result === "string") {
        childNode.tagname = result;
        currentNode.addChild(childNode);
      } else {
        currentNode.addChild(childNode);
      }
    }
    var replaceEntitiesValue = function(val2) {
      if (this.options.processEntities) {
        for (let entityName2 in this.docTypeEntities) {
          const entity = this.docTypeEntities[entityName2];
          val2 = val2.replace(entity.regx, entity.val);
        }
        for (let entityName2 in this.lastEntities) {
          const entity = this.lastEntities[entityName2];
          val2 = val2.replace(entity.regex, entity.val);
        }
        if (this.options.htmlEntities) {
          for (let entityName2 in this.htmlEntities) {
            const entity = this.htmlEntities[entityName2];
            val2 = val2.replace(entity.regex, entity.val);
          }
        }
        val2 = val2.replace(this.ampEntity.regex, this.ampEntity.val);
      }
      return val2;
    };
    function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
      if (textData) {
        if (isLeafNode === void 0)
          isLeafNode = Object.keys(currentNode.child).length === 0;
        textData = this.parseTextData(
          textData,
          currentNode.tagname,
          jPath,
          false,
          currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false,
          isLeafNode
        );
        if (textData !== void 0 && textData !== "")
          currentNode.add(this.options.textNodeName, textData);
        textData = "";
      }
      return textData;
    }
    function isItStopNode(stopNodes, jPath, currentTagName) {
      const allNodesExp = "*." + currentTagName;
      for (const stopNodePath in stopNodes) {
        const stopNodeExp = stopNodes[stopNodePath];
        if (allNodesExp === stopNodeExp || jPath === stopNodeExp)
          return true;
      }
      return false;
    }
    function tagExpWithClosingIndex(xmlData, i2, closingChar = ">") {
      let attrBoundary;
      let tagExp = "";
      for (let index = i2; index < xmlData.length; index++) {
        let ch = xmlData[index];
        if (attrBoundary) {
          if (ch === attrBoundary)
            attrBoundary = "";
        } else if (ch === '"' || ch === "'") {
          attrBoundary = ch;
        } else if (ch === closingChar[0]) {
          if (closingChar[1]) {
            if (xmlData[index + 1] === closingChar[1]) {
              return {
                data: tagExp,
                index
              };
            }
          } else {
            return {
              data: tagExp,
              index
            };
          }
        } else if (ch === "	") {
          ch = " ";
        }
        tagExp += ch;
      }
    }
    function findClosingIndex(xmlData, str, i2, errMsg) {
      const closingIndex = xmlData.indexOf(str, i2);
      if (closingIndex === -1) {
        throw new Error(errMsg);
      } else {
        return closingIndex + str.length - 1;
      }
    }
    function readTagExp(xmlData, i2, removeNSPrefix, closingChar = ">") {
      const result = tagExpWithClosingIndex(xmlData, i2 + 1, closingChar);
      if (!result)
        return;
      let tagExp = result.data;
      const closeIndex = result.index;
      const separatorIndex = tagExp.search(/\s/);
      let tagName = tagExp;
      let attrExpPresent = true;
      if (separatorIndex !== -1) {
        tagName = tagExp.substr(0, separatorIndex).replace(/\s\s*$/, "");
        tagExp = tagExp.substr(separatorIndex + 1);
      }
      if (removeNSPrefix) {
        const colonIndex = tagName.indexOf(":");
        if (colonIndex !== -1) {
          tagName = tagName.substr(colonIndex + 1);
          attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
        }
      }
      return {
        tagName,
        tagExp,
        closeIndex,
        attrExpPresent
      };
    }
    function readStopNodeData(xmlData, tagName, i2) {
      const startIndex = i2;
      let openTagCount = 1;
      for (; i2 < xmlData.length; i2++) {
        if (xmlData[i2] === "<") {
          if (xmlData[i2 + 1] === "/") {
            const closeIndex = findClosingIndex(xmlData, ">", i2, `${tagName} is not closed`);
            let closeTagName = xmlData.substring(i2 + 2, closeIndex).trim();
            if (closeTagName === tagName) {
              openTagCount--;
              if (openTagCount === 0) {
                return {
                  tagContent: xmlData.substring(startIndex, i2),
                  i: closeIndex
                };
              }
            }
            i2 = closeIndex;
          } else if (xmlData[i2 + 1] === "?") {
            const closeIndex = findClosingIndex(xmlData, "?>", i2 + 1, "StopNode is not closed.");
            i2 = closeIndex;
          } else if (xmlData.substr(i2 + 1, 3) === "!--") {
            const closeIndex = findClosingIndex(xmlData, "-->", i2 + 3, "StopNode is not closed.");
            i2 = closeIndex;
          } else if (xmlData.substr(i2 + 1, 2) === "![") {
            const closeIndex = findClosingIndex(xmlData, "]]>", i2, "StopNode is not closed.") - 2;
            i2 = closeIndex;
          } else {
            const tagData = readTagExp(xmlData, i2, ">");
            if (tagData) {
              const openTagName = tagData && tagData.tagName;
              if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") {
                openTagCount++;
              }
              i2 = tagData.closeIndex;
            }
          }
        }
      }
    }
    function parseValue(val2, shouldParse, options) {
      if (shouldParse && typeof val2 === "string") {
        const newval = val2.trim();
        if (newval === "true")
          return true;
        else if (newval === "false")
          return false;
        else
          return toNumber(val2, options);
      } else {
        if (util.isExist(val2)) {
          return val2;
        } else {
          return "";
        }
      }
    }
    module.exports = OrderedObjParser;
  }
});

// node_modules/fast-xml-parser/src/xmlparser/node2json.js
var require_node2json = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/node2json.js"(exports) {
    "use strict";
    function prettify(node, options) {
      return compress(node, options);
    }
    function compress(arr, options, jPath) {
      let text;
      const compressedObj = {};
      for (let i2 = 0; i2 < arr.length; i2++) {
        const tagObj = arr[i2];
        const property = propName(tagObj);
        let newJpath = "";
        if (jPath === void 0)
          newJpath = property;
        else
          newJpath = jPath + "." + property;
        if (property === options.textNodeName) {
          if (text === void 0)
            text = tagObj[property];
          else
            text += "" + tagObj[property];
        } else if (property === void 0) {
          continue;
        } else if (tagObj[property]) {
          let val2 = compress(tagObj[property], options, newJpath);
          const isLeaf = isLeafTag(val2, options);
          if (tagObj[":@"]) {
            assignAttributes(val2, tagObj[":@"], newJpath, options);
          } else if (Object.keys(val2).length === 1 && val2[options.textNodeName] !== void 0 && !options.alwaysCreateTextNode) {
            val2 = val2[options.textNodeName];
          } else if (Object.keys(val2).length === 0) {
            if (options.alwaysCreateTextNode)
              val2[options.textNodeName] = "";
            else
              val2 = "";
          }
          if (compressedObj[property] !== void 0 && compressedObj.hasOwnProperty(property)) {
            if (!Array.isArray(compressedObj[property])) {
              compressedObj[property] = [compressedObj[property]];
            }
            compressedObj[property].push(val2);
          } else {
            if (options.isArray(property, newJpath, isLeaf)) {
              compressedObj[property] = [val2];
            } else {
              compressedObj[property] = val2;
            }
          }
        }
      }
      if (typeof text === "string") {
        if (text.length > 0)
          compressedObj[options.textNodeName] = text;
      } else if (text !== void 0)
        compressedObj[options.textNodeName] = text;
      return compressedObj;
    }
    function propName(obj) {
      const keys = Object.keys(obj);
      for (let i2 = 0; i2 < keys.length; i2++) {
        const key = keys[i2];
        if (key !== ":@")
          return key;
      }
    }
    function assignAttributes(obj, attrMap, jpath, options) {
      if (attrMap) {
        const keys = Object.keys(attrMap);
        const len = keys.length;
        for (let i2 = 0; i2 < len; i2++) {
          const atrrName = keys[i2];
          if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
            obj[atrrName] = [attrMap[atrrName]];
          } else {
            obj[atrrName] = attrMap[atrrName];
          }
        }
      }
    }
    function isLeafTag(obj, options) {
      const { textNodeName } = options;
      const propCount = Object.keys(obj).length;
      if (propCount === 0) {
        return true;
      }
      if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)) {
        return true;
      }
      return false;
    }
    exports.prettify = prettify;
  }
});

// node_modules/fast-xml-parser/src/xmlparser/XMLParser.js
var require_XMLParser = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/XMLParser.js"(exports, module) {
    var { buildOptions } = require_OptionsBuilder();
    var OrderedObjParser = require_OrderedObjParser();
    var { prettify } = require_node2json();
    var validator = require_validator();
    var XMLParser = class {
      constructor(options) {
        this.externalEntities = {};
        this.options = buildOptions(options);
      }
      /**
       * Parse XML dats to JS object 
       * @param {string|Buffer} xmlData 
       * @param {boolean|Object} validationOption 
       */
      parse(xmlData, validationOption) {
        if (typeof xmlData === "string") {
        } else if (xmlData.toString) {
          xmlData = xmlData.toString();
        } else {
          throw new Error("XML data is accepted in String or Bytes[] form.");
        }
        if (validationOption) {
          if (validationOption === true)
            validationOption = {};
          const result = validator.validate(xmlData, validationOption);
          if (result !== true) {
            throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);
          }
        }
        const orderedObjParser = new OrderedObjParser(this.options);
        orderedObjParser.addExternalEntities(this.externalEntities);
        const orderedResult = orderedObjParser.parseXml(xmlData);
        if (this.options.preserveOrder || orderedResult === void 0)
          return orderedResult;
        else
          return prettify(orderedResult, this.options);
      }
      /**
       * Add Entity which is not by default supported by this library
       * @param {string} key 
       * @param {string} value 
       */
      addEntity(key, value) {
        if (value.indexOf("&") !== -1) {
          throw new Error("Entity value can't have '&'");
        } else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) {
          throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
        } else if (value === "&") {
          throw new Error("An entity with value '&' is not permitted");
        } else {
          this.externalEntities[key] = value;
        }
      }
    };
    module.exports = XMLParser;
  }
});

// node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js
var require_orderedJs2Xml = __commonJS({
  "node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js"(exports, module) {
    var EOL = "\n";
    function toXml(jArray, options) {
      let indentation = "";
      if (options.format && options.indentBy.length > 0) {
        indentation = EOL;
      }
      return arrToStr(jArray, options, "", indentation);
    }
    function arrToStr(arr, options, jPath, indentation) {
      let xmlStr = "";
      let isPreviousElementTag = false;
      for (let i2 = 0; i2 < arr.length; i2++) {
        const tagObj = arr[i2];
        const tagName = propName(tagObj);
        let newJPath = "";
        if (jPath.length === 0)
          newJPath = tagName;
        else
          newJPath = `${jPath}.${tagName}`;
        if (tagName === options.textNodeName) {
          let tagText = tagObj[tagName];
          if (!isStopNode(newJPath, options)) {
            tagText = options.tagValueProcessor(tagName, tagText);
            tagText = replaceEntitiesValue(tagText, options);
          }
          if (isPreviousElementTag) {
            xmlStr += indentation;
          }
          xmlStr += tagText;
          isPreviousElementTag = false;
          continue;
        } else if (tagName === options.cdataPropName) {
          if (isPreviousElementTag) {
            xmlStr += indentation;
          }
          xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
          isPreviousElementTag = false;
          continue;
        } else if (tagName === options.commentPropName) {
          xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
          isPreviousElementTag = true;
          continue;
        } else if (tagName[0] === "?") {
          const attStr2 = attr_to_str(tagObj[":@"], options);
          const tempInd = tagName === "?xml" ? "" : indentation;
          let piTextNodeName = tagObj[tagName][0][options.textNodeName];
          piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : "";
          xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr2}?>`;
          isPreviousElementTag = true;
          continue;
        }
        let newIdentation = indentation;
        if (newIdentation !== "") {
          newIdentation += options.indentBy;
        }
        const attStr = attr_to_str(tagObj[":@"], options);
        const tagStart = indentation + `<${tagName}${attStr}`;
        const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);
        if (options.unpairedTags.indexOf(tagName) !== -1) {
          if (options.suppressUnpairedNode)
            xmlStr += tagStart + ">";
          else
            xmlStr += tagStart + "/>";
        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
          xmlStr += tagStart + "/>";
        } else if (tagValue && tagValue.endsWith(">")) {
          xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
        } else {
          xmlStr += tagStart + ">";
          if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
            xmlStr += indentation + options.indentBy + tagValue + indentation;
          } else {
            xmlStr += tagValue;
          }
          xmlStr += `</${tagName}>`;
        }
        isPreviousElementTag = true;
      }
      return xmlStr;
    }
    function propName(obj) {
      const keys = Object.keys(obj);
      for (let i2 = 0; i2 < keys.length; i2++) {
        const key = keys[i2];
        if (key !== ":@")
          return key;
      }
    }
    function attr_to_str(attrMap, options) {
      let attrStr = "";
      if (attrMap && !options.ignoreAttributes) {
        for (let attr in attrMap) {
          let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
          attrVal = replaceEntitiesValue(attrVal, options);
          if (attrVal === true && options.suppressBooleanAttributes) {
            attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
          } else {
            attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
          }
        }
      }
      return attrStr;
    }
    function isStopNode(jPath, options) {
      jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
      let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
      for (let index in options.stopNodes) {
        if (options.stopNodes[index] === jPath || options.stopNodes[index] === "*." + tagName)
          return true;
      }
      return false;
    }
    function replaceEntitiesValue(textValue, options) {
      if (textValue && textValue.length > 0 && options.processEntities) {
        for (let i2 = 0; i2 < options.entities.length; i2++) {
          const entity = options.entities[i2];
          textValue = textValue.replace(entity.regex, entity.val);
        }
      }
      return textValue;
    }
    module.exports = toXml;
  }
});

// node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js
var require_json2xml = __commonJS({
  "node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js"(exports, module) {
    "use strict";
    var buildFromOrderedJs = require_orderedJs2Xml();
    var defaultOptions = {
      attributeNamePrefix: "@_",
      attributesGroupName: false,
      textNodeName: "#text",
      ignoreAttributes: true,
      cdataPropName: false,
      format: false,
      indentBy: "  ",
      suppressEmptyNode: false,
      suppressUnpairedNode: true,
      suppressBooleanAttributes: true,
      tagValueProcessor: function(key, a) {
        return a;
      },
      attributeValueProcessor: function(attrName, a) {
        return a;
      },
      preserveOrder: false,
      commentPropName: false,
      unpairedTags: [],
      entities: [
        { regex: new RegExp("&", "g"), val: "&amp;" },
        //it must be on top
        { regex: new RegExp(">", "g"), val: "&gt;" },
        { regex: new RegExp("<", "g"), val: "&lt;" },
        { regex: new RegExp("'", "g"), val: "&apos;" },
        { regex: new RegExp('"', "g"), val: "&quot;" }
      ],
      processEntities: true,
      stopNodes: [],
      // transformTagName: false,
      // transformAttributeName: false,
      oneListGroup: false
    };
    function Builder(options) {
      this.options = Object.assign({}, defaultOptions, options);
      if (this.options.ignoreAttributes || this.options.attributesGroupName) {
        this.isAttribute = function() {
          return false;
        };
      } else {
        this.attrPrefixLen = this.options.attributeNamePrefix.length;
        this.isAttribute = isAttribute;
      }
      this.processTextOrObjNode = processTextOrObjNode;
      if (this.options.format) {
        this.indentate = indentate;
        this.tagEndChar = ">\n";
        this.newLine = "\n";
      } else {
        this.indentate = function() {
          return "";
        };
        this.tagEndChar = ">";
        this.newLine = "";
      }
    }
    Builder.prototype.build = function(jObj) {
      if (this.options.preserveOrder) {
        return buildFromOrderedJs(jObj, this.options);
      } else {
        if (Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1) {
          jObj = {
            [this.options.arrayNodeName]: jObj
          };
        }
        return this.j2x(jObj, 0).val;
      }
    };
    Builder.prototype.j2x = function(jObj, level) {
      let attrStr = "";
      let val2 = "";
      for (let key in jObj) {
        if (typeof jObj[key] === "undefined") {
          if (this.isAttribute(key)) {
            val2 += "";
          }
        } else if (jObj[key] === null) {
          if (this.isAttribute(key)) {
            val2 += "";
          } else if (key[0] === "?") {
            val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
          } else {
            val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
          }
        } else if (jObj[key] instanceof Date) {
          val2 += this.buildTextValNode(jObj[key], key, "", level);
        } else if (typeof jObj[key] !== "object") {
          const attr = this.isAttribute(key);
          if (attr) {
            attrStr += this.buildAttrPairStr(attr, "" + jObj[key]);
          } else {
            if (key === this.options.textNodeName) {
              let newval = this.options.tagValueProcessor(key, "" + jObj[key]);
              val2 += this.replaceEntitiesValue(newval);
            } else {
              val2 += this.buildTextValNode(jObj[key], key, "", level);
            }
          }
        } else if (Array.isArray(jObj[key])) {
          const arrLen = jObj[key].length;
          let listTagVal = "";
          for (let j = 0; j < arrLen; j++) {
            const item = jObj[key][j];
            if (typeof item === "undefined") {
            } else if (item === null) {
              if (key[0] === "?")
                val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
              else
                val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
            } else if (typeof item === "object") {
              if (this.options.oneListGroup) {
                listTagVal += this.j2x(item, level + 1).val;
              } else {
                listTagVal += this.processTextOrObjNode(item, key, level);
              }
            } else {
              listTagVal += this.buildTextValNode(item, key, "", level);
            }
          }
          if (this.options.oneListGroup) {
            listTagVal = this.buildObjectNode(listTagVal, key, "", level);
          }
          val2 += listTagVal;
        } else {
          if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
            const Ks = Object.keys(jObj[key]);
            const L = Ks.length;
            for (let j = 0; j < L; j++) {
              attrStr += this.buildAttrPairStr(Ks[j], "" + jObj[key][Ks[j]]);
            }
          } else {
            val2 += this.processTextOrObjNode(jObj[key], key, level);
          }
        }
      }
      return { attrStr, val: val2 };
    };
    Builder.prototype.buildAttrPairStr = function(attrName, val2) {
      val2 = this.options.attributeValueProcessor(attrName, "" + val2);
      val2 = this.replaceEntitiesValue(val2);
      if (this.options.suppressBooleanAttributes && val2 === "true") {
        return " " + attrName;
      } else
        return " " + attrName + '="' + val2 + '"';
    };
    function processTextOrObjNode(object, key, level) {
      const result = this.j2x(object, level + 1);
      if (object[this.options.textNodeName] !== void 0 && Object.keys(object).length === 1) {
        return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);
      } else {
        return this.buildObjectNode(result.val, key, result.attrStr, level);
      }
    }
    Builder.prototype.buildObjectNode = function(val2, key, attrStr, level) {
      if (val2 === "") {
        if (key[0] === "?")
          return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
        else {
          return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
        }
      } else {
        let tagEndExp = "</" + key + this.tagEndChar;
        let piClosingChar = "";
        if (key[0] === "?") {
          piClosingChar = "?";
          tagEndExp = "";
        }
        if ((attrStr || attrStr === "") && val2.indexOf("<") === -1) {
          return this.indentate(level) + "<" + key + attrStr + piClosingChar + ">" + val2 + tagEndExp;
        } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
          return this.indentate(level) + `<!--${val2}-->` + this.newLine;
        } else {
          return this.indentate(level) + "<" + key + attrStr + piClosingChar + this.tagEndChar + val2 + this.indentate(level) + tagEndExp;
        }
      }
    };
    Builder.prototype.closeTag = function(key) {
      let closeTag = "";
      if (this.options.unpairedTags.indexOf(key) !== -1) {
        if (!this.options.suppressUnpairedNode)
          closeTag = "/";
      } else if (this.options.suppressEmptyNode) {
        closeTag = "/";
      } else {
        closeTag = `></${key}`;
      }
      return closeTag;
    };
    Builder.prototype.buildTextValNode = function(val2, key, attrStr, level) {
      if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
        return this.indentate(level) + `<![CDATA[${val2}]]>` + this.newLine;
      } else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
        return this.indentate(level) + `<!--${val2}-->` + this.newLine;
      } else if (key[0] === "?") {
        return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
      } else {
        let textValue = this.options.tagValueProcessor(key, val2);
        textValue = this.replaceEntitiesValue(textValue);
        if (textValue === "") {
          return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
        } else {
          return this.indentate(level) + "<" + key + attrStr + ">" + textValue + "</" + key + this.tagEndChar;
        }
      }
    };
    Builder.prototype.replaceEntitiesValue = function(textValue) {
      if (textValue && textValue.length > 0 && this.options.processEntities) {
        for (let i2 = 0; i2 < this.options.entities.length; i2++) {
          const entity = this.options.entities[i2];
          textValue = textValue.replace(entity.regex, entity.val);
        }
      }
      return textValue;
    };
    function indentate(level) {
      return this.options.indentBy.repeat(level);
    }
    function isAttribute(name) {
      if (name.startsWith(this.options.attributeNamePrefix) && name !== this.options.textNodeName) {
        return name.substr(this.attrPrefixLen);
      } else {
        return false;
      }
    }
    module.exports = Builder;
  }
});

// node_modules/fast-xml-parser/src/fxp.js
var require_fxp = __commonJS({
  "node_modules/fast-xml-parser/src/fxp.js"(exports, module) {
    "use strict";
    var validator = require_validator();
    var XMLParser = require_XMLParser();
    var XMLBuilder = require_json2xml();
    module.exports = {
      XMLParser,
      XMLValidator: validator,
      XMLBuilder
    };
  }
});

// node_modules/long/dist/long.js
var require_long = __commonJS({
  "node_modules/long/dist/long.js"(exports, module) {
    (function(global, factory) {
      if (typeof define === "function" && define["amd"])
        define([], factory);
      else if (typeof __require === "function" && typeof module === "object" && module && module["exports"])
        module["exports"] = factory();
      else
        (global["dcodeIO"] = global["dcodeIO"] || {})["Long"] = factory();
    })(exports, function() {
      "use strict";
      function Long3(low, high, unsigned) {
        this.low = low | 0;
        this.high = high | 0;
        this.unsigned = !!unsigned;
      }
      Long3.prototype.__isLong__;
      Object.defineProperty(Long3.prototype, "__isLong__", {
        value: true,
        enumerable: false,
        configurable: false
      });
      function isLong(obj) {
        return (obj && obj["__isLong__"]) === true;
      }
      Long3.isLong = isLong;
      var INT_CACHE = {};
      var UINT_CACHE = {};
      function fromInt(value, unsigned) {
        var obj, cachedObj, cache;
        if (unsigned) {
          value >>>= 0;
          if (cache = 0 <= value && value < 256) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
              return cachedObj;
          }
          obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
          if (cache)
            UINT_CACHE[value] = obj;
          return obj;
        } else {
          value |= 0;
          if (cache = -128 <= value && value < 128) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
              return cachedObj;
          }
          obj = fromBits(value, value < 0 ? -1 : 0, false);
          if (cache)
            INT_CACHE[value] = obj;
          return obj;
        }
      }
      Long3.fromInt = fromInt;
      function fromNumber(value, unsigned) {
        if (isNaN(value) || !isFinite(value))
          return unsigned ? UZERO : ZERO;
        if (unsigned) {
          if (value < 0)
            return UZERO;
          if (value >= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
        } else {
          if (value <= -TWO_PWR_63_DBL)
            return MIN_VALUE;
          if (value + 1 >= TWO_PWR_63_DBL)
            return MAX_VALUE;
        }
        if (value < 0)
          return fromNumber(-value, unsigned).neg();
        return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
      }
      Long3.fromNumber = fromNumber;
      function fromBits(lowBits, highBits, unsigned) {
        return new Long3(lowBits, highBits, unsigned);
      }
      Long3.fromBits = fromBits;
      var pow_dbl = Math.pow;
      function fromString(str, unsigned, radix) {
        if (str.length === 0)
          throw Error("empty string");
        if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
          return ZERO;
        if (typeof unsigned === "number") {
          radix = unsigned, unsigned = false;
        } else {
          unsigned = !!unsigned;
        }
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
          throw RangeError("radix");
        var p;
        if ((p = str.indexOf("-")) > 0)
          throw Error("interior hyphen");
        else if (p === 0) {
          return fromString(str.substring(1), unsigned, radix).neg();
        }
        var radixToPower = fromNumber(pow_dbl(radix, 8));
        var result = ZERO;
        for (var i2 = 0; i2 < str.length; i2 += 8) {
          var size = Math.min(8, str.length - i2), value = parseInt(str.substring(i2, i2 + size), radix);
          if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
          } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
          }
        }
        result.unsigned = unsigned;
        return result;
      }
      Long3.fromString = fromString;
      function fromValue(val2) {
        if (val2 instanceof Long3)
          return val2;
        if (typeof val2 === "number")
          return fromNumber(val2);
        if (typeof val2 === "string")
          return fromString(val2);
        return fromBits(val2.low, val2.high, val2.unsigned);
      }
      Long3.fromValue = fromValue;
      var TWO_PWR_16_DBL = 1 << 16;
      var TWO_PWR_24_DBL = 1 << 24;
      var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
      var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
      var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
      var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
      var ZERO = fromInt(0);
      Long3.ZERO = ZERO;
      var UZERO = fromInt(0, true);
      Long3.UZERO = UZERO;
      var ONE = fromInt(1);
      Long3.ONE = ONE;
      var UONE = fromInt(1, true);
      Long3.UONE = UONE;
      var NEG_ONE = fromInt(-1);
      Long3.NEG_ONE = NEG_ONE;
      var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
      Long3.MAX_VALUE = MAX_VALUE;
      var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
      Long3.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
      var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
      Long3.MIN_VALUE = MIN_VALUE;
      var LongPrototype = Long3.prototype;
      LongPrototype.toInt = function toInt() {
        return this.unsigned ? this.low >>> 0 : this.low;
      };
      LongPrototype.toNumber = function toNumber() {
        if (this.unsigned)
          return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
      };
      LongPrototype.toString = function toString(radix) {
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
          throw RangeError("radix");
        if (this.isZero())
          return "0";
        if (this.isNegative()) {
          if (this.eq(MIN_VALUE)) {
            var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
          } else
            return "-" + this.neg().toString(radix);
        }
        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
        var result = "";
        while (true) {
          var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
          rem = remDiv;
          if (rem.isZero())
            return digits + result;
          else {
            while (digits.length < 6)
              digits = "0" + digits;
            result = "" + digits + result;
          }
        }
      };
      LongPrototype.getHighBits = function getHighBits() {
        return this.high;
      };
      LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
        return this.high >>> 0;
      };
      LongPrototype.getLowBits = function getLowBits() {
        return this.low;
      };
      LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
        return this.low >>> 0;
      };
      LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
        if (this.isNegative())
          return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
        var val2 = this.high != 0 ? this.high : this.low;
        for (var bit = 31; bit > 0; bit--)
          if ((val2 & 1 << bit) != 0)
            break;
        return this.high != 0 ? bit + 33 : bit + 1;
      };
      LongPrototype.isZero = function isZero() {
        return this.high === 0 && this.low === 0;
      };
      LongPrototype.isNegative = function isNegative() {
        return !this.unsigned && this.high < 0;
      };
      LongPrototype.isPositive = function isPositive() {
        return this.unsigned || this.high >= 0;
      };
      LongPrototype.isOdd = function isOdd() {
        return (this.low & 1) === 1;
      };
      LongPrototype.isEven = function isEven() {
        return (this.low & 1) === 0;
      };
      LongPrototype.equals = function equals2(other) {
        if (!isLong(other))
          other = fromValue(other);
        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
          return false;
        return this.high === other.high && this.low === other.low;
      };
      LongPrototype.eq = LongPrototype.equals;
      LongPrototype.notEquals = function notEquals(other) {
        return !this.eq(
          /* validates */
          other
        );
      };
      LongPrototype.neq = LongPrototype.notEquals;
      LongPrototype.lessThan = function lessThan(other) {
        return this.comp(
          /* validates */
          other
        ) < 0;
      };
      LongPrototype.lt = LongPrototype.lessThan;
      LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
        return this.comp(
          /* validates */
          other
        ) <= 0;
      };
      LongPrototype.lte = LongPrototype.lessThanOrEqual;
      LongPrototype.greaterThan = function greaterThan(other) {
        return this.comp(
          /* validates */
          other
        ) > 0;
      };
      LongPrototype.gt = LongPrototype.greaterThan;
      LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
        return this.comp(
          /* validates */
          other
        ) >= 0;
      };
      LongPrototype.gte = LongPrototype.greaterThanOrEqual;
      LongPrototype.compare = function compare(other) {
        if (!isLong(other))
          other = fromValue(other);
        if (this.eq(other))
          return 0;
        var thisNeg = this.isNegative(), otherNeg = other.isNegative();
        if (thisNeg && !otherNeg)
          return -1;
        if (!thisNeg && otherNeg)
          return 1;
        if (!this.unsigned)
          return this.sub(other).isNegative() ? -1 : 1;
        return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
      };
      LongPrototype.comp = LongPrototype.compare;
      LongPrototype.negate = function negate() {
        if (!this.unsigned && this.eq(MIN_VALUE))
          return MIN_VALUE;
        return this.not().add(ONE);
      };
      LongPrototype.neg = LongPrototype.negate;
      LongPrototype.add = function add(addend) {
        if (!isLong(addend))
          addend = fromValue(addend);
        var a48 = this.high >>> 16;
        var a32 = this.high & 65535;
        var a16 = this.low >>> 16;
        var a00 = this.low & 65535;
        var b48 = addend.high >>> 16;
        var b32 = addend.high & 65535;
        var b16 = addend.low >>> 16;
        var b00 = addend.low & 65535;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 + b48;
        c48 &= 65535;
        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      };
      LongPrototype.subtract = function subtract(subtrahend) {
        if (!isLong(subtrahend))
          subtrahend = fromValue(subtrahend);
        return this.add(subtrahend.neg());
      };
      LongPrototype.sub = LongPrototype.subtract;
      LongPrototype.multiply = function multiply(multiplier) {
        if (this.isZero())
          return ZERO;
        if (!isLong(multiplier))
          multiplier = fromValue(multiplier);
        if (multiplier.isZero())
          return ZERO;
        if (this.eq(MIN_VALUE))
          return multiplier.isOdd() ? MIN_VALUE : ZERO;
        if (multiplier.eq(MIN_VALUE))
          return this.isOdd() ? MIN_VALUE : ZERO;
        if (this.isNegative()) {
          if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
          else
            return this.neg().mul(multiplier).neg();
        } else if (multiplier.isNegative())
          return this.mul(multiplier.neg()).neg();
        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
          return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
        var a48 = this.high >>> 16;
        var a32 = this.high & 65535;
        var a16 = this.low >>> 16;
        var a00 = this.low & 65535;
        var b48 = multiplier.high >>> 16;
        var b32 = multiplier.high & 65535;
        var b16 = multiplier.low >>> 16;
        var b00 = multiplier.low & 65535;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 65535;
        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      };
      LongPrototype.mul = LongPrototype.multiply;
      LongPrototype.divide = function divide(divisor) {
        if (!isLong(divisor))
          divisor = fromValue(divisor);
        if (divisor.isZero())
          throw Error("division by zero");
        if (this.isZero())
          return this.unsigned ? UZERO : ZERO;
        var approx, rem, res;
        if (!this.unsigned) {
          if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
              return MIN_VALUE;
            else if (divisor.eq(MIN_VALUE))
              return ONE;
            else {
              var halfThis = this.shr(1);
              approx = halfThis.div(divisor).shl(1);
              if (approx.eq(ZERO)) {
                return divisor.isNegative() ? ONE : NEG_ONE;
              } else {
                rem = this.sub(divisor.mul(approx));
                res = approx.add(rem.div(divisor));
                return res;
              }
            }
          } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
          if (this.isNegative()) {
            if (divisor.isNegative())
              return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
          } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
          res = ZERO;
        } else {
          if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
          if (divisor.gt(this))
            return UZERO;
          if (divisor.gt(this.shru(1)))
            return UONE;
          res = UZERO;
        }
        rem = this;
        while (rem.gte(divisor)) {
          approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
          var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
          while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
          }
          if (approxRes.isZero())
            approxRes = ONE;
          res = res.add(approxRes);
          rem = rem.sub(approxRem);
        }
        return res;
      };
      LongPrototype.div = LongPrototype.divide;
      LongPrototype.modulo = function modulo(divisor) {
        if (!isLong(divisor))
          divisor = fromValue(divisor);
        return this.sub(this.div(divisor).mul(divisor));
      };
      LongPrototype.mod = LongPrototype.modulo;
      LongPrototype.not = function not() {
        return fromBits(~this.low, ~this.high, this.unsigned);
      };
      LongPrototype.and = function and(other) {
        if (!isLong(other))
          other = fromValue(other);
        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
      };
      LongPrototype.or = function or(other) {
        if (!isLong(other))
          other = fromValue(other);
        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
      };
      LongPrototype.xor = function xor(other) {
        if (!isLong(other))
          other = fromValue(other);
        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
      };
      LongPrototype.shiftLeft = function shiftLeft(numBits) {
        if (isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        else if (numBits < 32)
          return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
        else
          return fromBits(0, this.low << numBits - 32, this.unsigned);
      };
      LongPrototype.shl = LongPrototype.shiftLeft;
      LongPrototype.shiftRight = function shiftRight(numBits) {
        if (isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        else if (numBits < 32)
          return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
        else
          return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
      };
      LongPrototype.shr = LongPrototype.shiftRight;
      LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
        if (isLong(numBits))
          numBits = numBits.toInt();
        numBits &= 63;
        if (numBits === 0)
          return this;
        else {
          var high = this.high;
          if (numBits < 32) {
            var low = this.low;
            return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
          } else if (numBits === 32)
            return fromBits(high, 0, this.unsigned);
          else
            return fromBits(high >>> numBits - 32, 0, this.unsigned);
        }
      };
      LongPrototype.shru = LongPrototype.shiftRightUnsigned;
      LongPrototype.toSigned = function toSigned() {
        if (!this.unsigned)
          return this;
        return fromBits(this.low, this.high, false);
      };
      LongPrototype.toUnsigned = function toUnsigned() {
        if (this.unsigned)
          return this;
        return fromBits(this.low, this.high, true);
      };
      LongPrototype.toBytes = function(le) {
        return le ? this.toBytesLE() : this.toBytesBE();
      };
      LongPrototype.toBytesLE = function() {
        var hi = this.high, lo = this.low;
        return [
          lo & 255,
          lo >>> 8 & 255,
          lo >>> 16 & 255,
          lo >>> 24 & 255,
          hi & 255,
          hi >>> 8 & 255,
          hi >>> 16 & 255,
          hi >>> 24 & 255
        ];
      };
      LongPrototype.toBytesBE = function() {
        var hi = this.high, lo = this.low;
        return [
          hi >>> 24 & 255,
          hi >>> 16 & 255,
          hi >>> 8 & 255,
          hi & 255,
          lo >>> 24 & 255,
          lo >>> 16 & 255,
          lo >>> 8 & 255,
          lo & 255
        ];
      };
      return Long3;
    });
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i2 = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i2];
      i2 += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i2], i2 += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i2], i2 += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i2 = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i2] = m & 255, i2 += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i2] = e & 255, i2 += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i2 - d] |= s * 128;
    };
  }
});

// node_modules/pbf/index.js
var require_pbf = __commonJS({
  "node_modules/pbf/index.js"(exports, module) {
    "use strict";
    module.exports = Pbf;
    var ieee754 = require_ieee754();
    function Pbf(buf) {
      this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
      this.pos = 0;
      this.type = 0;
      this.length = this.buf.length;
    }
    Pbf.Varint = 0;
    Pbf.Fixed64 = 1;
    Pbf.Bytes = 2;
    Pbf.Fixed32 = 5;
    var SHIFT_LEFT_32 = (1 << 16) * (1 << 16);
    var SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
    var TEXT_DECODER_MIN_LENGTH = 12;
    var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf8");
    Pbf.prototype = {
      destroy: function() {
        this.buf = null;
      },
      // === READING =================================================================
      readFields: function(readField, result, end) {
        end = end || this.length;
        while (this.pos < end) {
          var val2 = this.readVarint(), tag = val2 >> 3, startPos = this.pos;
          this.type = val2 & 7;
          readField(tag, result, this);
          if (this.pos === startPos)
            this.skip(val2);
        }
        return result;
      },
      readMessage: function(readField, result) {
        return this.readFields(readField, result, this.readVarint() + this.pos);
      },
      readFixed32: function() {
        var val2 = readUInt32(this.buf, this.pos);
        this.pos += 4;
        return val2;
      },
      readSFixed32: function() {
        var val2 = readInt32(this.buf, this.pos);
        this.pos += 4;
        return val2;
      },
      // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)
      readFixed64: function() {
        var val2 = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val2;
      },
      readSFixed64: function() {
        var val2 = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val2;
      },
      readFloat: function() {
        var val2 = ieee754.read(this.buf, this.pos, true, 23, 4);
        this.pos += 4;
        return val2;
      },
      readDouble: function() {
        var val2 = ieee754.read(this.buf, this.pos, true, 52, 8);
        this.pos += 8;
        return val2;
      },
      readVarint: function(isSigned) {
        var buf = this.buf, val2, b;
        b = buf[this.pos++];
        val2 = b & 127;
        if (b < 128)
          return val2;
        b = buf[this.pos++];
        val2 |= (b & 127) << 7;
        if (b < 128)
          return val2;
        b = buf[this.pos++];
        val2 |= (b & 127) << 14;
        if (b < 128)
          return val2;
        b = buf[this.pos++];
        val2 |= (b & 127) << 21;
        if (b < 128)
          return val2;
        b = buf[this.pos];
        val2 |= (b & 15) << 28;
        return readVarintRemainder(val2, isSigned, this);
      },
      readVarint64: function() {
        return this.readVarint(true);
      },
      readSVarint: function() {
        var num = this.readVarint();
        return num % 2 === 1 ? (num + 1) / -2 : num / 2;
      },
      readBoolean: function() {
        return Boolean(this.readVarint());
      },
      readString: function() {
        var end = this.readVarint() + this.pos;
        var pos = this.pos;
        this.pos = end;
        if (end - pos >= TEXT_DECODER_MIN_LENGTH && utf8TextDecoder) {
          return readUtf8TextDecoder(this.buf, pos, end);
        }
        return readUtf8(this.buf, pos, end);
      },
      readBytes: function() {
        var end = this.readVarint() + this.pos, buffer = this.buf.subarray(this.pos, end);
        this.pos = end;
        return buffer;
      },
      // verbose for performance reasons; doesn't affect gzipped size
      readPackedVarint: function(arr, isSigned) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readVarint(isSigned));
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readVarint(isSigned));
        return arr;
      },
      readPackedSVarint: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readSVarint());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readSVarint());
        return arr;
      },
      readPackedBoolean: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readBoolean());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readBoolean());
        return arr;
      },
      readPackedFloat: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readFloat());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readFloat());
        return arr;
      },
      readPackedDouble: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readDouble());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readDouble());
        return arr;
      },
      readPackedFixed32: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readFixed32());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readFixed32());
        return arr;
      },
      readPackedSFixed32: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readSFixed32());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readSFixed32());
        return arr;
      },
      readPackedFixed64: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readFixed64());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readFixed64());
        return arr;
      },
      readPackedSFixed64: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readSFixed64());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readSFixed64());
        return arr;
      },
      skip: function(val2) {
        var type = val2 & 7;
        if (type === Pbf.Varint)
          while (this.buf[this.pos++] > 127) {
          }
        else if (type === Pbf.Bytes)
          this.pos = this.readVarint() + this.pos;
        else if (type === Pbf.Fixed32)
          this.pos += 4;
        else if (type === Pbf.Fixed64)
          this.pos += 8;
        else
          throw new Error("Unimplemented type: " + type);
      },
      // === WRITING =================================================================
      writeTag: function(tag, type) {
        this.writeVarint(tag << 3 | type);
      },
      realloc: function(min) {
        var length2 = this.length || 16;
        while (length2 < this.pos + min)
          length2 *= 2;
        if (length2 !== this.length) {
          var buf = new Uint8Array(length2);
          buf.set(this.buf);
          this.buf = buf;
          this.length = length2;
        }
      },
      finish: function() {
        this.length = this.pos;
        this.pos = 0;
        return this.buf.subarray(0, this.length);
      },
      writeFixed32: function(val2) {
        this.realloc(4);
        writeInt32(this.buf, val2, this.pos);
        this.pos += 4;
      },
      writeSFixed32: function(val2) {
        this.realloc(4);
        writeInt32(this.buf, val2, this.pos);
        this.pos += 4;
      },
      writeFixed64: function(val2) {
        this.realloc(8);
        writeInt32(this.buf, val2 & -1, this.pos);
        writeInt32(this.buf, Math.floor(val2 * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
      },
      writeSFixed64: function(val2) {
        this.realloc(8);
        writeInt32(this.buf, val2 & -1, this.pos);
        writeInt32(this.buf, Math.floor(val2 * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
      },
      writeVarint: function(val2) {
        val2 = +val2 || 0;
        if (val2 > 268435455 || val2 < 0) {
          writeBigVarint(val2, this);
          return;
        }
        this.realloc(4);
        this.buf[this.pos++] = val2 & 127 | (val2 > 127 ? 128 : 0);
        if (val2 <= 127)
          return;
        this.buf[this.pos++] = (val2 >>>= 7) & 127 | (val2 > 127 ? 128 : 0);
        if (val2 <= 127)
          return;
        this.buf[this.pos++] = (val2 >>>= 7) & 127 | (val2 > 127 ? 128 : 0);
        if (val2 <= 127)
          return;
        this.buf[this.pos++] = val2 >>> 7 & 127;
      },
      writeSVarint: function(val2) {
        this.writeVarint(val2 < 0 ? -val2 * 2 - 1 : val2 * 2);
      },
      writeBoolean: function(val2) {
        this.writeVarint(Boolean(val2));
      },
      writeString: function(str) {
        str = String(str);
        this.realloc(str.length * 4);
        this.pos++;
        var startPos = this.pos;
        this.pos = writeUtf8(this.buf, str, this.pos);
        var len = this.pos - startPos;
        if (len >= 128)
          makeRoomForExtraLength(startPos, len, this);
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
      },
      writeFloat: function(val2) {
        this.realloc(4);
        ieee754.write(this.buf, val2, this.pos, true, 23, 4);
        this.pos += 4;
      },
      writeDouble: function(val2) {
        this.realloc(8);
        ieee754.write(this.buf, val2, this.pos, true, 52, 8);
        this.pos += 8;
      },
      writeBytes: function(buffer) {
        var len = buffer.length;
        this.writeVarint(len);
        this.realloc(len);
        for (var i2 = 0; i2 < len; i2++)
          this.buf[this.pos++] = buffer[i2];
      },
      writeRawMessage: function(fn, obj) {
        this.pos++;
        var startPos = this.pos;
        fn(obj, this);
        var len = this.pos - startPos;
        if (len >= 128)
          makeRoomForExtraLength(startPos, len, this);
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
      },
      writeMessage: function(tag, fn, obj) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeRawMessage(fn, obj);
      },
      writePackedVarint: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedVarint, arr);
      },
      writePackedSVarint: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedSVarint, arr);
      },
      writePackedBoolean: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedBoolean, arr);
      },
      writePackedFloat: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedFloat, arr);
      },
      writePackedDouble: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedDouble, arr);
      },
      writePackedFixed32: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedFixed32, arr);
      },
      writePackedSFixed32: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedSFixed32, arr);
      },
      writePackedFixed64: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedFixed64, arr);
      },
      writePackedSFixed64: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedSFixed64, arr);
      },
      writeBytesField: function(tag, buffer) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeBytes(buffer);
      },
      writeFixed32Field: function(tag, val2) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFixed32(val2);
      },
      writeSFixed32Field: function(tag, val2) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeSFixed32(val2);
      },
      writeFixed64Field: function(tag, val2) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeFixed64(val2);
      },
      writeSFixed64Field: function(tag, val2) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeSFixed64(val2);
      },
      writeVarintField: function(tag, val2) {
        this.writeTag(tag, Pbf.Varint);
        this.writeVarint(val2);
      },
      writeSVarintField: function(tag, val2) {
        this.writeTag(tag, Pbf.Varint);
        this.writeSVarint(val2);
      },
      writeStringField: function(tag, str) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeString(str);
      },
      writeFloatField: function(tag, val2) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFloat(val2);
      },
      writeDoubleField: function(tag, val2) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeDouble(val2);
      },
      writeBooleanField: function(tag, val2) {
        this.writeVarintField(tag, Boolean(val2));
      }
    };
    function readVarintRemainder(l, s, p) {
      var buf = p.buf, h, b;
      b = buf[p.pos++];
      h = (b & 112) >> 4;
      if (b < 128)
        return toNum(l, h, s);
      b = buf[p.pos++];
      h |= (b & 127) << 3;
      if (b < 128)
        return toNum(l, h, s);
      b = buf[p.pos++];
      h |= (b & 127) << 10;
      if (b < 128)
        return toNum(l, h, s);
      b = buf[p.pos++];
      h |= (b & 127) << 17;
      if (b < 128)
        return toNum(l, h, s);
      b = buf[p.pos++];
      h |= (b & 127) << 24;
      if (b < 128)
        return toNum(l, h, s);
      b = buf[p.pos++];
      h |= (b & 1) << 31;
      if (b < 128)
        return toNum(l, h, s);
      throw new Error("Expected varint not more than 10 bytes");
    }
    function readPackedEnd(pbf) {
      return pbf.type === Pbf.Bytes ? pbf.readVarint() + pbf.pos : pbf.pos + 1;
    }
    function toNum(low, high, isSigned) {
      if (isSigned) {
        return high * 4294967296 + (low >>> 0);
      }
      return (high >>> 0) * 4294967296 + (low >>> 0);
    }
    function writeBigVarint(val2, pbf) {
      var low, high;
      if (val2 >= 0) {
        low = val2 % 4294967296 | 0;
        high = val2 / 4294967296 | 0;
      } else {
        low = ~(-val2 % 4294967296);
        high = ~(-val2 / 4294967296);
        if (low ^ 4294967295) {
          low = low + 1 | 0;
        } else {
          low = 0;
          high = high + 1 | 0;
        }
      }
      if (val2 >= 18446744073709552e3 || val2 < -18446744073709552e3) {
        throw new Error("Given varint doesn't fit into 10 bytes");
      }
      pbf.realloc(10);
      writeBigVarintLow(low, high, pbf);
      writeBigVarintHigh(high, pbf);
    }
    function writeBigVarintLow(low, high, pbf) {
      pbf.buf[pbf.pos++] = low & 127 | 128;
      low >>>= 7;
      pbf.buf[pbf.pos++] = low & 127 | 128;
      low >>>= 7;
      pbf.buf[pbf.pos++] = low & 127 | 128;
      low >>>= 7;
      pbf.buf[pbf.pos++] = low & 127 | 128;
      low >>>= 7;
      pbf.buf[pbf.pos] = low & 127;
    }
    function writeBigVarintHigh(high, pbf) {
      var lsb = (high & 7) << 4;
      pbf.buf[pbf.pos++] |= lsb | ((high >>>= 3) ? 128 : 0);
      if (!high)
        return;
      pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
      if (!high)
        return;
      pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
      if (!high)
        return;
      pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
      if (!high)
        return;
      pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
      if (!high)
        return;
      pbf.buf[pbf.pos++] = high & 127;
    }
    function makeRoomForExtraLength(startPos, len, pbf) {
      var extraLen = len <= 16383 ? 1 : len <= 2097151 ? 2 : len <= 268435455 ? 3 : Math.floor(Math.log(len) / (Math.LN2 * 7));
      pbf.realloc(extraLen);
      for (var i2 = pbf.pos - 1; i2 >= startPos; i2--)
        pbf.buf[i2 + extraLen] = pbf.buf[i2];
    }
    function writePackedVarint(arr, pbf) {
      for (var i2 = 0; i2 < arr.length; i2++)
        pbf.writeVarint(arr[i2]);
    }
    function writePackedSVarint(arr, pbf) {
      for (var i2 = 0; i2 < arr.length; i2++)
        pbf.writeSVarint(arr[i2]);
    }
    function writePackedFloat(arr, pbf) {
      for (var i2 = 0; i2 < arr.length; i2++)
        pbf.writeFloat(arr[i2]);
    }
    function writePackedDouble(arr, pbf) {
      for (var i2 = 0; i2 < arr.length; i2++)
        pbf.writeDouble(arr[i2]);
    }
    function writePackedBoolean(arr, pbf) {
      for (var i2 = 0; i2 < arr.length; i2++)
        pbf.writeBoolean(arr[i2]);
    }
    function writePackedFixed32(arr, pbf) {
      for (var i2 = 0; i2 < arr.length; i2++)
        pbf.writeFixed32(arr[i2]);
    }
    function writePackedSFixed32(arr, pbf) {
      for (var i2 = 0; i2 < arr.length; i2++)
        pbf.writeSFixed32(arr[i2]);
    }
    function writePackedFixed64(arr, pbf) {
      for (var i2 = 0; i2 < arr.length; i2++)
        pbf.writeFixed64(arr[i2]);
    }
    function writePackedSFixed64(arr, pbf) {
      for (var i2 = 0; i2 < arr.length; i2++)
        pbf.writeSFixed64(arr[i2]);
    }
    function readUInt32(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + buf[pos + 3] * 16777216;
    }
    function writeInt32(buf, val2, pos) {
      buf[pos] = val2;
      buf[pos + 1] = val2 >>> 8;
      buf[pos + 2] = val2 >>> 16;
      buf[pos + 3] = val2 >>> 24;
    }
    function readInt32(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + (buf[pos + 3] << 24);
    }
    function readUtf8(buf, pos, end) {
      var str = "";
      var i2 = pos;
      while (i2 < end) {
        var b0 = buf[i2];
        var c = null;
        var bytesPerSequence = b0 > 239 ? 4 : b0 > 223 ? 3 : b0 > 191 ? 2 : 1;
        if (i2 + bytesPerSequence > end)
          break;
        var b1, b2, b3;
        if (bytesPerSequence === 1) {
          if (b0 < 128) {
            c = b0;
          }
        } else if (bytesPerSequence === 2) {
          b1 = buf[i2 + 1];
          if ((b1 & 192) === 128) {
            c = (b0 & 31) << 6 | b1 & 63;
            if (c <= 127) {
              c = null;
            }
          }
        } else if (bytesPerSequence === 3) {
          b1 = buf[i2 + 1];
          b2 = buf[i2 + 2];
          if ((b1 & 192) === 128 && (b2 & 192) === 128) {
            c = (b0 & 15) << 12 | (b1 & 63) << 6 | b2 & 63;
            if (c <= 2047 || c >= 55296 && c <= 57343) {
              c = null;
            }
          }
        } else if (bytesPerSequence === 4) {
          b1 = buf[i2 + 1];
          b2 = buf[i2 + 2];
          b3 = buf[i2 + 3];
          if ((b1 & 192) === 128 && (b2 & 192) === 128 && (b3 & 192) === 128) {
            c = (b0 & 15) << 18 | (b1 & 63) << 12 | (b2 & 63) << 6 | b3 & 63;
            if (c <= 65535 || c >= 1114112) {
              c = null;
            }
          }
        }
        if (c === null) {
          c = 65533;
          bytesPerSequence = 1;
        } else if (c > 65535) {
          c -= 65536;
          str += String.fromCharCode(c >>> 10 & 1023 | 55296);
          c = 56320 | c & 1023;
        }
        str += String.fromCharCode(c);
        i2 += bytesPerSequence;
      }
      return str;
    }
    function readUtf8TextDecoder(buf, pos, end) {
      return utf8TextDecoder.decode(buf.subarray(pos, end));
    }
    function writeUtf8(buf, str, pos) {
      for (var i2 = 0, c, lead; i2 < str.length; i2++) {
        c = str.charCodeAt(i2);
        if (c > 55295 && c < 57344) {
          if (lead) {
            if (c < 56320) {
              buf[pos++] = 239;
              buf[pos++] = 191;
              buf[pos++] = 189;
              lead = c;
              continue;
            } else {
              c = lead - 55296 << 10 | c - 56320 | 65536;
              lead = null;
            }
          } else {
            if (c > 56319 || i2 + 1 === str.length) {
              buf[pos++] = 239;
              buf[pos++] = 191;
              buf[pos++] = 189;
            } else {
              lead = c;
            }
            continue;
          }
        } else if (lead) {
          buf[pos++] = 239;
          buf[pos++] = 191;
          buf[pos++] = 189;
          lead = null;
        }
        if (c < 128) {
          buf[pos++] = c;
        } else {
          if (c < 2048) {
            buf[pos++] = c >> 6 | 192;
          } else {
            if (c < 65536) {
              buf[pos++] = c >> 12 | 224;
            } else {
              buf[pos++] = c >> 18 | 240;
              buf[pos++] = c >> 12 & 63 | 128;
            }
            buf[pos++] = c >> 6 & 63 | 128;
          }
          buf[pos++] = c & 63 | 128;
        }
      }
      return pos;
    }
  }
});

// node_modules/@loaders.gl/xml/dist/esm/sax-ts/sax.js
var DEFAULT_SAX_EVENTS = {
  ontext: () => {
  },
  onprocessinginstruction: () => {
  },
  onsgmldeclaration: () => {
  },
  ondoctype: () => {
  },
  oncomment: () => {
  },
  onopentagstart: () => {
  },
  onattribute: () => {
  },
  onopentag: () => {
  },
  onclosetag: () => {
  },
  onopencdata: () => {
  },
  oncdata: () => {
  },
  onclosecdata: () => {
  },
  onerror: () => {
  },
  onend: () => {
  },
  onready: () => {
  },
  onscript: () => {
  },
  onopennamespace: () => {
  },
  onclosenamespace: () => {
  }
};
var DEFAULT_SAX_PARSER_OPTIONS = {
  ...DEFAULT_SAX_EVENTS,
  strict: false,
  MAX_BUFFER_LENGTH: 64 * 1024,
  lowercase: false,
  lowercasetags: false,
  noscript: false,
  strictEntities: false,
  xmlns: void 0,
  position: void 0,
  trim: void 0,
  normalize: void 0
};
var EVENTS = ["text", "processinginstruction", "sgmldeclaration", "doctype", "comment", "opentagstart", "attribute", "opentag", "closetag", "opencdata", "cdata", "closecdata", "error", "end", "ready", "script", "opennamespace", "closenamespace"];
var BUFFERS = ["comment", "sgmlDecl", "textNode", "tagName", "doctype", "procInstName", "procInstBody", "entity", "attribName", "attribValue", "cdata", "script"];
var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
var ENTITIES = {
  amp: "&",
  gt: ">",
  lt: "<",
  quot: '"',
  apos: "'",
  AElig: 198,
  Aacute: 193,
  Acirc: 194,
  Agrave: 192,
  Aring: 197,
  Atilde: 195,
  Auml: 196,
  Ccedil: 199,
  ETH: 208,
  Eacute: 201,
  Ecirc: 202,
  Egrave: 200,
  Euml: 203,
  Iacute: 205,
  Icirc: 206,
  Igrave: 204,
  Iuml: 207,
  Ntilde: 209,
  Oacute: 211,
  Ocirc: 212,
  Ograve: 210,
  Oslash: 216,
  Otilde: 213,
  Ouml: 214,
  THORN: 222,
  Uacute: 218,
  Ucirc: 219,
  Ugrave: 217,
  Uuml: 220,
  Yacute: 221,
  aacute: 225,
  acirc: 226,
  aelig: 230,
  agrave: 224,
  aring: 229,
  atilde: 227,
  auml: 228,
  ccedil: 231,
  eacute: 233,
  ecirc: 234,
  egrave: 232,
  eth: 240,
  euml: 235,
  iacute: 237,
  icirc: 238,
  igrave: 236,
  iuml: 239,
  ntilde: 241,
  oacute: 243,
  ocirc: 244,
  ograve: 242,
  oslash: 248,
  otilde: 245,
  ouml: 246,
  szlig: 223,
  thorn: 254,
  uacute: 250,
  ucirc: 251,
  ugrave: 249,
  uuml: 252,
  yacute: 253,
  yuml: 255,
  copy: 169,
  reg: 174,
  nbsp: 160,
  iexcl: 161,
  cent: 162,
  pound: 163,
  curren: 164,
  yen: 165,
  brvbar: 166,
  sect: 167,
  uml: 168,
  ordf: 170,
  laquo: 171,
  not: 172,
  shy: 173,
  macr: 175,
  deg: 176,
  plusmn: 177,
  sup1: 185,
  sup2: 178,
  sup3: 179,
  acute: 180,
  micro: 181,
  para: 182,
  middot: 183,
  cedil: 184,
  ordm: 186,
  raquo: 187,
  frac14: 188,
  frac12: 189,
  frac34: 190,
  iquest: 191,
  times: 215,
  divide: 247,
  OElig: 338,
  oelig: 339,
  Scaron: 352,
  scaron: 353,
  Yuml: 376,
  fnof: 402,
  circ: 710,
  tilde: 732,
  Alpha: 913,
  Beta: 914,
  Gamma: 915,
  Delta: 916,
  Epsilon: 917,
  Zeta: 918,
  Eta: 919,
  Theta: 920,
  Iota: 921,
  Kappa: 922,
  Lambda: 923,
  Mu: 924,
  Nu: 925,
  Xi: 926,
  Omicron: 927,
  Pi: 928,
  Rho: 929,
  Sigma: 931,
  Tau: 932,
  Upsilon: 933,
  Phi: 934,
  Chi: 935,
  Psi: 936,
  Omega: 937,
  alpha: 945,
  beta: 946,
  gamma: 947,
  delta: 948,
  epsilon: 949,
  zeta: 950,
  eta: 951,
  theta: 952,
  iota: 953,
  kappa: 954,
  lambda: 955,
  mu: 956,
  nu: 957,
  xi: 958,
  omicron: 959,
  pi: 960,
  rho: 961,
  sigmaf: 962,
  sigma: 963,
  tau: 964,
  upsilon: 965,
  phi: 966,
  chi: 967,
  psi: 968,
  omega: 969,
  thetasym: 977,
  upsih: 978,
  piv: 982,
  ensp: 8194,
  emsp: 8195,
  thinsp: 8201,
  zwnj: 8204,
  zwj: 8205,
  lrm: 8206,
  rlm: 8207,
  ndash: 8211,
  mdash: 8212,
  lsquo: 8216,
  rsquo: 8217,
  sbquo: 8218,
  ldquo: 8220,
  rdquo: 8221,
  bdquo: 8222,
  dagger: 8224,
  Dagger: 8225,
  bull: 8226,
  hellip: 8230,
  permil: 8240,
  prime: 8242,
  Prime: 8243,
  lsaquo: 8249,
  rsaquo: 8250,
  oline: 8254,
  frasl: 8260,
  euro: 8364,
  image: 8465,
  weierp: 8472,
  real: 8476,
  trade: 8482,
  alefsym: 8501,
  larr: 8592,
  uarr: 8593,
  rarr: 8594,
  darr: 8595,
  harr: 8596,
  crarr: 8629,
  lArr: 8656,
  uArr: 8657,
  rArr: 8658,
  dArr: 8659,
  hArr: 8660,
  forall: 8704,
  part: 8706,
  exist: 8707,
  empty: 8709,
  nabla: 8711,
  isin: 8712,
  notin: 8713,
  ni: 8715,
  prod: 8719,
  sum: 8721,
  minus: 8722,
  lowast: 8727,
  radic: 8730,
  prop: 8733,
  infin: 8734,
  ang: 8736,
  and: 8743,
  or: 8744,
  cap: 8745,
  cup: 8746,
  int: 8747,
  there4: 8756,
  sim: 8764,
  cong: 8773,
  asymp: 8776,
  ne: 8800,
  equiv: 8801,
  le: 8804,
  ge: 8805,
  sub: 8834,
  sup: 8835,
  nsub: 8836,
  sube: 8838,
  supe: 8839,
  oplus: 8853,
  otimes: 8855,
  perp: 8869,
  sdot: 8901,
  lceil: 8968,
  rceil: 8969,
  lfloor: 8970,
  rfloor: 8971,
  lang: 9001,
  rang: 9002,
  loz: 9674,
  spades: 9824,
  clubs: 9827,
  hearts: 9829,
  diams: 9830
};
Object.keys(ENTITIES).forEach((key) => {
  const e = ENTITIES[key];
  ENTITIES[key] = typeof e === "number" ? String.fromCharCode(e) : e;
});
var SAX = class _SAX {
  constructor() {
    _defineProperty(this, "EVENTS", EVENTS);
    _defineProperty(this, "ENTITIES", {
      ...ENTITIES
    });
    _defineProperty(this, "events", void 0);
    _defineProperty(this, "XML_ENTITIES", {
      amp: "&",
      gt: ">",
      lt: "<",
      quot: '"',
      apos: "'"
    });
    _defineProperty(this, "S", 0);
    _defineProperty(this, "opt", void 0);
    _defineProperty(this, "trackPosition", false);
    _defineProperty(this, "column", 0);
    _defineProperty(this, "line", 0);
    _defineProperty(this, "c", "");
    _defineProperty(this, "error", void 0);
    _defineProperty(this, "q", "");
    _defineProperty(this, "bufferCheckPosition", void 0);
    _defineProperty(this, "closed", false);
    _defineProperty(this, "tags", []);
    _defineProperty(this, "looseCase", "");
    _defineProperty(this, "closedRoot", false);
    _defineProperty(this, "sawRoot", false);
    _defineProperty(this, "strict", false);
    _defineProperty(this, "tag", void 0);
    _defineProperty(this, "strictEntities", void 0);
    _defineProperty(this, "state", void 0);
    _defineProperty(this, "noscript", false);
    _defineProperty(this, "attribList", []);
    _defineProperty(this, "ns", void 0);
    _defineProperty(this, "position", 0);
    _defineProperty(this, "STATE", {
      BEGIN: this.S++,
      BEGIN_WHITESPACE: this.S++,
      TEXT: this.S++,
      TEXT_ENTITY: this.S++,
      OPEN_WAKA: this.S++,
      SGML_DECL: this.S++,
      SGML_DECL_QUOTED: this.S++,
      DOCTYPE: this.S++,
      DOCTYPE_QUOTED: this.S++,
      DOCTYPE_DTD: this.S++,
      DOCTYPE_DTD_QUOTED: this.S++,
      COMMENT_STARTING: this.S++,
      COMMENT: this.S++,
      COMMENT_ENDING: this.S++,
      COMMENT_ENDED: this.S++,
      CDATA: this.S++,
      CDATA_ENDING: this.S++,
      CDATA_ENDING_2: this.S++,
      PROC_INST: this.S++,
      PROC_INST_BODY: this.S++,
      PROC_INST_ENDING: this.S++,
      OPEN_TAG: this.S++,
      OPEN_TAG_SLASH: this.S++,
      ATTRIB: this.S++,
      ATTRIB_NAME: this.S++,
      ATTRIB_NAME_SAW_WHITE: this.S++,
      ATTRIB_VALUE: this.S++,
      ATTRIB_VALUE_QUOTED: this.S++,
      ATTRIB_VALUE_CLOSED: this.S++,
      ATTRIB_VALUE_UNQUOTED: this.S++,
      ATTRIB_VALUE_ENTITY_Q: this.S++,
      ATTRIB_VALUE_ENTITY_U: this.S++,
      CLOSE_TAG: this.S++,
      CLOSE_TAG_SAW_WHITE: this.S++,
      SCRIPT: this.S++,
      SCRIPT_ENDING: this.S++
    });
    _defineProperty(this, "BUFFERS", BUFFERS);
    _defineProperty(this, "CDATA", "[CDATA[");
    _defineProperty(this, "DOCTYPE", "DOCTYPE");
    _defineProperty(this, "XML_NAMESPACE", "http://www.w3.org/XML/1998/namespace");
    _defineProperty(this, "XMLNS_NAMESPACE", "http://www.w3.org/2000/xmlns/");
    _defineProperty(this, "rootNS", {
      xml: this.XML_NAMESPACE,
      xmlns: this.XMLNS_NAMESPACE
    });
    _defineProperty(this, "comment", void 0);
    _defineProperty(this, "sgmlDecl", void 0);
    _defineProperty(this, "textNode", "");
    _defineProperty(this, "tagName", void 0);
    _defineProperty(this, "doctype", void 0);
    _defineProperty(this, "procInstName", void 0);
    _defineProperty(this, "procInstBody", void 0);
    _defineProperty(this, "entity", "");
    _defineProperty(this, "attribName", void 0);
    _defineProperty(this, "attribValue", void 0);
    _defineProperty(this, "cdata", "");
    _defineProperty(this, "script", "");
    _defineProperty(this, "startTagPosition", 0);
    this.S = 0;
    for (const s in this.STATE) {
      if (this.STATE.hasOwnProperty(s)) {
        this.STATE[this.STATE[s]] = s;
      }
    }
    this.S = this.STATE;
  }
  static charAt(chunk, i2) {
    let result = "";
    if (i2 < chunk.length) {
      result = chunk.charAt(i2);
    }
    return result;
  }
  static isWhitespace(c) {
    return c === " " || c === "\n" || c === "\r" || c === "	";
  }
  static isQuote(c) {
    return c === '"' || c === "'";
  }
  static isAttribEnd(c) {
    return c === ">" || _SAX.isWhitespace(c);
  }
  static isMatch(regex, c) {
    return regex.test(c);
  }
  static notMatch(regex, c) {
    return !_SAX.isMatch(regex, c);
  }
  static qname(name, attribute) {
    const i2 = name.indexOf(":");
    const qualName = i2 < 0 ? ["", name] : name.split(":");
    let prefix = qualName[0];
    let local = qualName[1];
    if (attribute && name === "xmlns") {
      prefix = "xmlns";
      local = "";
    }
    return {
      prefix,
      local
    };
  }
  write(chunk) {
    if (this.error) {
      throw this.error;
    }
    if (this.closed) {
      return this.errorFunction("Cannot write after close. Assign an onready handler.");
    }
    if (chunk === null) {
      return this.end();
    }
    if (typeof chunk === "object") {
      chunk = chunk.toString();
    }
    let i2 = 0;
    let c;
    while (true) {
      c = _SAX.charAt(chunk, i2++);
      this.c = c;
      if (!c) {
        break;
      }
      if (this.trackPosition) {
        this.position++;
        if (c === "\n") {
          this.line++;
          this.column = 0;
        } else {
          this.column++;
        }
      }
      switch (this.state) {
        case this.S.BEGIN:
          this.state = this.S.BEGIN_WHITESPACE;
          if (c === "\uFEFF") {
            continue;
          }
          this.beginWhiteSpace(c);
          continue;
        case this.S.BEGIN_WHITESPACE:
          this.beginWhiteSpace(c);
          continue;
        case this.S.TEXT:
          if (this.sawRoot && !this.closedRoot) {
            const starti = i2 - 1;
            while (c && c !== "<" && c !== "&") {
              c = _SAX.charAt(chunk, i2++);
              if (c && this.trackPosition) {
                this.position++;
                if (c === "\n") {
                  this.line++;
                  this.column = 0;
                } else {
                  this.column++;
                }
              }
            }
            this.textNode += chunk.substring(starti, i2 - 1);
          }
          if (c === "<" && !(this.sawRoot && this.closedRoot && !this.strict)) {
            this.state = this.S.OPEN_WAKA;
            this.startTagPosition = this.position;
          } else {
            if (!_SAX.isWhitespace(c) && (!this.sawRoot || this.closedRoot)) {
              this.strictFail("Text data outside of root node.");
            }
            if (c === "&") {
              this.state = this.S.TEXT_ENTITY;
            } else {
              this.textNode += c;
            }
          }
          continue;
        case this.S.SCRIPT:
          if (c === "<") {
            this.state = this.S.SCRIPT_ENDING;
          } else {
            this.script += c;
          }
          continue;
        case this.S.SCRIPT_ENDING:
          if (c === "/") {
            this.state = this.S.CLOSE_TAG;
          } else {
            this.script += "<".concat(c);
            this.state = this.S.SCRIPT;
          }
          continue;
        case this.S.OPEN_WAKA:
          if (c === "!") {
            this.state = this.S.SGML_DECL;
            this.sgmlDecl = "";
          } else if (_SAX.isWhitespace(c)) {
          } else if (_SAX.isMatch(nameStart, c)) {
            this.state = this.S.OPEN_TAG;
            this.tagName = c;
          } else if (c === "/") {
            this.state = this.S.CLOSE_TAG;
            this.tagName = "";
          } else if (c === "?") {
            this.state = this.S.PROC_INST;
            this.procInstName = this.procInstBody = "";
          } else {
            this.strictFail("Unencoded <");
            if (this.startTagPosition + 1 < this.position) {
              const pad = this.position - this.startTagPosition;
              c = new Array(pad).join(" ") + c;
            }
            this.textNode += "<".concat(c);
            this.state = this.S.TEXT;
          }
          continue;
        case this.S.SGML_DECL:
          if ((this.sgmlDecl + c).toUpperCase() === this.CDATA) {
            this.emitNode("onopencdata");
            this.state = this.S.CDATA;
            this.sgmlDecl = "";
            this.cdata = "";
          } else if (this.sgmlDecl + c === "--") {
            this.state = this.S.COMMENT;
            this.comment = "";
            this.sgmlDecl = "";
          } else if ((this.sgmlDecl + c).toUpperCase() === this.DOCTYPE) {
            this.state = this.S.DOCTYPE;
            if (this.doctype || this.sawRoot) {
              this.strictFail("Inappropriately located doctype declaration");
            }
            this.doctype = "";
            this.sgmlDecl = "";
          } else if (c === ">") {
            this.emitNode("onsgmldeclaration", this.sgmlDecl);
            this.sgmlDecl = "";
            this.state = this.S.TEXT;
          } else if (_SAX.isQuote(c)) {
            this.state = this.S.SGML_DECL_QUOTED;
            this.sgmlDecl += c;
          } else {
            this.sgmlDecl += c;
          }
          continue;
        case this.S.SGML_DECL_QUOTED:
          if (c === this.q) {
            this.state = this.S.SGML_DECL;
            this.q = "";
          }
          this.sgmlDecl += c;
          continue;
        case this.S.DOCTYPE:
          if (c === ">") {
            this.state = this.S.TEXT;
            this.emitNode("ondoctype", this.doctype);
            this.doctype = true;
          } else {
            this.doctype += c;
            if (c === "[") {
              this.state = this.S.DOCTYPE_DTD;
            } else if (_SAX.isQuote(c)) {
              this.state = this.S.DOCTYPE_QUOTED;
              this.q = c;
            }
          }
          continue;
        case this.S.DOCTYPE_QUOTED:
          this.doctype += c;
          if (c === this.q) {
            this.q = "";
            this.state = this.S.DOCTYPE;
          }
          continue;
        case this.S.DOCTYPE_DTD:
          this.doctype += c;
          if (c === "]") {
            this.state = this.S.DOCTYPE;
          } else if (_SAX.isQuote(c)) {
            this.state = this.S.DOCTYPE_DTD_QUOTED;
            this.q = c;
          }
          continue;
        case this.S.DOCTYPE_DTD_QUOTED:
          this.doctype += c;
          if (c === this.q) {
            this.state = this.S.DOCTYPE_DTD;
            this.q = "";
          }
          continue;
        case this.S.COMMENT:
          if (c === "-") {
            this.state = this.S.COMMENT_ENDING;
          } else {
            this.comment += c;
          }
          continue;
        case this.S.COMMENT_ENDING:
          if (c === "-") {
            this.state = this.S.COMMENT_ENDED;
            this.comment = this.textApplyOptions(this.comment);
            if (this.comment) {
              this.emitNode("oncomment", this.comment);
            }
            this.comment = "";
          } else {
            this.comment += "-".concat(c);
            this.state = this.S.COMMENT;
          }
          continue;
        case this.S.COMMENT_ENDED:
          if (c !== ">") {
            this.strictFail("Malformed comment");
            this.comment += "--".concat(c);
            this.state = this.S.COMMENT;
          } else {
            this.state = this.S.TEXT;
          }
          continue;
        case this.S.CDATA:
          if (c === "]") {
            this.state = this.S.CDATA_ENDING;
          } else {
            this.cdata += c;
          }
          continue;
        case this.S.CDATA_ENDING:
          if (c === "]") {
            this.state = this.S.CDATA_ENDING_2;
          } else {
            this.cdata += "]".concat(c);
            this.state = this.S.CDATA;
          }
          continue;
        case this.S.CDATA_ENDING_2:
          if (c === ">") {
            if (this.cdata) {
              this.emitNode("oncdata", this.cdata);
            }
            this.emitNode("onclosecdata");
            this.cdata = "";
            this.state = this.S.TEXT;
          } else if (c === "]") {
            this.cdata += "]";
          } else {
            this.cdata += "]]".concat(c);
            this.state = this.S.CDATA;
          }
          continue;
        case this.S.PROC_INST:
          if (c === "?") {
            this.state = this.S.PROC_INST_ENDING;
          } else if (_SAX.isWhitespace(c)) {
            this.state = this.S.PROC_INST_BODY;
          } else {
            this.procInstName += c;
          }
          continue;
        case this.S.PROC_INST_BODY:
          if (!this.procInstBody && _SAX.isWhitespace(c)) {
            continue;
          } else if (c === "?") {
            this.state = this.S.PROC_INST_ENDING;
          } else {
            this.procInstBody += c;
          }
          continue;
        case this.S.PROC_INST_ENDING:
          if (c === ">") {
            this.emitNode("onprocessinginstruction", {
              name: this.procInstName,
              body: this.procInstBody
            });
            this.procInstName = this.procInstBody = "";
            this.state = this.S.TEXT;
          } else {
            this.procInstBody += "?".concat(c);
            this.state = this.S.PROC_INST_BODY;
          }
          continue;
        case this.S.OPEN_TAG:
          if (_SAX.isMatch(nameBody, c)) {
            this.tagName += c;
          } else {
            this.newTag();
            if (c === ">") {
              this.openTag();
            } else if (c === "/") {
              this.state = this.S.OPEN_TAG_SLASH;
            } else {
              if (!_SAX.isWhitespace(c)) {
                this.strictFail("Invalid character in tag name");
              }
              this.state = this.S.ATTRIB;
            }
          }
          continue;
        case this.S.OPEN_TAG_SLASH:
          if (c === ">") {
            this.openTag(true);
            this.closeTag();
          } else {
            this.strictFail("Forward-slash in opening tag not followed by >");
            this.state = this.S.ATTRIB;
          }
          continue;
        case this.S.ATTRIB:
          if (_SAX.isWhitespace(c)) {
            continue;
          } else if (c === ">") {
            this.openTag();
          } else if (c === "/") {
            this.state = this.S.OPEN_TAG_SLASH;
          } else if (_SAX.isMatch(nameStart, c)) {
            this.attribName = c;
            this.attribValue = "";
            this.state = this.S.ATTRIB_NAME;
          } else {
            this.strictFail("Invalid attribute name");
          }
          continue;
        case this.S.ATTRIB_NAME:
          if (c === "=") {
            this.state = this.S.ATTRIB_VALUE;
          } else if (c === ">") {
            this.strictFail("Attribute without value");
            this.attribValue = this.attribName;
            this.attrib();
            this.openTag();
          } else if (_SAX.isWhitespace(c)) {
            this.state = this.S.ATTRIB_NAME_SAW_WHITE;
          } else if (_SAX.isMatch(nameBody, c)) {
            this.attribName += c;
          } else {
            this.strictFail("Invalid attribute name");
          }
          continue;
        case this.S.ATTRIB_NAME_SAW_WHITE:
          if (c === "=") {
            this.state = this.S.ATTRIB_VALUE;
          } else if (_SAX.isWhitespace(c)) {
            continue;
          } else {
            this.strictFail("Attribute without value");
            this.tag.attributes[this.attribName] = "";
            this.attribValue = "";
            this.emitNode("onattribute", {
              name: this.attribName,
              value: ""
            });
            this.attribName = "";
            if (c === ">") {
              this.openTag();
            } else if (_SAX.isMatch(nameStart, c)) {
              this.attribName = c;
              this.state = this.S.ATTRIB_NAME;
            } else {
              this.strictFail("Invalid attribute name");
              this.state = this.S.ATTRIB;
            }
          }
          continue;
        case this.S.ATTRIB_VALUE:
          if (_SAX.isWhitespace(c)) {
            continue;
          } else if (_SAX.isQuote(c)) {
            this.q = c;
            this.state = this.S.ATTRIB_VALUE_QUOTED;
          } else {
            this.strictFail("Unquoted attribute value");
            this.state = this.S.ATTRIB_VALUE_UNQUOTED;
            this.attribValue = c;
          }
          continue;
        case this.S.ATTRIB_VALUE_QUOTED:
          if (c !== this.q) {
            if (c === "&") {
              this.state = this.S.ATTRIB_VALUE_ENTITY_Q;
            } else {
              this.attribValue += c;
            }
            continue;
          }
          this.attrib();
          this.q = "";
          this.state = this.S.ATTRIB_VALUE_CLOSED;
          continue;
        case this.S.ATTRIB_VALUE_CLOSED:
          if (_SAX.isWhitespace(c)) {
            this.state = this.S.ATTRIB;
          } else if (c === ">") {
            this.openTag();
          } else if (c === "/") {
            this.state = this.S.OPEN_TAG_SLASH;
          } else if (_SAX.isMatch(nameStart, c)) {
            this.strictFail("No whitespace between attributes");
            this.attribName = c;
            this.attribValue = "";
            this.state = this.S.ATTRIB_NAME;
          } else {
            this.strictFail("Invalid attribute name");
          }
          continue;
        case this.S.ATTRIB_VALUE_UNQUOTED:
          if (!_SAX.isAttribEnd(c)) {
            if (c === "&") {
              this.state = this.S.ATTRIB_VALUE_ENTITY_U;
            } else {
              this.attribValue += c;
            }
            continue;
          }
          this.attrib();
          if (c === ">") {
            this.openTag();
          } else {
            this.state = this.S.ATTRIB;
          }
          continue;
        case this.S.CLOSE_TAG:
          if (!this.tagName) {
            if (_SAX.isWhitespace(c)) {
              continue;
            } else if (_SAX.notMatch(nameStart, c)) {
              if (this.script) {
                this.script += "</".concat(c);
                this.state = this.S.SCRIPT;
              } else {
                this.strictFail("Invalid tagname in closing tag.");
              }
            } else {
              this.tagName = c;
            }
          } else if (c === ">") {
            this.closeTag();
          } else if (_SAX.isMatch(nameBody, c)) {
            this.tagName += c;
          } else if (this.script) {
            this.script += "</".concat(this.tagName);
            this.tagName = "";
            this.state = this.S.SCRIPT;
          } else {
            if (!_SAX.isWhitespace(c)) {
              this.strictFail("Invalid tagname in closing tag");
            }
            this.state = this.S.CLOSE_TAG_SAW_WHITE;
          }
          continue;
        case this.S.CLOSE_TAG_SAW_WHITE:
          if (_SAX.isWhitespace(c)) {
            continue;
          }
          if (c === ">") {
            this.closeTag();
          } else {
            this.strictFail("Invalid characters in closing tag");
          }
          continue;
        case this.S.TEXT_ENTITY:
        case this.S.ATTRIB_VALUE_ENTITY_Q:
        case this.S.ATTRIB_VALUE_ENTITY_U:
          let returnState;
          let buffer;
          switch (this.state) {
            case this.S.TEXT_ENTITY:
              returnState = this.S.TEXT;
              buffer = "textNode";
              break;
            case this.S.ATTRIB_VALUE_ENTITY_Q:
              returnState = this.S.ATTRIB_VALUE_QUOTED;
              buffer = "attribValue";
              break;
            case this.S.ATTRIB_VALUE_ENTITY_U:
              returnState = this.S.ATTRIB_VALUE_UNQUOTED;
              buffer = "attribValue";
              break;
            default:
              throw new Error("Unknown state: ".concat(this.state));
          }
          if (c === ";") {
            this[buffer] += this.parseEntity();
            this.entity = "";
            this.state = returnState;
          } else if (_SAX.isMatch(this.entity.length ? entityBody : entityStart, c)) {
            this.entity += c;
          } else {
            this.strictFail("Invalid character in entity name");
            this[buffer] += "&".concat(this.entity).concat(c);
            this.entity = "";
            this.state = returnState;
          }
          continue;
        default:
          throw new Error("Unknown state: ".concat(this.state));
      }
    }
    if (this.position >= this.bufferCheckPosition) {
      this.checkBufferLength();
    }
    return this;
  }
  emit(event, data) {
    if (this.events.hasOwnProperty(event)) {
      const eventName = event.replace(/^on/, "");
      this.events[event](data, eventName, this);
    }
  }
  clearBuffers() {
    for (let i2 = 0, l = this.BUFFERS.length; i2 < l; i2++) {
      this[this[i2]] = "";
    }
  }
  flushBuffers() {
    this.closeText();
    if (this.cdata !== "") {
      this.emitNode("oncdata", this.cdata);
      this.cdata = "";
    }
    if (this.script !== "") {
      this.emitNode("onscript", this.script);
      this.script = "";
    }
  }
  end() {
    if (this.sawRoot && !this.closedRoot)
      this.strictFail("Unclosed root tag");
    if (this.state !== this.S.BEGIN && this.state !== this.S.BEGIN_WHITESPACE && this.state !== this.S.TEXT) {
      this.errorFunction("Unexpected end");
    }
    this.closeText();
    this.c = "";
    this.closed = true;
    this.emit("onend");
    return new SAXParser(this.opt);
  }
  errorFunction(er) {
    this.closeText();
    if (this.trackPosition) {
      er += "\nLine: ".concat(this.line, "\nColumn: ").concat(this.column, "\nChar: ").concat(this.c);
    }
    const error = new Error(er);
    this.error = error;
    this.emit("onerror", error);
    return this;
  }
  attrib() {
    if (!this.strict) {
      this.attribName = this.attribName[this.looseCase]();
    }
    if (this.attribList.indexOf(this.attribName) !== -1 || this.tag.attributes.hasOwnProperty(this.attribName)) {
      this.attribName = this.attribValue = "";
      return;
    }
    if (this.opt.xmlns) {
      const qn = _SAX.qname(this.attribName, true);
      const prefix = qn.prefix;
      const local = qn.local;
      if (prefix === "xmlns") {
        if (local === "xml" && this.attribValue !== this.XML_NAMESPACE) {
          this.strictFail("xml: prefix must be bound to ".concat(this.XML_NAMESPACE, "\n") + "Actual: ".concat(this.attribValue));
        } else if (local === "xmlns" && this.attribValue !== this.XMLNS_NAMESPACE) {
          this.strictFail("xmlns: prefix must be bound to ".concat(this.XMLNS_NAMESPACE, "\n") + "Actual: ".concat(this.attribValue));
        } else {
          const tag = this.tag;
          const parent = this.tags[this.tags.length - 1] || this;
          if (tag.ns === parent.ns) {
            tag.ns = Object.create(parent.ns);
          }
          tag.ns[local] = this.attribValue;
        }
      }
      this.attribList.push([this.attribName, this.attribValue]);
    } else {
      this.tag.attributes[this.attribName] = this.attribValue;
      this.emitNode("onattribute", {
        name: this.attribName,
        value: this.attribValue
      });
    }
    this.attribName = this.attribValue = "";
  }
  newTag() {
    if (!this.strict)
      this.tagName = this.tagName[this.looseCase]();
    const parent = this.tags[this.tags.length - 1] || this;
    const tag = this.tag = {
      name: this.tagName,
      attributes: {}
    };
    if (this.opt.xmlns) {
      tag.ns = parent.ns;
    }
    this.attribList.length = 0;
    this.emitNode("onopentagstart", tag);
  }
  parseEntity() {
    let entity = this.entity;
    const entityLC = entity.toLowerCase();
    let num = NaN;
    let numStr = "";
    if (this.ENTITIES[entity]) {
      return this.ENTITIES[entity];
    }
    if (this.ENTITIES[entityLC]) {
      return this.ENTITIES[entityLC];
    }
    entity = entityLC;
    if (entity.charAt(0) === "#") {
      if (entity.charAt(1) === "x") {
        entity = entity.slice(2);
        num = parseInt(entity, 16);
        numStr = num.toString(16);
      } else {
        entity = entity.slice(1);
        num = parseInt(entity, 10);
        numStr = num.toString(10);
      }
    }
    entity = entity.replace(/^0+/, "");
    if (isNaN(num) || numStr.toLowerCase() !== entity) {
      this.strictFail("Invalid character entity");
      return "&".concat(this.entity, ";");
    }
    return String.fromCodePoint(num);
  }
  beginWhiteSpace(c) {
    if (c === "<") {
      this.state = this.S.OPEN_WAKA;
      this.startTagPosition = this.position;
    } else if (!_SAX.isWhitespace(c)) {
      this.strictFail("Non-whitespace before first tag.");
      this.textNode = c;
      this.state = this.S.TEXT;
    } else {
    }
  }
  strictFail(message) {
    if (typeof this !== "object" || !(this instanceof SAXParser)) {
      throw new Error("bad call to strictFail");
    }
    if (this.strict) {
      this.errorFunction(message);
    }
  }
  textApplyOptions(text) {
    if (this.opt.trim)
      text = text.trim();
    if (this.opt.normalize)
      text = text.replace(/\s+/g, " ");
    return text;
  }
  emitNode(nodeType, data) {
    if (this.textNode)
      this.closeText();
    this.emit(nodeType, data);
  }
  closeText() {
    this.textNode = this.textApplyOptions(this.textNode);
    if (this.textNode !== void 0 && this.textNode !== "" && this.textNode !== "undefined") {
      this.emit("ontext", this.textNode);
    }
    this.textNode = "";
  }
  checkBufferLength() {
    const maxAllowed = Math.max(this.opt.MAX_BUFFER_LENGTH, 10);
    let maxActual = 0;
    for (let i2 = 0, l = this.BUFFERS.length; i2 < l; i2++) {
      var _this$this$BUFFERS$i;
      const len = ((_this$this$BUFFERS$i = this[this.BUFFERS[i2]]) === null || _this$this$BUFFERS$i === void 0 ? void 0 : _this$this$BUFFERS$i.length) || 0;
      if (len > maxAllowed) {
        switch (this.BUFFERS[i2]) {
          case "textNode":
            this.closeText();
            break;
          case "cdata":
            this.emitNode("oncdata", this.cdata);
            this.cdata = "";
            break;
          case "script":
            this.emitNode("onscript", this.script);
            this.script = "";
            break;
          default:
            this.errorFunction("Max buffer length exceeded: ".concat(this.BUFFERS[i2]));
        }
      }
      maxActual = Math.max(maxActual, len);
    }
    const m = this.opt.MAX_BUFFER_LENGTH - maxActual;
    this.bufferCheckPosition = m + this.position;
  }
  openTag(selfClosing) {
    if (this.opt.xmlns) {
      const tag = this.tag;
      const qn = _SAX.qname(this.tagName);
      tag.prefix = qn.prefix;
      tag.local = qn.local;
      tag.uri = tag.ns[qn.prefix] || "";
      if (tag.prefix && !tag.uri) {
        this.strictFail("Unbound namespace prefix: ".concat(JSON.stringify(this.tagName)));
        tag.uri = qn.prefix;
      }
      const parent = this.tags[this.tags.length - 1] || this;
      if (tag.ns && parent.ns !== tag.ns) {
        const that = this;
        Object.keys(tag.ns).forEach((p) => {
          that.emitNode("onopennamespace", {
            prefix: p,
            uri: tag.ns[p]
          });
        });
      }
      for (let i2 = 0, l = this.attribList.length; i2 < l; i2++) {
        const nv = this.attribList[i2];
        const name = nv[0];
        const value = nv[1];
        const qualName = _SAX.qname(name, true);
        const prefix = qualName.prefix;
        const local = qualName.local;
        const uri = prefix === "" ? "" : tag.ns[prefix] || "";
        const a = {
          name,
          value,
          prefix,
          local,
          uri
        };
        if (prefix && prefix !== "xmlns" && !uri) {
          this.strictFail("Unbound namespace prefix: ".concat(JSON.stringify(prefix)));
          a.uri = prefix;
        }
        this.tag.attributes[name] = a;
        this.emitNode("onattribute", a);
      }
      this.attribList.length = 0;
    }
    this.tag.isSelfClosing = Boolean(selfClosing);
    this.sawRoot = true;
    this.tags.push(this.tag);
    this.emitNode("onopentag", this.tag);
    if (!selfClosing) {
      if (!this.noscript && this.tagName.toLowerCase() === "script") {
        this.state = this.S.SCRIPT;
      } else {
        this.state = this.S.TEXT;
      }
      this.tag = null;
      this.tagName = "";
    }
    this.attribName = this.attribValue = "";
    this.attribList.length = 0;
  }
  closeTag() {
    if (!this.tagName) {
      this.strictFail("Weird empty close tag.");
      this.textNode += "</>";
      this.state = this.S.TEXT;
      return;
    }
    if (this.script) {
      if (this.tagName !== "script") {
        this.script += "</".concat(this.tagName, ">");
        this.tagName = "";
        this.state = this.S.SCRIPT;
        return;
      }
      this.emitNode("onscript", this.script);
      this.script = "";
    }
    let t = this.tags.length;
    let tagName = this.tagName;
    if (!this.strict) {
      tagName = tagName[this.looseCase]();
    }
    while (t--) {
      const close = this.tags[t];
      if (close.name !== tagName) {
        this.strictFail("Unexpected close tag");
      } else {
        break;
      }
    }
    if (t < 0) {
      this.strictFail("Unmatched closing tag: ".concat(this.tagName));
      this.textNode += "</".concat(this.tagName, ">");
      this.state = this.S.TEXT;
      return;
    }
    this.tagName = tagName;
    let s = this.tags.length;
    while (s-- > t) {
      const tag = this.tag = this.tags.pop();
      this.tagName = this.tag.name;
      this.emitNode("onclosetag", this.tagName);
      const x2 = {};
      for (const i2 in tag.ns) {
        if (tag.ns.hasOwnProperty(i2)) {
          x2[i2] = tag.ns[i2];
        }
      }
      const parent = this.tags[this.tags.length - 1] || this;
      if (this.opt.xmlns && tag.ns !== parent.ns) {
        const that = this;
        Object.keys(tag.ns).forEach((p) => {
          const n = tag.ns[p];
          that.emitNode("onclosenamespace", {
            prefix: p,
            uri: n
          });
        });
      }
    }
    if (t === 0)
      this.closedRoot = true;
    this.tagName = this.attribValue = this.attribName = "";
    this.attribList.length = 0;
    this.state = this.S.TEXT;
  }
};
var SAXParser = class extends SAX {
  constructor(opt) {
    super();
    _defineProperty(this, "opt", DEFAULT_SAX_PARSER_OPTIONS);
    _defineProperty(this, "events", DEFAULT_SAX_EVENTS);
    this.clearBuffers();
    this.opt = opt = {
      ...this.opt,
      ...opt
    };
    this.events = {
      ...this.events,
      ...opt
    };
    this.q = this.c = "";
    this.opt.lowercase = this.opt.lowercase || this.opt.lowercasetags;
    this.bufferCheckPosition = this.opt.MAX_BUFFER_LENGTH;
    this.looseCase = this.opt.lowercase ? "toLowerCase" : "toUpperCase";
    this.tags = [];
    this.closed = this.closedRoot = this.sawRoot = false;
    this.tag = this.error = null;
    this.strict = Boolean(this.opt.strict);
    this.noscript = Boolean(this.opt.strict || this.opt.noscript);
    this.state = this.S.BEGIN;
    this.strictEntities = this.opt.strictEntities;
    this.ENTITIES = this.strictEntities ? Object.create(this.XML_ENTITIES) : Object.create(this.ENTITIES);
    this.attribList = [];
    if (this.opt.xmlns) {
      this.ns = Object.create(this.rootNS);
    }
    this.trackPosition = this.opt.position !== false;
    if (this.trackPosition) {
      this.position = this.line = this.column = 0;
    }
    this.emit("onready");
  }
  resume() {
    this.error = null;
    return this;
  }
  close() {
    return this.write(null);
  }
  flush() {
    this.flushBuffers();
  }
};
_defineProperty(SAXParser, "ENTITIES", ENTITIES);

// node_modules/@loaders.gl/xml/dist/esm/lib/parsers/parse-xml.js
var import_fast_xml_parser = __toESM(require_fxp());
function fastParseXML(text, options) {
  const parser = new import_fast_xml_parser.XMLParser({
    ignoreAttributes: false,
    attributeNamePrefix: "",
    ...options
  });
  const parsedXML = parser.parse(text);
  return parsedXML;
}

// node_modules/@loaders.gl/xml/dist/esm/lib/xml-utils/uncapitalize.js
function uncapitalize(str) {
  return typeof str === "string" ? str.charAt(0).toLowerCase() + str.slice(1) : str;
}
function uncapitalizeKeys(object) {
  if (Array.isArray(object)) {
    return object.map((element) => uncapitalizeKeys(element));
  }
  if (object && typeof object === "object") {
    const newObject = {};
    for (const [key, value] of Object.entries(object)) {
      newObject[uncapitalize(key)] = uncapitalizeKeys(value);
    }
    return newObject;
  }
  return object;
}

// node_modules/@loaders.gl/xml/dist/esm/xml-loader.js
var VERSION = true ? "3.4.9" : "latest";
var XMLLoader = {
  name: "XML",
  id: "xml",
  module: "xml",
  version: VERSION,
  worker: false,
  extensions: ["xml"],
  mimeTypes: ["application/xml", "text/xml"],
  testText: testXMLFile,
  options: {
    xml: {
      parser: "fast-xml-parser",
      uncapitalizeKeys: false,
      removeNSPrefix: false,
      textNodeName: "value",
      arrayPaths: []
    }
  },
  parse: async (arrayBuffer, options) => parseTextSync(new TextDecoder().decode(arrayBuffer), options),
  parseTextSync: (text, options) => parseTextSync(text, options)
};
function testXMLFile(text) {
  return text.startsWith("<?xml");
}
function parseTextSync(text, options) {
  var _options$xml;
  const xmlOptions = {
    ...XMLLoader.options.xml,
    ...options === null || options === void 0 ? void 0 : options.xml
  };
  switch (xmlOptions.parser) {
    case "fast-xml-parser":
      const fastXMLOptions = {
        allowBooleanAttributes: true,
        ignoreDeclaration: true,
        removeNSPrefix: xmlOptions.removeNSPrefix,
        textNodeName: xmlOptions.textNodeName,
        isArray: (name, jpath, isLeafNode, isAttribute) => {
          var _xmlOptions$arrayPath;
          const array = Boolean(xmlOptions === null || xmlOptions === void 0 ? void 0 : (_xmlOptions$arrayPath = xmlOptions.arrayPaths) === null || _xmlOptions$arrayPath === void 0 ? void 0 : _xmlOptions$arrayPath.some((path) => jpath === path));
          return array;
        },
        ...options === null || options === void 0 ? void 0 : options._fastXML
      };
      const xml = fastParseXML(text, fastXMLOptions);
      return xmlOptions.uncapitalizeKeys ? uncapitalizeKeys(xml) : xml;
    default:
      throw new Error(options === null || options === void 0 ? void 0 : (_options$xml = options.xml) === null || _options$xml === void 0 ? void 0 : _options$xml.parser);
  }
}

// node_modules/@loaders.gl/xml/dist/esm/html-loader.js
var HTMLLoader = {
  ...XMLLoader,
  name: "HTML",
  id: "html",
  extensions: ["html", "htm"],
  mimeTypes: ["text/html"],
  testText: testHTMLFile,
  parse: async (arrayBuffer, options) => parseTextSync2(new TextDecoder().decode(arrayBuffer), options),
  parseTextSync: (text, options) => parseTextSync2(text, options)
};
function testHTMLFile(text) {
  return text.startsWith("<html");
}
function parseTextSync2(text, options) {
  options = mergeLoaderOptions(options, {
    xml: {
      parser: "fast-xml-parser"
    },
    _fastXML: {
      htmlEntities: true
    }
  });
  return XMLLoader.parseTextSync(text, options);
}

// node_modules/@loaders.gl/xml/dist/esm/lib/xml-utils/xml-utils.js
function convertXMLValueToArray(xmlValue) {
  if (Array.isArray(xmlValue)) {
    return xmlValue;
  }
  if (xmlValue && typeof xmlValue === "object" && xmlValue["0"]) {
  }
  if (xmlValue) {
    return [xmlValue];
  }
  return [];
}
function convertXMLFieldToArrayInPlace(xml, key) {
  xml[key] = convertXMLValueToArray(xml[key]);
}

// node_modules/@loaders.gl/wms/dist/esm/lib/parsers/csw/parse-exception-report.js
function parseExceptionReport(parsedXML) {
  var _exceptionReport$exce, _exceptionReport$exce2, _exceptionReport$exce3;
  const exceptionReport = parsedXML.exceptionReport;
  if (!exceptionReport) {
    return;
  }
  const errorMessage = ((_exceptionReport$exce = exceptionReport.exception) === null || _exceptionReport$exce === void 0 ? void 0 : _exceptionReport$exce.exceptionText) || ((_exceptionReport$exce2 = exceptionReport.exception) === null || _exceptionReport$exce2 === void 0 ? void 0 : _exceptionReport$exce2.exceptionCode) || ((_exceptionReport$exce3 = exceptionReport.exception) === null || _exceptionReport$exce3 === void 0 ? void 0 : _exceptionReport$exce3.locator) || "server error";
  throw new Error("Catalog Server: ".concat(errorMessage));
}

// node_modules/@loaders.gl/wms/dist/esm/lib/parsers/csw/parse-csw-capabilities.js
function parseCSWCapabilities(text, options) {
  const parsedXML = XMLLoader.parseTextSync(text, {
    ...options,
    xml: {
      ...options === null || options === void 0 ? void 0 : options.xml,
      removeNSPrefix: true,
      uncapitalizeKeys: true
    }
  });
  parseExceptionReport(parsedXML);
  const xmlCapabilities = parsedXML.capabilities || parsedXML;
  return xmlCapabilities;
}

// node_modules/@loaders.gl/wms/dist/esm/csw-capabilities-loader.js
var VERSION2 = true ? "3.4.9" : "latest";
var CSWCapabilitiesLoader = {
  id: "csw-capabilities",
  name: "CSW Capabilities",
  module: "wms",
  version: VERSION2,
  worker: false,
  extensions: ["xml"],
  mimeTypes: ["application/vnd.ogc.csw_xml", "application/xml", "text/xml"],
  testText: testXMLFile2,
  options: {
    csw: {}
  },
  parse: async (arrayBuffer, options) => parseCSWCapabilities(new TextDecoder().decode(arrayBuffer), options),
  parseTextSync: (text, options) => parseCSWCapabilities(text, options)
};
function testXMLFile2(text) {
  return text.startsWith("<?xml");
}

// node_modules/@loaders.gl/wms/dist/esm/lib/parsers/csw/parse-csw-domain.js
function parseCSWDomain(text, options) {
  const parsedXML = XMLLoader.parseTextSync(text, {
    ...options,
    xml: {
      ...options === null || options === void 0 ? void 0 : options.xml,
      removeNSPrefix: true,
      uncapitalizeKeys: true,
      arrayPaths: ["GetDomainResponse.DomainValues", "GetDomainResponse.DomainValues.ListOfValues.value"]
    }
  });
  parseExceptionReport(parsedXML);
  const xmlDomain = parsedXML.getDomainResponse;
  for (const domainValue of xmlDomain.domainValues) {
    var _domainValue$listOfVa;
    domainValue.values = (_domainValue$listOfVa = domainValue.listOfValues) === null || _domainValue$listOfVa === void 0 ? void 0 : _domainValue$listOfVa.value;
    delete domainValue.listOfValues;
  }
  return xmlDomain;
}

// node_modules/@loaders.gl/wms/dist/esm/csw-domain-loader.js
var VERSION3 = true ? "3.4.9" : "latest";
var CSWDomainLoader = {
  id: "csw-domain",
  name: "CSW Domain",
  module: "wms",
  version: VERSION3,
  worker: false,
  extensions: ["xml"],
  mimeTypes: ["application/vnd.ogc.csw_xml", "application/xml", "text/xml"],
  testText: testXMLFile3,
  options: {
    csw: {}
  },
  parse: async (arrayBuffer, options) => parseCSWDomain(new TextDecoder().decode(arrayBuffer), options),
  parseTextSync: (text, options) => parseCSWDomain(text, options)
};
function testXMLFile3(text) {
  return text.startsWith("<?xml");
}

// node_modules/@loaders.gl/wms/dist/esm/lib/parsers/csw/parse-csw-records.js
function parseCSWRecords(text, options) {
  const parsedXML = XMLLoader.parseTextSync(text, {
    ...options,
    xml: {
      ...options === null || options === void 0 ? void 0 : options.xml,
      removeNSPrefix: true,
      uncapitalizeKeys: true,
      arrayPaths: []
    },
    _fastXML: {
      ...options === null || options === void 0 ? void 0 : options._fastXML,
      parseAttributeValue: true
    }
  });
  parseExceptionReport(parsedXML);
  const xmlRecords = parsedXML.getRecordsResponse;
  const elementSet = xmlRecords.searchResults.elementSet;
  const recordsFieldName = "".concat(elementSet, "Record");
  xmlRecords.records = xmlRecords.searchResults[recordsFieldName];
  delete xmlRecords.searchResults[recordsFieldName];
  convertXMLFieldToArrayInPlace(xmlRecords, "records");
  for (const record of xmlRecords.records) {
    record.boundingBoxes = record.boundingBox;
    delete record.boundingBox;
    convertXMLFieldToArrayInPlace(record, "boundingBoxes");
    for (const boundingBox of record.boundingBoxes) {
      boundingBox.value = [boundingBox.upperCorner[0], boundingBox.upperCorner[1], boundingBox.lowerCorner[0], boundingBox.lowerCorner[1]];
      delete boundingBox.upperCorner;
      delete boundingBox.lowerCorner;
    }
  }
  return xmlRecords;
}

// node_modules/@loaders.gl/wms/dist/esm/csw-records-loader.js
var VERSION4 = true ? "3.4.9" : "latest";
var CSWRecordsLoader = {
  id: "csw-records",
  name: "CSW Domain",
  module: "wms",
  version: VERSION4,
  worker: false,
  extensions: ["xml"],
  mimeTypes: ["application/vnd.ogc.csw_xml", "application/xml", "text/xml"],
  testText: testXMLFile4,
  options: {
    csw: {}
  },
  parse: async (arrayBuffer, options) => parseCSWRecords(new TextDecoder().decode(arrayBuffer), options),
  parseTextSync: (text, options) => parseCSWRecords(text, options)
};
function testXMLFile4(text) {
  return text.startsWith("<?xml");
}

// node_modules/@loaders.gl/wms/dist/esm/lib/parsers/wms/parse-wms-error.js
function parseWMSError(text, options) {
  var _XMLLoader$parseTextS, _parsedXML$ServiceExc, _parsedXML$ogcServic;
  const parsedXML = (_XMLLoader$parseTextS = XMLLoader.parseTextSync) === null || _XMLLoader$parseTextS === void 0 ? void 0 : _XMLLoader$parseTextS.call(XMLLoader, text, options);
  const serviceExceptionXML = (parsedXML === null || parsedXML === void 0 ? void 0 : (_parsedXML$ServiceExc = parsedXML.ServiceExceptionReport) === null || _parsedXML$ServiceExc === void 0 ? void 0 : _parsedXML$ServiceExc.ServiceException) || (parsedXML === null || parsedXML === void 0 ? void 0 : (_parsedXML$ogcServic = parsedXML["ogc:ServiceExceptionReport"]) === null || _parsedXML$ogcServic === void 0 ? void 0 : _parsedXML$ogcServic["ogc:ServiceException"]);
  const message = typeof serviceExceptionXML === "string" ? serviceExceptionXML : serviceExceptionXML.value || serviceExceptionXML.code || "Unknown error";
  return message;
}

// node_modules/@loaders.gl/wms/dist/esm/wms-error-loader.js
var VERSION5 = true ? "3.4.9" : "latest";
var WMSErrorLoader = {
  id: "wms-error",
  name: "WMS Error",
  module: "wms",
  version: VERSION5,
  worker: false,
  extensions: ["xml"],
  mimeTypes: ["application/vnd.ogc.se_xml", "application/xml", "text/xml"],
  testText: testXMLFile5,
  options: {
    wms: {
      throwOnError: false
    }
  },
  parse: async (arrayBuffer, options) => parseTextSync3(new TextDecoder().decode(arrayBuffer), options),
  parseSync: (arrayBuffer, options) => parseTextSync3(new TextDecoder().decode(arrayBuffer), options),
  parseTextSync: (text, options) => parseTextSync3(text, options)
};
function testXMLFile5(text) {
  return text.startsWith("<?xml");
}
function parseTextSync3(text, options) {
  const wmsOptions = {
    ...WMSErrorLoader.options.wms,
    ...options === null || options === void 0 ? void 0 : options.wms
  };
  const error = parseWMSError(text, wmsOptions);
  const message = wmsOptions.minimalErrors ? error : "WMS Service error: ".concat(error);
  if (wmsOptions.throwOnError) {
    throw new Error(message);
  }
  return message;
}

// node_modules/@loaders.gl/wms/dist/esm/lib/parsers/xml/parse-xml-helpers.js
function getXMLArray(xmlValue) {
  if (Array.isArray(xmlValue)) {
    return xmlValue;
  }
  if (xmlValue) {
    return [xmlValue];
  }
  return [];
}
function getXMLStringArray(xmlValue) {
  const xmlArray = getXMLArray(xmlValue);
  if (xmlArray.length > 0 && xmlArray.every((_) => typeof _ === "string")) {
    return xmlArray;
  }
  return [];
}
function getXMLFloat(xmlValue) {
  let defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
  switch (typeof xmlValue) {
    case "number":
      return xmlValue;
    case "string":
      return parseFloat(xmlValue);
    default:
      return void 0;
  }
}
function getXMLInteger(xmlValue) {
  let defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
  switch (typeof xmlValue) {
    case "number":
      return xmlValue;
    case "string":
      return parseInt(xmlValue, 10);
    default:
      return void 0;
  }
}
function getXMLBoolean(xmlValue) {
  switch (xmlValue) {
    case "true":
      return true;
    case "false":
      return false;
    case "1":
      return true;
    case "0":
      return false;
    default:
      return false;
  }
}

// node_modules/@loaders.gl/wms/dist/esm/lib/parsers/wms/parse-wms-capabilities.js
function parseWMSCapabilities(xmlText, options) {
  const parsedXML = XMLLoader.parseTextSync(xmlText, options);
  const xmlCapabilities = parsedXML.WMT_MS_Capabilities || parsedXML.WMS_Capabilities || parsedXML;
  const capabilities = extractCapabilities(xmlCapabilities);
  if (options !== null && options !== void 0 && options.inheritedLayerProps) {
    for (const layer of capabilities.layers) {
      addInheritedLayerProps(layer, null);
    }
  }
  if (options !== null && options !== void 0 && options.includeRawData || options !== null && options !== void 0 && options.raw) {
    capabilities.raw = xmlCapabilities;
  }
  if (options !== null && options !== void 0 && options.includeXMLText) {
    capabilities.xml = xmlText;
  }
  return capabilities;
}
function extractCapabilities(xml) {
  var _xml$Service, _xml$Service2, _xml$Service3, _xml$Service4, _xml$Service5, _xml$Service6, _xml$Service6$Keyword, _xml$Service7, _xml$Service8, _xml$Service9, _xml$Service10, _xml$Service11, _xml$Service12, _xml$Service13, _xml$Capability, _xml$Capability2;
  const capabilities = {
    version: String(xml.version || ""),
    name: String(((_xml$Service = xml.Service) === null || _xml$Service === void 0 ? void 0 : _xml$Service.Name) || "unnamed"),
    title: (_xml$Service2 = xml.Service) !== null && _xml$Service2 !== void 0 && _xml$Service2.Title ? String((_xml$Service3 = xml.Service) === null || _xml$Service3 === void 0 ? void 0 : _xml$Service3.Title) : void 0,
    abstract: (_xml$Service4 = xml.Service) !== null && _xml$Service4 !== void 0 && _xml$Service4.Abstract ? String((_xml$Service5 = xml.Service) === null || _xml$Service5 === void 0 ? void 0 : _xml$Service5.Abstract) : void 0,
    keywords: getXMLStringArray((_xml$Service6 = xml.Service) === null || _xml$Service6 === void 0 ? void 0 : (_xml$Service6$Keyword = _xml$Service6.KeywordList) === null || _xml$Service6$Keyword === void 0 ? void 0 : _xml$Service6$Keyword.Keyword),
    fees: (_xml$Service7 = xml.Service) !== null && _xml$Service7 !== void 0 && _xml$Service7.Fees ? JSON.stringify((_xml$Service8 = xml.Service) === null || _xml$Service8 === void 0 ? void 0 : _xml$Service8.Fees) : void 0,
    accessConstraints: (_xml$Service9 = xml.Service) !== null && _xml$Service9 !== void 0 && _xml$Service9.AccessConstraints ? JSON.stringify((_xml$Service10 = xml.Service) === null || _xml$Service10 === void 0 ? void 0 : _xml$Service10.AccessConstraints) : void 0,
    layerLimit: getXMLInteger((_xml$Service11 = xml.Service) === null || _xml$Service11 === void 0 ? void 0 : _xml$Service11.LayerLimit),
    maxWidth: getXMLInteger((_xml$Service12 = xml.Service) === null || _xml$Service12 === void 0 ? void 0 : _xml$Service12.maxWidth),
    maxHeight: getXMLInteger((_xml$Service13 = xml.Service) === null || _xml$Service13 === void 0 ? void 0 : _xml$Service13.maxHeight),
    layers: [],
    requests: extractRequests((_xml$Capability = xml.Capability) === null || _xml$Capability === void 0 ? void 0 : _xml$Capability.Request),
    exceptions: extractExceptions(xml.Exception)
  };
  const xmlLayers = getXMLArray((_xml$Capability2 = xml.Capability) === null || _xml$Capability2 === void 0 ? void 0 : _xml$Capability2.Layer);
  for (const xmlSubLayer of xmlLayers) {
    capabilities.layers.push(extractLayer(xmlSubLayer));
  }
  for (const [key, value] of Object.entries(capabilities)) {
    if (value === void 0) {
      delete capabilities[key];
    }
  }
  return capabilities;
}
function extractRequests(xmlRequests) {
  const requests = {};
  for (const [name, xmlRequest] of Object.entries(xmlRequests || {})) {
    const mimeTypes = getXMLStringArray(xmlRequest === null || xmlRequest === void 0 ? void 0 : xmlRequest.Format);
    requests[name] = {
      mimeTypes
    };
  }
  return requests;
}
function extractExceptions(xmlException) {
  const xmlExceptionFormats = getXMLArray(xmlException === null || xmlException === void 0 ? void 0 : xmlException.Format);
  if (xmlExceptionFormats.length > 0) {
    return {
      mimeTypes: getXMLStringArray(xmlException)
    };
  }
  return void 0;
}
function extractLayer(xmlLayer) {
  var _xmlLayer$KeywordList;
  const layer = {
    title: String((xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.Title) || ""),
    name: (xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.Name) && String(xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.Name),
    abstract: (xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.Name) && String(xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.Abstract),
    keywords: getXMLStringArray((_xmlLayer$KeywordList = xmlLayer.KeywordList) === null || _xmlLayer$KeywordList === void 0 ? void 0 : _xmlLayer$KeywordList.Keyword)
  };
  const crs = (xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.CRS) || (xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.SRS);
  if (crs && Array.isArray(crs) && crs.every((_) => typeof _ === "string")) {
    layer.crs = crs;
  }
  let geographicBoundingBox = (xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.EX_GeographicBoundingBox) && extractEXBoundingBox(xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.EX_GeographicBoundingBox);
  if (geographicBoundingBox) {
    layer.geographicBoundingBox = geographicBoundingBox;
  }
  geographicBoundingBox = (xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.LatLonBoundingBox) && extractLatLonBoundingBox(xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.LatLonBoundingBox);
  if (geographicBoundingBox) {
    layer.geographicBoundingBox = geographicBoundingBox;
  }
  const boundingBoxes = (xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.BoundingBox) && extractWMSBoundingBoxes(xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.BoundingBox);
  if (boundingBoxes && boundingBoxes.length > 0) {
    layer.boundingBoxes = boundingBoxes;
  }
  const xmlDimensions = getXMLArray(xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.Dimension);
  const dimensions = xmlDimensions.map((xml) => extractDimension(xml));
  if (dimensions.length) {
    layer.dimensions = dimensions;
  }
  if (xmlLayer !== null && xmlLayer !== void 0 && xmlLayer.opaque) {
    layer.opaque = getXMLBoolean(xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.opaque);
  }
  if (xmlLayer !== null && xmlLayer !== void 0 && xmlLayer.cascaded) {
    layer.cascaded = getXMLBoolean(xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.cascaded);
  }
  if (xmlLayer !== null && xmlLayer !== void 0 && xmlLayer.queryable) {
    layer.queryable = getXMLBoolean(xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.queryable);
  }
  const xmlLayers = getXMLArray(xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.Layer);
  const layers = [];
  for (const xmlSubLayer of xmlLayers) {
    layers.push(extractLayer(xmlSubLayer));
  }
  if (layers.length > 0) {
    layer.layers = layers;
  }
  for (const [key, value] of Object.entries(layer)) {
    if (value === void 0) {
      delete layer[key];
    }
  }
  return layer;
}
function extractEXBoundingBox(xmlBoundingBox) {
  const {
    westBoundLongitude: w,
    northBoundLatitude: n,
    eastBoundLongitude: e,
    southBoundLatitude: s
  } = xmlBoundingBox;
  return [[w, s], [e, n]];
}
function extractLatLonBoundingBox(xmlBoundingBox) {
  const {
    minx,
    miny,
    maxx,
    maxy
  } = xmlBoundingBox;
  return [[minx, miny], [maxx, maxy]];
}
function extractWMSBoundingBoxes(xmlBoundingBoxes) {
  const xmlBoxes = getXMLArray(xmlBoundingBoxes);
  return xmlBoxes.map((xmlBox) => extractWMSBoundingBox(xmlBox));
}
function extractWMSBoundingBox(xmlBoundingBox) {
  const {
    CRS,
    SRS,
    minx,
    miny,
    maxx,
    maxy,
    resx,
    resy
  } = xmlBoundingBox;
  const boundingBox = {
    crs: CRS || SRS,
    boundingBox: [[getXMLFloat(minx), getXMLFloat(miny)], [getXMLFloat(maxx), getXMLFloat(maxy)]]
  };
  if (resx) {
    boundingBox.xResolution = resx;
  }
  if (resy) {
    boundingBox.yResolution = resy;
  }
  return boundingBox;
}
function extractDimension(xmlDimension) {
  const {
    name,
    units,
    value: extent
  } = xmlDimension;
  const dimension = {
    name,
    units,
    extent
  };
  if (xmlDimension.unitSymbol) {
    dimension.unitSymbol = xmlDimension.unitSymbol;
  }
  if (xmlDimension.default) {
    dimension.defaultValue = xmlDimension.default;
  }
  if (xmlDimension.multipleValues) {
    dimension.multipleValues = getXMLBoolean(xmlDimension.multipleValues);
  }
  if (xmlDimension.nearestValue) {
    dimension.nearestValue = getXMLBoolean(xmlDimension.nearestValue);
  }
  if (xmlDimension.current) {
    dimension.current = getXMLBoolean(xmlDimension.current);
  }
  return dimension;
}
function addInheritedLayerProps(layer, parent) {
  if (parent !== null && parent !== void 0 && parent.geographicBoundingBox && !layer.geographicBoundingBox) {
    layer.geographicBoundingBox = [...parent.geographicBoundingBox];
  }
  if (parent !== null && parent !== void 0 && parent.crs && !layer.crs) {
    layer.crs = [...parent.crs];
  }
  if (parent !== null && parent !== void 0 && parent.boundingBoxes && !layer.boundingBoxes) {
    layer.boundingBoxes = [...parent.boundingBoxes];
  }
  if (parent !== null && parent !== void 0 && parent.dimensions && !layer.dimensions) {
    layer.dimensions = [...parent.dimensions];
  }
  for (const subLayer of layer.layers || []) {
    addInheritedLayerProps(subLayer, layer);
  }
}

// node_modules/@loaders.gl/wms/dist/esm/wms-capabilities-loader.js
var VERSION6 = true ? "3.4.9" : "latest";
var WMSCapabilitiesLoader = {
  id: "wms-capabilities",
  name: "WMS Capabilities",
  module: "wms",
  version: VERSION6,
  worker: false,
  extensions: ["xml"],
  mimeTypes: ["application/vnd.ogc.wms_xml", "application/xml", "text/xml"],
  testText: testXMLFile6,
  options: {
    wms: {}
  },
  parse: async (arrayBuffer, options) => parseWMSCapabilities(new TextDecoder().decode(arrayBuffer), options === null || options === void 0 ? void 0 : options.wms),
  parseTextSync: (text, options) => parseWMSCapabilities(text, options === null || options === void 0 ? void 0 : options.wms)
};
function testXMLFile6(text) {
  return text.startsWith("<?xml");
}

// node_modules/@loaders.gl/wms/dist/esm/lib/parsers/wms/parse-wms-features.js
function parseWMSFeatureInfo(text, options) {
  var _parsedXML$FeatureInf;
  const parsedXML = XMLLoader.parseTextSync(text, options);
  const xmlFeatureInfo = ((_parsedXML$FeatureInf = parsedXML.FeatureInfoResponse) === null || _parsedXML$FeatureInf === void 0 ? void 0 : _parsedXML$FeatureInf.FIELDS) || [];
  const xmlFeatures = Array.isArray(xmlFeatureInfo) ? xmlFeatureInfo : [xmlFeatureInfo];
  return {
    features: xmlFeatures.map((xmlFeature) => extractFeature(xmlFeature))
  };
}
function extractFeature(xmlFeature) {
  const xmlFields = xmlFeature || {};
  return {
    attributes: xmlFields,
    type: "",
    bounds: {
      bottom: 0,
      top: 0,
      left: 0,
      right: 0
    }
  };
}

// node_modules/@loaders.gl/wms/dist/esm/wip/wms-feature-info-loader.js
var WMSFeatureInfoLoader = {
  ...WMSCapabilitiesLoader,
  id: "wms-feature-info",
  name: "WMS FeatureInfo",
  parse: async (arrayBuffer, options) => parseWMSFeatureInfo(new TextDecoder().decode(arrayBuffer), options),
  parseTextSync: (text, options) => parseWMSFeatureInfo(text, options)
};

// node_modules/@loaders.gl/wms/dist/esm/lib/parsers/wms/parse-wms-layer-description.js
function parseWMSLayerDescription(text, options) {
  var _XMLLoader$parseTextS;
  const parsedXML = (_XMLLoader$parseTextS = XMLLoader.parseTextSync) === null || _XMLLoader$parseTextS === void 0 ? void 0 : _XMLLoader$parseTextS.call(XMLLoader, text, options);
  return parsedXML;
}

// node_modules/@loaders.gl/wms/dist/esm/wip/wms-layer-description-loader.js
var WMSLayerDescriptionLoader = {
  ...WMSCapabilitiesLoader,
  id: "wms-layer-description",
  name: "WMS DescribeLayer",
  parse: async (arrayBuffer, options) => parseWMSLayerDescription(new TextDecoder().decode(arrayBuffer), options),
  parseTextSync: (text, options) => parseWMSLayerDescription(text, options)
};

// node_modules/@loaders.gl/wms/dist/esm/lib/parsers/gml/deep-strict-equal.js
var pSlice = Array.prototype.slice;

// node_modules/@turf/helpers/main.es.js
var earthRadius = 63710088e-1;
var factors = {
  meters: earthRadius,
  metres: earthRadius,
  millimeters: earthRadius * 1e3,
  millimetres: earthRadius * 1e3,
  centimeters: earthRadius * 100,
  centimetres: earthRadius * 100,
  kilometers: earthRadius / 1e3,
  kilometres: earthRadius / 1e3,
  miles: earthRadius / 1609.344,
  nauticalmiles: earthRadius / 1852,
  inches: earthRadius * 39.37,
  yards: earthRadius / 1.0936,
  feet: earthRadius * 3.28084,
  radians: 1,
  degrees: earthRadius / 111325
};
var unitsFactors = {
  meters: 1,
  metres: 1,
  millimeters: 1e3,
  millimetres: 1e3,
  centimeters: 100,
  centimetres: 100,
  kilometers: 1 / 1e3,
  kilometres: 1 / 1e3,
  miles: 1 / 1609.344,
  nauticalmiles: 1 / 1852,
  inches: 39.37,
  yards: 1 / 1.0936,
  feet: 3.28084,
  radians: 1 / earthRadius,
  degrees: 1 / 111325
};

// node_modules/@loaders.gl/wms/dist/esm/lib/sources/data-source.js
var DataSource = class {
  constructor(props) {
    _defineProperty(this, "fetch", void 0);
    _defineProperty(this, "loadOptions", void 0);
    _defineProperty(this, "_needsRefresh", true);
    _defineProperty(this, "props", void 0);
    this.props = {
      ...props
    };
    this.loadOptions = {
      ...props.loadOptions
    };
    this.fetch = getFetchFunction(this.loadOptions);
  }
  setProps(props) {
    this.props = Object.assign(this.props, props);
    this.setNeedsRefresh();
  }
  setNeedsRefresh() {
    this._needsRefresh = true;
  }
  getNeedsRefresh() {
    let clear2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    const needsRefresh = this._needsRefresh;
    if (clear2) {
      this._needsRefresh = false;
    }
    return needsRefresh;
  }
};
function getFetchFunction(options) {
  const fetchFunction = options === null || options === void 0 ? void 0 : options.fetch;
  if (fetchFunction && typeof fetchFunction === "function") {
    return (url, fetchOptions2) => fetchFunction(url, fetchOptions2);
  }
  const fetchOptions = options === null || options === void 0 ? void 0 : options.fetch;
  if (fetchOptions && typeof fetchOptions !== "function") {
    return (url) => fetch(url, fetchOptions);
  }
  return (url) => fetch(url);
}

// node_modules/@loaders.gl/wms/dist/esm/lib/sources/image-source.js
var ImageSource = class extends DataSource {
};

// node_modules/@loaders.gl/wms/dist/esm/lib/services/generic/image-service.js
var ImageService = class extends ImageSource {
  constructor(props) {
    super(props);
  }
  async getMetadata() {
    throw new Error("ImageSource.getMetadata not implemented");
  }
  async getImage(parameters2) {
    const granularParameters = this.getGranularParameters(parameters2);
    const url = this.getURLFromTemplate(granularParameters);
    const response = await this.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    return await ImageLoader.parse(arrayBuffer);
  }
  getGranularParameters(parameters2) {
    const [east, north, west, south] = parameters2.bbox;
    return {
      ...parameters2,
      east,
      north,
      south,
      west
    };
  }
  getURLFromTemplate(parameters2) {
    let url = this.props.url;
    for (const [key, value] of Object.entries(parameters2)) {
      url = url.replace("${".concat(key, "}"), String(value));
      url = url.replace("{".concat(key, "}"), String(value));
    }
    return url;
  }
};
_defineProperty(ImageService, "type", "template");
_defineProperty(ImageService, "testURL", (url) => url.toLowerCase().includes("{"));

// node_modules/@loaders.gl/wms/dist/esm/lib/services/ogc/wms-service.js
var WMSService = class extends ImageSource {
  constructor(props) {
    var _props$substituteCRS;
    super(props);
    _defineProperty(this, "url", void 0);
    _defineProperty(this, "substituteCRS84", void 0);
    _defineProperty(this, "flipCRS", void 0);
    _defineProperty(this, "wmsParameters", void 0);
    _defineProperty(this, "vendorParameters", void 0);
    _defineProperty(this, "capabilities", null);
    _defineProperty(this, "loaders", [ImageLoader, WMSErrorLoader, WMSCapabilitiesLoader, WMSFeatureInfoLoader, WMSLayerDescriptionLoader]);
    this.url = props.url;
    this.substituteCRS84 = (_props$substituteCRS = props.substituteCRS84) !== null && _props$substituteCRS !== void 0 ? _props$substituteCRS : false;
    this.flipCRS = ["EPSG:4326"];
    this.wmsParameters = {
      layers: void 0,
      query_layers: void 0,
      styles: void 0,
      version: "1.3.0",
      crs: "EPSG:4326",
      format: "image/png",
      info_format: "text/plain",
      transparent: void 0,
      time: void 0,
      elevation: void 0,
      ...props.wmsParameters
    };
    this.vendorParameters = props.vendorParameters || {};
  }
  async getMetadata() {
    const capabilities = await this.getCapabilities();
    return this.normalizeMetadata(capabilities);
  }
  async getImage(parameters2) {
    return await this.getMap(parameters2);
  }
  normalizeMetadata(capabilities) {
    return capabilities;
  }
  async getCapabilities(wmsParameters, vendorParameters) {
    const url = this.getCapabilitiesURL(wmsParameters, vendorParameters);
    const response = await this.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    this._checkResponse(response, arrayBuffer);
    const capabilities = await WMSCapabilitiesLoader.parse(arrayBuffer, this.loadOptions);
    this.capabilities = capabilities;
    return capabilities;
  }
  async getMap(wmsParameters, vendorParameters) {
    const url = this.getMapURL(wmsParameters, vendorParameters);
    const response = await this.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    this._checkResponse(response, arrayBuffer);
    try {
      return await ImageLoader.parse(arrayBuffer, this.loadOptions);
    } catch {
      throw this._parseError(arrayBuffer);
    }
  }
  async getFeatureInfo(wmsParameters, vendorParameters) {
    const url = this.getFeatureInfoURL(wmsParameters, vendorParameters);
    const response = await this.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    this._checkResponse(response, arrayBuffer);
    return await WMSFeatureInfoLoader.parse(arrayBuffer, this.loadOptions);
  }
  async getFeatureInfoText(wmsParameters, vendorParameters) {
    const url = this.getFeatureInfoURL(wmsParameters, vendorParameters);
    const response = await this.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    this._checkResponse(response, arrayBuffer);
    return new TextDecoder().decode(arrayBuffer);
  }
  async describeLayer(wmsParameters, vendorParameters) {
    const url = this.describeLayerURL(wmsParameters, vendorParameters);
    const response = await this.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    this._checkResponse(response, arrayBuffer);
    return await WMSLayerDescriptionLoader.parse(arrayBuffer, this.loadOptions);
  }
  async getLegendGraphic(wmsParameters, vendorParameters) {
    const url = this.getLegendGraphicURL(wmsParameters, vendorParameters);
    const response = await this.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    this._checkResponse(response, arrayBuffer);
    try {
      return await ImageLoader.parse(arrayBuffer, this.loadOptions);
    } catch {
      throw this._parseError(arrayBuffer);
    }
  }
  getCapabilitiesURL(wmsParameters, vendorParameters) {
    const options = {
      version: this.wmsParameters.version,
      ...wmsParameters
    };
    return this._getWMSUrl("GetCapabilities", options, vendorParameters);
  }
  getMapURL(wmsParameters, vendorParameters) {
    wmsParameters = this._getWMS130Parameters(wmsParameters);
    const options = {
      version: this.wmsParameters.version,
      format: this.wmsParameters.format,
      transparent: this.wmsParameters.transparent,
      time: this.wmsParameters.time,
      elevation: this.wmsParameters.elevation,
      layers: this.wmsParameters.layers,
      styles: this.wmsParameters.styles,
      crs: this.wmsParameters.crs,
      ...wmsParameters
    };
    return this._getWMSUrl("GetMap", options, vendorParameters);
  }
  getFeatureInfoURL(wmsParameters, vendorParameters) {
    const options = {
      version: this.wmsParameters.version,
      info_format: this.wmsParameters.info_format,
      layers: this.wmsParameters.layers,
      query_layers: this.wmsParameters.query_layers,
      styles: this.wmsParameters.styles,
      crs: this.wmsParameters.crs,
      ...wmsParameters
    };
    return this._getWMSUrl("GetFeatureInfo", options, vendorParameters);
  }
  describeLayerURL(wmsParameters, vendorParameters) {
    const options = {
      version: this.wmsParameters.version,
      ...wmsParameters
    };
    return this._getWMSUrl("DescribeLayer", options, vendorParameters);
  }
  getLegendGraphicURL(wmsParameters, vendorParameters) {
    const options = {
      version: this.wmsParameters.version,
      ...wmsParameters
    };
    return this._getWMSUrl("GetLegendGraphic", options, vendorParameters);
  }
  _parseWMSUrl(url) {
    const [baseUrl, search] = url.split("?");
    const searchParams = search.split("&");
    const parameters2 = {};
    for (const parameter of searchParams) {
      const [key, value] = parameter.split("=");
      parameters2[key] = value;
    }
    return {
      url: baseUrl,
      parameters: parameters2
    };
  }
  _getWMSUrl(request, wmsParameters, vendorParameters) {
    let url = this.url;
    let first = true;
    const allParameters = {
      service: "WMS",
      version: wmsParameters.version,
      request,
      ...wmsParameters,
      ...this.vendorParameters,
      ...vendorParameters
    };
    const IGNORE_EMPTY_KEYS = ["transparent", "time", "elevation"];
    for (const [key, value] of Object.entries(allParameters)) {
      if (!IGNORE_EMPTY_KEYS.includes(key) || value) {
        url += first ? "?" : "&";
        first = false;
        url += this._getURLParameter(key, value, wmsParameters);
      }
    }
    return encodeURI(url);
  }
  _getWMS130Parameters(wmsParameters) {
    const newParameters = {
      ...wmsParameters
    };
    if (newParameters.srs) {
      newParameters.crs = newParameters.crs || newParameters.srs;
      delete newParameters.srs;
    }
    return newParameters;
  }
  _getURLParameter(key, value, wmsParameters) {
    switch (key) {
      case "crs":
        if (wmsParameters.version !== "1.3.0") {
          key = "srs";
        } else if (this.substituteCRS84 && value === "EPSG:4326") {
          value = "CRS:84";
        }
        break;
      case "srs":
        if (wmsParameters.version === "1.3.0") {
          key = "crs";
        }
        break;
      case "bbox":
        const bbox = this._flipBoundingBox(value, wmsParameters);
        if (bbox) {
          value = bbox;
        }
        break;
      default:
    }
    key = key.toUpperCase();
    return Array.isArray(value) ? "".concat(key, "=").concat(value.join(",")) : "".concat(key, "=").concat(value ? String(value) : "");
  }
  _flipBoundingBox(bboxValue, wmsParameters) {
    if (!Array.isArray(bboxValue) || bboxValue.length !== 4) {
      return null;
    }
    const flipCoordinates = wmsParameters.version === "1.3.0" && this.flipCRS.includes(wmsParameters.crs || "") && !(this.substituteCRS84 && wmsParameters.crs === "EPSG:4326");
    const bbox = bboxValue;
    return flipCoordinates ? [bbox[1], bbox[0], bbox[3], bbox[2]] : bbox;
  }
  async _fetchArrayBuffer(url) {
    const response = await this.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    this._checkResponse(response, arrayBuffer);
    return arrayBuffer;
  }
  _checkResponse(response, arrayBuffer) {
    const contentType = response.headers["content-type"];
    if (!response.ok || WMSErrorLoader.mimeTypes.includes(contentType)) {
      const loadOptions = mergeLoaderOptions(this.loadOptions, {
        wms: {
          throwOnError: true
        }
      });
      const error = WMSErrorLoader.parseSync(arrayBuffer, loadOptions);
      throw new Error(error);
    }
  }
  _parseError(arrayBuffer) {
    const error = WMSErrorLoader.parseSync(arrayBuffer, this.loadOptions);
    return new Error(error);
  }
};
_defineProperty(WMSService, "type", "wms");
_defineProperty(WMSService, "testURL", (url) => url.toLowerCase().includes("wms"));

// node_modules/@loaders.gl/wms/dist/esm/lib/services/arcgis/arcgis-image-service.js
var ArcGISImageServer = class extends ImageSource {
  constructor(props) {
    super(props);
  }
  async getMetadata() {
    return await this.metadata();
  }
  async getImage(parameters2) {
    throw new Error("not implemented");
  }
  async metadata() {
    throw new Error("not implemented");
  }
  exportImage(options) {
    throw new Error("not implemented");
  }
  metadataURL(options) {
    return "".concat(this.props.url, "?f=pjson");
  }
  exportImageURL(options) {
    const bbox = "bbox=".concat(options.bbox[0], ",").concat(options.bbox[1], ",").concat(options.bbox[2], ",").concat(options.bbox[3]);
    const size = "size=".concat(options.width, ",").concat(options.height);
    const arcgisOptions = {
      ...options,
      bbox,
      size
    };
    delete arcgisOptions.width;
    delete arcgisOptions.height;
    return this.getUrl("exportImage", arcgisOptions);
  }
  getUrl(path, options, extra) {
    let url = "".concat(this.props.url, "/").concat(path);
    let first = true;
    for (const [key, value] of Object.entries(options)) {
      url += first ? "?" : "&";
      first = false;
      if (Array.isArray(value)) {
        url += "".concat(key.toUpperCase(), "=").concat(value.join(","));
      } else {
        url += "".concat(key.toUpperCase(), "=").concat(value ? String(value) : "");
      }
    }
    return url;
  }
  async checkResponse(response) {
    if (!response.ok) {
      throw new Error("error");
    }
  }
};
_defineProperty(ArcGISImageServer, "type", "arcgis-image-server");
_defineProperty(ArcGISImageServer, "testURL", (url) => url.toLowerCase().includes("ImageServer"));

// node_modules/@loaders.gl/wms/dist/esm/lib/create-image-source.js
var SERVICES = [WMSService, ArcGISImageServer, ImageService];
function createImageSource(props) {
  const {
    type = "auto"
  } = props;
  const serviceType = type === "auto" ? guessServiceType(props.url) : type;
  switch (serviceType) {
    case "template":
      return new ImageService(props);
    case "wms":
      return new WMSService(props);
    default:
      throw new Error("Not a valid image source type");
  }
}
function guessServiceType(url) {
  for (const Service of SERVICES) {
    if (Service.testURL && Service.testURL(url)) {
      return Service.type;
    }
  }
  return "wms";
}

// node_modules/@loaders.gl/wms/dist/esm/lib/services/ogc/csw-service.js
var CSWService = class extends DataSource {
  constructor(props) {
    super(props);
    _defineProperty(this, "capabilities", null);
    _defineProperty(this, "loaders", [WMSErrorLoader, CSWCapabilitiesLoader]);
  }
  async getMetadata() {
    const capabilities = await this.getCapabilities();
    return this.normalizeMetadata(capabilities);
  }
  normalizeMetadata(capabilities) {
    return capabilities;
  }
  async getServiceDirectory(options) {
    const services = [];
    const unknownServices = [];
    const records = await this.getRecords();
    for (const record of records.records) {
      for (const reference of record.references) {
        const url = reference.value;
        switch (reference.scheme) {
          case "OGC:WMS":
            services.push({
              name: record.title,
              type: "ogc-wms-service",
              ...this._parseOGCUrl(url)
            });
            break;
          case "OGC:WMTS":
            services.push({
              name: record.title,
              type: "ogc-wmts-service",
              ...this._parseOGCUrl(url)
            });
            break;
          case "OGC:WFS":
            services.push({
              name: record.title,
              type: "ogc-wfs-service",
              ...this._parseOGCUrl(url)
            });
            break;
          default:
            unknownServices.push({
              name: record.title,
              type: "unknown",
              url: reference.value,
              scheme: reference.scheme
            });
        }
      }
    }
    return options !== null && options !== void 0 && options.includeUnknown ? services.concat(unknownServices) : services;
  }
  _parseOGCUrl(url) {
    const parts = url.split("?");
    return {
      url: parts[0],
      params: parts[1] || ""
    };
  }
  async getCapabilities(wmsParameters, vendorParameters) {
    const url = this.getCapabilitiesURL(wmsParameters, vendorParameters);
    const response = await this.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    this._checkResponse(response, arrayBuffer);
    const capabilities = await CSWCapabilitiesLoader.parse(arrayBuffer, this.props.loadOptions);
    return capabilities;
  }
  async getRecords(wmsParameters, vendorParameters) {
    const url = this.getRecordsURL(wmsParameters, vendorParameters);
    const response = await this.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    this._checkResponse(response, arrayBuffer);
    return await CSWRecordsLoader.parse(arrayBuffer, this.props.loadOptions);
  }
  async getDomain(wmsParameters, vendorParameters) {
    const url = this.getDomainURL(wmsParameters, vendorParameters);
    const response = await this.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    this._checkResponse(response, arrayBuffer);
    return await CSWDomainLoader.parse(arrayBuffer, this.props.loadOptions);
  }
  getCapabilitiesURL(wmsParameters, vendorParameters) {
    const options = {
      version: "3.0.0",
      ...wmsParameters,
      ...vendorParameters,
      service: "CSW",
      request: "GetCapabilities"
    };
    return this._getCSWUrl(options, vendorParameters);
  }
  getRecordsURL(wmsParameters, vendorParameters) {
    const options = {
      version: "3.0.0",
      typenames: "csw:Record",
      ...wmsParameters,
      ...vendorParameters,
      service: "CSW",
      request: "GetRecords"
    };
    return this._getCSWUrl(options, vendorParameters);
  }
  getDomainURL(wmsParameters, vendorParameters) {
    const options = {
      version: "3.0.0",
      ...wmsParameters,
      ...vendorParameters,
      service: "CSW",
      request: "GetDomain"
    };
    return this._getCSWUrl(options, vendorParameters);
  }
  _getCSWUrl(options, vendorParameters) {
    let url = this.props.url;
    let first = true;
    for (const [key, value] of Object.entries(options)) {
      url += first ? "?" : "&";
      first = false;
      if (Array.isArray(value)) {
        url += "".concat(key.toUpperCase(), "=").concat(value.join(","));
      } else {
        url += "".concat(key.toUpperCase(), "=").concat(value ? String(value) : "");
      }
    }
    return encodeURI(url);
  }
  _checkResponse(response, arrayBuffer) {
    const contentType = response.headers["content-type"];
    if (!response.ok || WMSErrorLoader.mimeTypes.includes(contentType)) {
      const error = WMSErrorLoader.parseSync(arrayBuffer, this.props.loadOptions);
      throw new Error(error);
    }
  }
  _parseError(arrayBuffer) {
    const error = WMSErrorLoader.parseSync(arrayBuffer, this.props.loadOptions);
    return new Error(error);
  }
};
_defineProperty(CSWService, "type", "csw");
_defineProperty(CSWService, "testURL", (url) => url.toLowerCase().includes("csw"));

// node_modules/@deck.gl/geo-layers/dist/esm/wms-layer/utils.js
var HALF_EARTH_CIRCUMFERENCE = 6378137 * Math.PI;
function WGS84ToPseudoMercator(coord) {
  const mercator = lngLatToWorld(coord);
  mercator[0] = (mercator[0] / 256 - 1) * HALF_EARTH_CIRCUMFERENCE;
  mercator[1] = (mercator[1] / 256 - 1) * HALF_EARTH_CIRCUMFERENCE;
  return mercator;
}

// node_modules/@deck.gl/geo-layers/dist/esm/wms-layer/wms-layer.js
var defaultProps = {
  id: "imagery-layer",
  data: "",
  serviceType: "auto",
  srs: "auto",
  layers: {
    type: "array",
    compare: true,
    value: []
  },
  onMetadataLoad: {
    type: "function",
    value: () => {
    }
  },
  onMetadataLoadError: {
    type: "function",
    value: console.error
  },
  onImageLoadStart: {
    type: "function",
    value: () => {
    }
  },
  onImageLoad: {
    type: "function",
    value: () => {
    }
  },
  onImageLoadError: {
    type: "function",
    compare: false,
    value: (requestId, error) => console.error(error, requestId)
  }
};
var WMSLayer = class extends CompositeLayer {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "state", void 0);
  }
  get isLoaded() {
    return Boolean(this.state) && this.state.loadCounter === 0 && super.isLoaded;
  }
  shouldUpdateState() {
    return true;
  }
  initializeState() {
    this.state._nextRequestId = 0;
    this.state.lastRequestId = -1;
    this.state.loadCounter = 0;
  }
  updateState({
    changeFlags,
    props,
    oldProps
  }) {
    const {
      viewport
    } = this.context;
    if (changeFlags.dataChanged || props.serviceType !== oldProps.serviceType) {
      this.state.imageSource = this._createImageSource(props);
      this._loadMetadata();
      this.debounce(() => this.loadImage(viewport, "image source changed"), 0);
    } else if (!deepEqual(props.layers, oldProps.layers, 1)) {
      this.debounce(() => this.loadImage(viewport, "layers changed"), 0);
    } else if (changeFlags.viewportChanged) {
      this.debounce(() => this.loadImage(viewport, "viewport changed"));
    }
  }
  finalizeState() {
  }
  renderLayers() {
    const {
      bounds,
      image,
      lastRequestParameters
    } = this.state;
    return image && new BitmapLayer({
      ...this.getSubLayerProps({
        id: "bitmap"
      }),
      _imageCoordinateSystem: lastRequestParameters.srs === "EPSG:4326" ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN,
      bounds,
      image
    });
  }
  async getFeatureInfoText(x2, y2) {
    const {
      lastRequestParameters
    } = this.state;
    if (lastRequestParameters) {
      var _this$state$imageSour, _this$state$imageSour2;
      const featureInfo = await ((_this$state$imageSour = (_this$state$imageSour2 = this.state.imageSource).getFeatureInfoText) === null || _this$state$imageSour === void 0 ? void 0 : _this$state$imageSour.call(_this$state$imageSour2, {
        ...lastRequestParameters,
        query_layers: lastRequestParameters.layers,
        x: x2,
        y: y2,
        info_format: "application/vnd.ogc.gml"
      }));
      return featureInfo;
    }
    return "";
  }
  _createImageSource(props) {
    if (props.data instanceof ImageSource) {
      return props.data;
    }
    if (typeof props.data === "string") {
      return createImageSource({
        url: props.data,
        loadOptions: props.loadOptions,
        type: props.serviceType
      });
    }
    throw new Error("invalid image source in props.data");
  }
  async _loadMetadata() {
    const {
      imageSource
    } = this.state;
    try {
      this.state.loadCounter++;
      const metadata = await imageSource.getMetadata();
      if (this.state.imageSource === imageSource) {
        var _this$getCurrentLayer;
        (_this$getCurrentLayer = this.getCurrentLayer()) === null || _this$getCurrentLayer === void 0 ? void 0 : _this$getCurrentLayer.props.onMetadataLoad(metadata);
      }
    } catch (error) {
      var _this$getCurrentLayer2;
      (_this$getCurrentLayer2 = this.getCurrentLayer()) === null || _this$getCurrentLayer2 === void 0 ? void 0 : _this$getCurrentLayer2.props.onMetadataLoadError(error);
    } finally {
      this.state.loadCounter--;
    }
  }
  async loadImage(viewport, reason) {
    const {
      layers,
      serviceType
    } = this.props;
    if (serviceType === "wms" && layers.length === 0) {
      return;
    }
    const bounds = viewport.getBounds();
    const {
      width,
      height
    } = viewport;
    const requestId = this.getRequestId();
    let {
      srs
    } = this.props;
    if (srs === "auto") {
      srs = viewport.resolution ? "EPSG:4326" : "EPSG:3857";
    }
    const requestParams = {
      width,
      height,
      bbox: bounds,
      layers,
      srs
    };
    if (srs === "EPSG:3857") {
      const [minX, minY] = WGS84ToPseudoMercator([bounds[0], bounds[1]]);
      const [maxX, maxY] = WGS84ToPseudoMercator([bounds[2], bounds[3]]);
      requestParams.bbox = [minX, minY, maxX, maxY];
    }
    try {
      this.state.loadCounter++;
      this.props.onImageLoadStart(requestId);
      const image = await this.state.imageSource.getImage(requestParams);
      if (this.state.lastRequestId < requestId) {
        var _this$getCurrentLayer3;
        (_this$getCurrentLayer3 = this.getCurrentLayer()) === null || _this$getCurrentLayer3 === void 0 ? void 0 : _this$getCurrentLayer3.props.onImageLoad(requestId);
        this.setState({
          image,
          bounds,
          lastRequestParameters: requestParams,
          lastRequestId: requestId
        });
      }
    } catch (error) {
      var _this$getCurrentLayer4;
      this.raiseError(error, "Load image");
      (_this$getCurrentLayer4 = this.getCurrentLayer()) === null || _this$getCurrentLayer4 === void 0 ? void 0 : _this$getCurrentLayer4.props.onImageLoadError(requestId, error);
    } finally {
      this.state.loadCounter--;
    }
  }
  getRequestId() {
    return this.state._nextRequestId++;
  }
  debounce(fn, ms = 500) {
    clearTimeout(this.state._timeoutId);
    this.state._timeoutId = setTimeout(() => fn(), ms);
  }
};
_defineProperty(WMSLayer, "layerName", "WMSLayer");
_defineProperty(WMSLayer, "defaultProps", defaultProps);

// node_modules/@deck.gl/geo-layers/dist/esm/great-circle-layer/great-circle-layer.js
var defaultProps2 = {
  getHeight: {
    type: "accessor",
    value: 0
  },
  greatCircle: true
};
var GreatCircleLayer = class extends ArcLayer {
};
_defineProperty(GreatCircleLayer, "layerName", "GreatCircleLayer");
_defineProperty(GreatCircleLayer, "defaultProps", defaultProps2);

// node_modules/@deck.gl/geo-layers/dist/esm/geo-cell-layer/GeoCellLayer.js
var defaultProps3 = {
  ...PolygonLayer.defaultProps
};
var GeoCellLayer = class extends CompositeLayer {
  indexToBounds() {
    return null;
  }
  renderLayers() {
    const {
      elevationScale,
      extruded,
      wireframe,
      filled,
      stroked,
      lineWidthUnits,
      lineWidthScale,
      lineWidthMinPixels,
      lineWidthMaxPixels,
      lineJointRounded,
      lineMiterLimit,
      lineDashJustified,
      getElevation,
      getFillColor,
      getLineColor,
      getLineWidth
    } = this.props;
    const {
      updateTriggers,
      material,
      transitions
    } = this.props;
    const CellLayer = this.getSubLayerClass("cell", PolygonLayer);
    const {
      updateTriggers: boundsUpdateTriggers,
      ...boundsProps
    } = this.indexToBounds() || {};
    return new CellLayer({
      filled,
      wireframe,
      extruded,
      elevationScale,
      stroked,
      lineWidthUnits,
      lineWidthScale,
      lineWidthMinPixels,
      lineWidthMaxPixels,
      lineJointRounded,
      lineMiterLimit,
      lineDashJustified,
      material,
      transitions,
      getElevation,
      getFillColor,
      getLineColor,
      getLineWidth
    }, this.getSubLayerProps({
      id: "cell",
      updateTriggers: updateTriggers && {
        ...boundsUpdateTriggers,
        getElevation: updateTriggers.getElevation,
        getFillColor: updateTriggers.getFillColor,
        getLineColor: updateTriggers.getLineColor,
        getLineWidth: updateTriggers.getLineWidth
      }
    }), boundsProps);
  }
};
_defineProperty(GeoCellLayer, "layerName", "GeoCellLayer");
_defineProperty(GeoCellLayer, "defaultProps", defaultProps3);

// node_modules/@deck.gl/geo-layers/dist/esm/s2-layer/s2-geometry.js
var import_long = __toESM(require_long());
var FACE_BITS = 3;
var MAX_LEVEL = 30;
var POS_BITS = 2 * MAX_LEVEL + 1;
var RADIAN_TO_DEGREE = 180 / Math.PI;
function IJToST(ij, order, offsets) {
  const maxSize = 1 << order;
  return [(ij[0] + offsets[0]) / maxSize, (ij[1] + offsets[1]) / maxSize];
}
function singleSTtoUV(st) {
  if (st >= 0.5) {
    return 1 / 3 * (4 * st * st - 1);
  }
  return 1 / 3 * (1 - 4 * (1 - st) * (1 - st));
}
function STToUV(st) {
  return [singleSTtoUV(st[0]), singleSTtoUV(st[1])];
}
function FaceUVToXYZ(face, [u, v]) {
  switch (face) {
    case 0:
      return [1, u, v];
    case 1:
      return [-u, 1, v];
    case 2:
      return [-u, -v, 1];
    case 3:
      return [-1, -v, -u];
    case 4:
      return [v, -1, -u];
    case 5:
      return [v, u, -1];
    default:
      throw new Error("Invalid face");
  }
}
function XYZToLngLat([x2, y2, z]) {
  const lat = Math.atan2(z, Math.sqrt(x2 * x2 + y2 * y2));
  const lng = Math.atan2(y2, x2);
  return [lng * RADIAN_TO_DEGREE, lat * RADIAN_TO_DEGREE];
}
function toHilbertQuadkey(idS) {
  let bin = import_long.default.fromString(idS, true, 10).toString(2);
  while (bin.length < FACE_BITS + POS_BITS) {
    bin = "0" + bin;
  }
  const lsbIndex = bin.lastIndexOf("1");
  const faceB = bin.substring(0, 3);
  const posB = bin.substring(3, lsbIndex);
  const levelN = posB.length / 2;
  const faceS = import_long.default.fromString(faceB, true, 2).toString(10);
  let posS = import_long.default.fromString(posB, true, 2).toString(4);
  while (posS.length < levelN) {
    posS = "0" + posS;
  }
  return "".concat(faceS, "/").concat(posS);
}
function rotateAndFlipQuadrant(n, point2, rx, ry) {
  if (ry === 0) {
    if (rx === 1) {
      point2[0] = n - 1 - point2[0];
      point2[1] = n - 1 - point2[1];
    }
    const x2 = point2[0];
    point2[0] = point2[1];
    point2[1] = x2;
  }
}
function FromHilbertQuadKey(hilbertQuadkey) {
  const parts = hilbertQuadkey.split("/");
  const face = parseInt(parts[0], 10);
  const position = parts[1];
  const maxLevel = position.length;
  const point2 = [0, 0];
  let level;
  for (let i2 = maxLevel - 1; i2 >= 0; i2--) {
    level = maxLevel - i2;
    const bit = position[i2];
    let rx = 0;
    let ry = 0;
    if (bit === "1") {
      ry = 1;
    } else if (bit === "2") {
      rx = 1;
      ry = 1;
    } else if (bit === "3") {
      rx = 1;
    }
    const val2 = Math.pow(2, level - 1);
    rotateAndFlipQuadrant(val2, point2, rx, ry);
    point2[0] += val2 * rx;
    point2[1] += val2 * ry;
  }
  if (face % 2 === 1) {
    const t = point2[0];
    point2[0] = point2[1];
    point2[1] = t;
  }
  return {
    face,
    ij: point2,
    level
  };
}

// node_modules/@deck.gl/geo-layers/dist/esm/s2-layer/s2-utils.js
var import_long2 = __toESM(require_long());
function getIdFromToken(token) {
  const paddedToken = token.padEnd(16, "0");
  return import_long2.default.fromString(paddedToken, 16);
}
var MAX_RESOLUTION = 100;
function getGeoBounds({
  face,
  ij,
  level
}) {
  const offsets = [[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]];
  const resolution = Math.max(1, Math.ceil(MAX_RESOLUTION * Math.pow(2, -level)));
  const result = new Float64Array(4 * resolution * 2 + 2);
  let ptIndex = 0;
  let prevLng = 0;
  for (let i2 = 0; i2 < 4; i2++) {
    const offset = offsets[i2].slice(0);
    const nextOffset = offsets[i2 + 1];
    const stepI = (nextOffset[0] - offset[0]) / resolution;
    const stepJ = (nextOffset[1] - offset[1]) / resolution;
    for (let j = 0; j < resolution; j++) {
      offset[0] += stepI;
      offset[1] += stepJ;
      const st = IJToST(ij, level, offset);
      const uv = STToUV(st);
      const xyz = FaceUVToXYZ(face, uv);
      const lngLat = XYZToLngLat(xyz);
      if (Math.abs(lngLat[1]) > 89.999) {
        lngLat[0] = prevLng;
      }
      const deltaLng = lngLat[0] - prevLng;
      lngLat[0] += deltaLng > 180 ? -360 : deltaLng < -180 ? 360 : 0;
      result[ptIndex++] = lngLat[0];
      result[ptIndex++] = lngLat[1];
      prevLng = lngLat[0];
    }
  }
  result[ptIndex++] = result[0];
  result[ptIndex++] = result[1];
  return result;
}
function getS2QuadKey(token) {
  if (typeof token === "string") {
    if (token.indexOf("/") > 0) {
      return token;
    }
    token = getIdFromToken(token);
  }
  return toHilbertQuadkey(token.toString());
}
function getS2Polygon(token) {
  const key = getS2QuadKey(token);
  const s2cell = FromHilbertQuadKey(key);
  return getGeoBounds(s2cell);
}

// node_modules/@deck.gl/geo-layers/dist/esm/s2-layer/s2-layer.js
var defaultProps4 = {
  getS2Token: {
    type: "accessor",
    value: (d) => d.token
  }
};
var S2Layer = class extends GeoCellLayer {
  indexToBounds() {
    const {
      data,
      getS2Token
    } = this.props;
    return {
      data,
      _normalize: false,
      positionFormat: "XY",
      getPolygon: (x2, objectInfo) => getS2Polygon(getS2Token(x2, objectInfo))
    };
  }
};
_defineProperty(S2Layer, "layerName", "S2Layer");
_defineProperty(S2Layer, "defaultProps", defaultProps4);

// node_modules/@deck.gl/geo-layers/dist/esm/quadkey-layer/quadkey-utils.js
var TILE_SIZE = 512;
function quadkeyToWorldBounds(quadkey, coverage) {
  let x2 = 0;
  let y2 = 0;
  let mask = 1 << quadkey.length;
  const scale = mask / TILE_SIZE;
  for (let i2 = 0; i2 < quadkey.length; i2++) {
    mask >>= 1;
    const q = parseInt(quadkey[i2]);
    if (q % 2)
      x2 |= mask;
    if (q > 1)
      y2 |= mask;
  }
  return [[x2 / scale, TILE_SIZE - y2 / scale], [(x2 + coverage) / scale, TILE_SIZE - (y2 + coverage) / scale]];
}
function getQuadkeyPolygon(quadkey, coverage = 1) {
  const [topLeft, bottomRight] = quadkeyToWorldBounds(quadkey, coverage);
  const [w, n] = worldToLngLat(topLeft);
  const [e, s] = worldToLngLat(bottomRight);
  return [e, n, e, s, w, s, w, n, e, n];
}

// node_modules/@deck.gl/geo-layers/dist/esm/quadkey-layer/quadkey-layer.js
var defaultProps5 = {
  getQuadkey: {
    type: "accessor",
    value: (d) => d.quadkey
  }
};
var QuadkeyLayer = class extends GeoCellLayer {
  indexToBounds() {
    const {
      data,
      extruded,
      getQuadkey
    } = this.props;
    const coverage = extruded ? 0.99 : 1;
    return {
      data,
      _normalize: false,
      positionFormat: "XY",
      getPolygon: (x2, objectInfo) => getQuadkeyPolygon(getQuadkey(x2, objectInfo), coverage),
      updateTriggers: {
        getPolygon: coverage
      }
    };
  }
};
_defineProperty(QuadkeyLayer, "layerName", "QuadkeyLayer");
_defineProperty(QuadkeyLayer, "defaultProps", defaultProps5);

// node_modules/@deck.gl/geo-layers/dist/esm/tileset-2d/tile-2d-header.js
var Tile2DHeader = class {
  constructor(index) {
    _defineProperty(this, "index", void 0);
    _defineProperty(this, "isVisible", void 0);
    _defineProperty(this, "isSelected", void 0);
    _defineProperty(this, "parent", void 0);
    _defineProperty(this, "children", void 0);
    _defineProperty(this, "content", void 0);
    _defineProperty(this, "state", void 0);
    _defineProperty(this, "layers", void 0);
    _defineProperty(this, "id", void 0);
    _defineProperty(this, "zoom", void 0);
    _defineProperty(this, "userData", void 0);
    _defineProperty(this, "boundingBox", void 0);
    _defineProperty(this, "_abortController", void 0);
    _defineProperty(this, "_loader", void 0);
    _defineProperty(this, "_loaderId", void 0);
    _defineProperty(this, "_isLoaded", void 0);
    _defineProperty(this, "_isCancelled", void 0);
    _defineProperty(this, "_needsReload", void 0);
    _defineProperty(this, "_bbox", void 0);
    this.index = index;
    this.isVisible = false;
    this.isSelected = false;
    this.parent = null;
    this.children = [];
    this.content = null;
    this._loader = void 0;
    this._abortController = null;
    this._loaderId = 0;
    this._isLoaded = false;
    this._isCancelled = false;
    this._needsReload = false;
  }
  get bbox() {
    return this._bbox;
  }
  set bbox(value) {
    if (this._bbox)
      return;
    this._bbox = value;
    if ("west" in value) {
      this.boundingBox = [[value.west, value.south], [value.east, value.north]];
    } else {
      this.boundingBox = [[value.left, value.top], [value.right, value.bottom]];
    }
  }
  get data() {
    return this.isLoading && this._loader ? this._loader.then(() => this.data) : this.content;
  }
  get isLoaded() {
    return this._isLoaded && !this._needsReload;
  }
  get isLoading() {
    return Boolean(this._loader) && !this._isCancelled;
  }
  get needsReload() {
    return this._needsReload || this._isCancelled;
  }
  get byteLength() {
    const result = this.content ? this.content.byteLength : 0;
    if (!Number.isFinite(result)) {
      console.error("byteLength not defined in tile data");
    }
    return result;
  }
  async _loadData({
    getData,
    requestScheduler,
    onLoad,
    onError
  }) {
    const {
      index,
      id,
      bbox,
      userData,
      zoom
    } = this;
    const loaderId = this._loaderId;
    this._abortController = new AbortController();
    const {
      signal
    } = this._abortController;
    const requestToken = await requestScheduler.scheduleRequest(this, (tile) => {
      return tile.isSelected ? 1 : -1;
    });
    if (!requestToken) {
      this._isCancelled = true;
      return;
    }
    if (this._isCancelled) {
      requestToken.done();
      return;
    }
    let tileData = null;
    let error;
    try {
      tileData = await getData({
        index,
        id,
        bbox,
        userData,
        zoom,
        signal
      });
    } catch (err) {
      error = err || true;
    } finally {
      requestToken.done();
    }
    if (loaderId !== this._loaderId) {
      return;
    }
    this._loader = void 0;
    this.content = tileData;
    if (this._isCancelled && !tileData) {
      this._isLoaded = false;
      return;
    }
    this._isLoaded = true;
    this._isCancelled = false;
    if (error) {
      onError(error, this);
    } else {
      onLoad(this);
    }
  }
  loadData(opts) {
    this._isLoaded = false;
    this._isCancelled = false;
    this._needsReload = false;
    this._loaderId++;
    this._loader = this._loadData(opts);
    return this._loader;
  }
  setNeedsReload() {
    if (this.isLoading) {
      this.abort();
      this._loader = void 0;
    }
    this._needsReload = true;
  }
  abort() {
    var _this$_abortControlle;
    if (this.isLoaded) {
      return;
    }
    this._isCancelled = true;
    (_this$_abortControlle = this._abortController) === null || _this$_abortControlle === void 0 ? void 0 : _this$_abortControlle.abort();
  }
};

// node_modules/@deck.gl/geo-layers/dist/esm/tileset-2d/tile-2d-traversal.js
var TILE_SIZE2 = 512;
var MAX_MAPS = 3;
var REF_POINTS_5 = [[0.5, 0.5], [0, 0], [0, 1], [1, 0], [1, 1]];
var REF_POINTS_9 = REF_POINTS_5.concat([[0, 0.5], [0.5, 0], [1, 0.5], [0.5, 1]]);
var REF_POINTS_11 = REF_POINTS_9.concat([[0.25, 0.5], [0.75, 0.5]]);
var OSMNode = class _OSMNode {
  constructor(x2, y2, z) {
    _defineProperty(this, "x", void 0);
    _defineProperty(this, "y", void 0);
    _defineProperty(this, "z", void 0);
    _defineProperty(this, "childVisible", void 0);
    _defineProperty(this, "selected", void 0);
    _defineProperty(this, "_children", void 0);
    this.x = x2;
    this.y = y2;
    this.z = z;
  }
  get children() {
    if (!this._children) {
      const x2 = this.x * 2;
      const y2 = this.y * 2;
      const z = this.z + 1;
      this._children = [new _OSMNode(x2, y2, z), new _OSMNode(x2, y2 + 1, z), new _OSMNode(x2 + 1, y2, z), new _OSMNode(x2 + 1, y2 + 1, z)];
    }
    return this._children;
  }
  update(params) {
    const {
      viewport,
      cullingVolume,
      elevationBounds,
      minZ,
      maxZ,
      bounds,
      offset,
      project: project2
    } = params;
    const boundingVolume = this.getBoundingVolume(elevationBounds, offset, project2);
    if (bounds && !this.insideBounds(bounds)) {
      return false;
    }
    const isInside = cullingVolume.computeVisibility(boundingVolume);
    if (isInside < 0) {
      return false;
    }
    if (!this.childVisible) {
      let {
        z
      } = this;
      if (z < maxZ && z >= minZ) {
        const distance = boundingVolume.distanceTo(viewport.cameraPosition) * viewport.scale / viewport.height;
        z += Math.floor(Math.log2(distance));
      }
      if (z >= maxZ) {
        this.selected = true;
        return true;
      }
    }
    this.selected = false;
    this.childVisible = true;
    for (const child of this.children) {
      child.update(params);
    }
    return true;
  }
  getSelected(result = []) {
    if (this.selected) {
      result.push(this);
    }
    if (this._children) {
      for (const node of this._children) {
        node.getSelected(result);
      }
    }
    return result;
  }
  insideBounds([minX, minY, maxX, maxY]) {
    const scale = Math.pow(2, this.z);
    const extent = TILE_SIZE2 / scale;
    return this.x * extent < maxX && this.y * extent < maxY && (this.x + 1) * extent > minX && (this.y + 1) * extent > minY;
  }
  getBoundingVolume(zRange, worldOffset, project2) {
    if (project2) {
      const refPoints = this.z < 1 ? REF_POINTS_11 : this.z < 2 ? REF_POINTS_9 : REF_POINTS_5;
      const refPointPositions = [];
      for (const p of refPoints) {
        const lngLat = osmTile2lngLat(this.x + p[0], this.y + p[1], this.z);
        lngLat[2] = zRange[0];
        refPointPositions.push(project2(lngLat));
        if (zRange[0] !== zRange[1]) {
          lngLat[2] = zRange[1];
          refPointPositions.push(project2(lngLat));
        }
      }
      return makeOrientedBoundingBoxFromPoints(refPointPositions);
    }
    const scale = Math.pow(2, this.z);
    const extent = TILE_SIZE2 / scale;
    const originX = this.x * extent + worldOffset * TILE_SIZE2;
    const originY = TILE_SIZE2 - (this.y + 1) * extent;
    return new AxisAlignedBoundingBox([originX, originY, zRange[0]], [originX + extent, originY + extent, zRange[1]]);
  }
};
function getOSMTileIndices(viewport, maxZ, zRange, bounds) {
  const project2 = viewport instanceof GlobeViewport && viewport.resolution ? viewport.projectPosition : null;
  const planes = Object.values(viewport.getFrustumPlanes()).map(({
    normal,
    distance
  }) => new Plane(normal.clone().negate(), distance));
  const cullingVolume = new CullingVolume(planes);
  const unitsPerMeter = viewport.distanceScales.unitsPerMeter[2];
  const elevationMin = zRange && zRange[0] * unitsPerMeter || 0;
  const elevationMax = zRange && zRange[1] * unitsPerMeter || 0;
  const minZ = viewport instanceof WebMercatorViewport && viewport.pitch <= 60 ? maxZ : 0;
  if (bounds) {
    const [minLng, minLat, maxLng, maxLat] = bounds;
    const topLeft = lngLatToWorld([minLng, maxLat]);
    const bottomRight = lngLatToWorld([maxLng, minLat]);
    bounds = [topLeft[0], TILE_SIZE2 - topLeft[1], bottomRight[0], TILE_SIZE2 - bottomRight[1]];
  }
  const root = new OSMNode(0, 0, 0);
  const traversalParams = {
    viewport,
    project: project2,
    cullingVolume,
    elevationBounds: [elevationMin, elevationMax],
    minZ,
    maxZ,
    bounds,
    offset: 0
  };
  root.update(traversalParams);
  if (viewport instanceof WebMercatorViewport && viewport.subViewports && viewport.subViewports.length > 1) {
    traversalParams.offset = -1;
    while (root.update(traversalParams)) {
      if (--traversalParams.offset < -MAX_MAPS) {
        break;
      }
    }
    traversalParams.offset = 1;
    while (root.update(traversalParams)) {
      if (++traversalParams.offset > MAX_MAPS) {
        break;
      }
    }
  }
  return root.getSelected();
}

// node_modules/@deck.gl/geo-layers/dist/esm/tileset-2d/utils.js
var TILE_SIZE3 = 512;
var DEFAULT_EXTENT = [-Infinity, -Infinity, Infinity, Infinity];
var urlType = {
  type: "object",
  value: null,
  validate: (value, propType) => propType.optional && value === null || typeof value === "string" || Array.isArray(value) && value.every((url) => typeof url === "string"),
  equal: (value1, value2) => {
    if (value1 === value2) {
      return true;
    }
    if (!Array.isArray(value1) || !Array.isArray(value2)) {
      return false;
    }
    const len = value1.length;
    if (len !== value2.length) {
      return false;
    }
    for (let i2 = 0; i2 < len; i2++) {
      if (value1[i2] !== value2[i2]) {
        return false;
      }
    }
    return true;
  }
};
function transformBox(bbox, modelMatrix2) {
  const transformedCoords = [modelMatrix2.transformAsPoint([bbox[0], bbox[1]]), modelMatrix2.transformAsPoint([bbox[2], bbox[1]]), modelMatrix2.transformAsPoint([bbox[0], bbox[3]]), modelMatrix2.transformAsPoint([bbox[2], bbox[3]])];
  const transformedBox = [Math.min(...transformedCoords.map((i2) => i2[0])), Math.min(...transformedCoords.map((i2) => i2[1])), Math.max(...transformedCoords.map((i2) => i2[0])), Math.max(...transformedCoords.map((i2) => i2[1]))];
  return transformedBox;
}
function stringHash(s) {
  return Math.abs(s.split("").reduce((a, b) => (a << 5) - a + b.charCodeAt(0) | 0, 0));
}
function getURLFromTemplate(template, tile) {
  if (!template || !template.length) {
    return null;
  }
  const {
    index,
    id
  } = tile;
  if (Array.isArray(template)) {
    const i2 = stringHash(id) % template.length;
    template = template[i2];
  }
  let url = template;
  for (const key of Object.keys(index)) {
    const regex = new RegExp("{".concat(key, "}"), "g");
    url = url.replace(regex, String(index[key]));
  }
  if (Number.isInteger(index.y) && Number.isInteger(index.z)) {
    url = url.replace(/\{-y\}/g, String(Math.pow(2, index.z) - index.y - 1));
  }
  return url;
}
function getBoundingBox(viewport, zRange, extent) {
  let bounds;
  if (zRange && zRange.length === 2) {
    const [minZ, maxZ] = zRange;
    const bounds0 = viewport.getBounds({
      z: minZ
    });
    const bounds1 = viewport.getBounds({
      z: maxZ
    });
    bounds = [Math.min(bounds0[0], bounds1[0]), Math.min(bounds0[1], bounds1[1]), Math.max(bounds0[2], bounds1[2]), Math.max(bounds0[3], bounds1[3])];
  } else {
    bounds = viewport.getBounds();
  }
  if (!viewport.isGeospatial) {
    return [Math.max(Math.min(bounds[0], extent[2]), extent[0]), Math.max(Math.min(bounds[1], extent[3]), extent[1]), Math.min(Math.max(bounds[2], extent[0]), extent[2]), Math.min(Math.max(bounds[3], extent[1]), extent[3])];
  }
  return [Math.max(bounds[0], extent[0]), Math.max(bounds[1], extent[1]), Math.min(bounds[2], extent[2]), Math.min(bounds[3], extent[3])];
}
function getCullBounds({
  viewport,
  z = 0,
  cullRect
}) {
  const subViewports = viewport.subViewports || [viewport];
  return subViewports.map((v) => getCullBoundsInViewport(v, z, cullRect));
}
function getCullBoundsInViewport(viewport, z, cullRect) {
  if (!Array.isArray(z)) {
    const x2 = cullRect.x - viewport.x;
    const y2 = cullRect.y - viewport.y;
    const {
      width,
      height
    } = cullRect;
    const unprojectOption = {
      targetZ: z
    };
    const topLeft = viewport.unproject([x2, y2], unprojectOption);
    const topRight = viewport.unproject([x2 + width, y2], unprojectOption);
    const bottomLeft = viewport.unproject([x2, y2 + height], unprojectOption);
    const bottomRight = viewport.unproject([x2 + width, y2 + height], unprojectOption);
    return [Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]), Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])];
  }
  const bounds0 = getCullBoundsInViewport(viewport, z[0], cullRect);
  const bounds1 = getCullBoundsInViewport(viewport, z[1], cullRect);
  return [Math.min(bounds0[0], bounds1[0]), Math.min(bounds0[1], bounds1[1]), Math.max(bounds0[2], bounds1[2]), Math.max(bounds0[3], bounds1[3])];
}
function getIndexingCoords(bbox, scale, modelMatrixInverse) {
  if (modelMatrixInverse) {
    const transformedTileIndex = transformBox(bbox, modelMatrixInverse).map((i2) => i2 * scale / TILE_SIZE3);
    return transformedTileIndex;
  }
  return bbox.map((i2) => i2 * scale / TILE_SIZE3);
}
function getScale(z, tileSize) {
  return Math.pow(2, z) * TILE_SIZE3 / tileSize;
}
function osmTile2lngLat(x2, y2, z) {
  const scale = getScale(z, TILE_SIZE3);
  const lng = x2 / scale * 360 - 180;
  const n = Math.PI - 2 * Math.PI * y2 / scale;
  const lat = 180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
  return [lng, lat];
}
function tile2XY(x2, y2, z, tileSize) {
  const scale = getScale(z, tileSize);
  return [x2 / scale * TILE_SIZE3, y2 / scale * TILE_SIZE3];
}
function tileToBoundingBox(viewport, x2, y2, z, tileSize = TILE_SIZE3) {
  if (viewport.isGeospatial) {
    const [west, north] = osmTile2lngLat(x2, y2, z);
    const [east, south] = osmTile2lngLat(x2 + 1, y2 + 1, z);
    return {
      west,
      north,
      east,
      south
    };
  }
  const [left, top] = tile2XY(x2, y2, z, tileSize);
  const [right, bottom] = tile2XY(x2 + 1, y2 + 1, z, tileSize);
  return {
    left,
    top,
    right,
    bottom
  };
}
function getIdentityTileIndices(viewport, z, tileSize, extent, modelMatrixInverse) {
  const bbox = getBoundingBox(viewport, null, extent);
  const scale = getScale(z, tileSize);
  const [minX, minY, maxX, maxY] = getIndexingCoords(bbox, scale, modelMatrixInverse);
  const indices = [];
  for (let x2 = Math.floor(minX); x2 < maxX; x2++) {
    for (let y2 = Math.floor(minY); y2 < maxY; y2++) {
      indices.push({
        x: x2,
        y: y2,
        z
      });
    }
  }
  return indices;
}
function getTileIndices({
  viewport,
  maxZoom,
  minZoom,
  zRange,
  extent,
  tileSize = TILE_SIZE3,
  modelMatrix: modelMatrix2,
  modelMatrixInverse,
  zoomOffset = 0
}) {
  let z = viewport.isGeospatial ? Math.round(viewport.zoom + Math.log2(TILE_SIZE3 / tileSize)) + zoomOffset : Math.ceil(viewport.zoom) + zoomOffset;
  if (typeof minZoom === "number" && Number.isFinite(minZoom) && z < minZoom) {
    if (!extent) {
      return [];
    }
    z = minZoom;
  }
  if (typeof maxZoom === "number" && Number.isFinite(maxZoom) && z > maxZoom) {
    z = maxZoom;
  }
  let transformedExtent = extent;
  if (modelMatrix2 && modelMatrixInverse && extent && !viewport.isGeospatial) {
    transformedExtent = transformBox(extent, modelMatrix2);
  }
  return viewport.isGeospatial ? getOSMTileIndices(viewport, z, zRange, extent) : getIdentityTileIndices(viewport, z, tileSize, transformedExtent || DEFAULT_EXTENT, modelMatrixInverse);
}
function isURLTemplate(s) {
  return /(?=.*{z})(?=.*{x})(?=.*({y}|{-y}))/.test(s);
}
function isGeoBoundingBox(v) {
  return Number.isFinite(v.west) && Number.isFinite(v.north) && Number.isFinite(v.east) && Number.isFinite(v.south);
}

// node_modules/@deck.gl/geo-layers/dist/esm/tileset-2d/memoize.js
function memoize2(compute) {
  let cachedArgs = {};
  let cachedResult;
  return (args) => {
    for (const key in args) {
      if (!isEqual(args[key], cachedArgs[key])) {
        cachedResult = compute(args);
        cachedArgs = args;
        break;
      }
    }
    return cachedResult;
  };
}
function isEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (Array.isArray(a)) {
    const len = a.length;
    if (!b || b.length !== len) {
      return false;
    }
    for (let i2 = 0; i2 < len; i2++) {
      if (a[i2] !== b[i2]) {
        return false;
      }
    }
    return true;
  }
  return false;
}

// node_modules/@deck.gl/geo-layers/dist/esm/tileset-2d/tileset-2d.js
var TILE_STATE_VISITED = 1;
var TILE_STATE_VISIBLE = 2;
var STRATEGY_NEVER = "never";
var STRATEGY_REPLACE = "no-overlap";
var STRATEGY_DEFAULT = "best-available";
var DEFAULT_CACHE_SCALE = 5;
var STRATEGIES = {
  [STRATEGY_DEFAULT]: updateTileStateDefault,
  [STRATEGY_REPLACE]: updateTileStateReplace,
  [STRATEGY_NEVER]: () => {
  }
};
var DEFAULT_TILESET2D_PROPS = {
  extent: null,
  tileSize: 512,
  maxZoom: null,
  minZoom: null,
  maxCacheSize: null,
  maxCacheByteSize: null,
  refinementStrategy: "best-available",
  zRange: null,
  maxRequests: 6,
  zoomOffset: 0,
  onTileLoad: () => {
  },
  onTileUnload: () => {
  },
  onTileError: () => {
  }
};
var Tileset2D = class {
  constructor(opts) {
    _defineProperty(this, "opts", void 0);
    _defineProperty(this, "_requestScheduler", void 0);
    _defineProperty(this, "_cache", void 0);
    _defineProperty(this, "_dirty", void 0);
    _defineProperty(this, "_tiles", void 0);
    _defineProperty(this, "_cacheByteSize", void 0);
    _defineProperty(this, "_viewport", void 0);
    _defineProperty(this, "_zRange", void 0);
    _defineProperty(this, "_selectedTiles", void 0);
    _defineProperty(this, "_frameNumber", void 0);
    _defineProperty(this, "_modelMatrix", void 0);
    _defineProperty(this, "_modelMatrixInverse", void 0);
    _defineProperty(this, "_maxZoom", void 0);
    _defineProperty(this, "_minZoom", void 0);
    _defineProperty(this, "onTileLoad", void 0);
    _defineProperty(this, "_getCullBounds", memoize2(getCullBounds));
    this.opts = {
      ...DEFAULT_TILESET2D_PROPS,
      ...opts
    };
    this.onTileLoad = (tile) => {
      var _this$opts$onTileLoad, _this$opts;
      (_this$opts$onTileLoad = (_this$opts = this.opts).onTileLoad) === null || _this$opts$onTileLoad === void 0 ? void 0 : _this$opts$onTileLoad.call(_this$opts, tile);
      if (this.opts.maxCacheByteSize) {
        this._cacheByteSize += tile.byteLength;
        this._resizeCache();
      }
    };
    this._requestScheduler = new RequestScheduler({
      maxRequests: opts.maxRequests,
      throttleRequests: Boolean(opts.maxRequests && opts.maxRequests > 0)
    });
    this._cache = /* @__PURE__ */ new Map();
    this._tiles = [];
    this._dirty = false;
    this._cacheByteSize = 0;
    this._viewport = null;
    this._selectedTiles = null;
    this._frameNumber = 0;
    this._modelMatrix = new Matrix4();
    this._modelMatrixInverse = new Matrix4();
    this.setOptions(opts);
  }
  get tiles() {
    return this._tiles;
  }
  get selectedTiles() {
    return this._selectedTiles;
  }
  get isLoaded() {
    return this._selectedTiles !== null && this._selectedTiles.every((tile) => tile.isLoaded);
  }
  get needsReload() {
    return this._selectedTiles !== null && this._selectedTiles.some((tile) => tile.needsReload);
  }
  setOptions(opts) {
    Object.assign(this.opts, opts);
    if (Number.isFinite(opts.maxZoom)) {
      this._maxZoom = Math.floor(opts.maxZoom);
    }
    if (Number.isFinite(opts.minZoom)) {
      this._minZoom = Math.ceil(opts.minZoom);
    }
  }
  finalize() {
    for (const tile of this._cache.values()) {
      if (tile.isLoading) {
        tile.abort();
      }
    }
    this._cache.clear();
    this._tiles = [];
    this._selectedTiles = null;
  }
  reloadAll() {
    for (const id of this._cache.keys()) {
      const tile = this._cache.get(id);
      if (!this._selectedTiles || !this._selectedTiles.includes(tile)) {
        this._cache.delete(id);
      } else {
        tile.setNeedsReload();
      }
    }
  }
  update(viewport, {
    zRange,
    modelMatrix: modelMatrix2
  } = {}) {
    const modelMatrixAsMatrix4 = new Matrix4(modelMatrix2);
    const isModelMatrixNew = !modelMatrixAsMatrix4.equals(this._modelMatrix);
    if (!this._viewport || !viewport.equals(this._viewport) || !equals(this._zRange, zRange) || isModelMatrixNew) {
      if (isModelMatrixNew) {
        this._modelMatrixInverse = modelMatrixAsMatrix4.clone().invert();
        this._modelMatrix = modelMatrixAsMatrix4;
      }
      this._viewport = viewport;
      this._zRange = zRange;
      const tileIndices = this.getTileIndices({
        viewport,
        maxZoom: this._maxZoom,
        minZoom: this._minZoom,
        zRange,
        modelMatrix: this._modelMatrix,
        modelMatrixInverse: this._modelMatrixInverse
      });
      this._selectedTiles = tileIndices.map((index) => this._getTile(index, true));
      if (this._dirty) {
        this._rebuildTree();
      }
    } else if (this.needsReload) {
      this._selectedTiles = this._selectedTiles.map((tile) => this._getTile(tile.index, true));
    }
    const changed = this.updateTileStates();
    this._pruneRequests();
    if (this._dirty) {
      this._resizeCache();
    }
    if (changed) {
      this._frameNumber++;
    }
    return this._frameNumber;
  }
  isTileVisible(tile, cullRect) {
    if (!tile.isVisible) {
      return false;
    }
    if (cullRect && this._viewport) {
      const boundsArr = this._getCullBounds({
        viewport: this._viewport,
        z: this._zRange,
        cullRect
      });
      const {
        bbox
      } = tile;
      for (const [minX, minY, maxX, maxY] of boundsArr) {
        let overlaps;
        if ("west" in bbox) {
          overlaps = bbox.west < maxX && bbox.east > minX && bbox.south < maxY && bbox.north > minY;
        } else {
          const y0 = Math.min(bbox.top, bbox.bottom);
          const y1 = Math.max(bbox.top, bbox.bottom);
          overlaps = bbox.left < maxX && bbox.right > minX && y0 < maxY && y1 > minY;
        }
        if (overlaps) {
          return true;
        }
      }
      return false;
    }
    return true;
  }
  getTileIndices({
    viewport,
    maxZoom,
    minZoom,
    zRange,
    modelMatrix: modelMatrix2,
    modelMatrixInverse
  }) {
    const {
      tileSize,
      extent,
      zoomOffset
    } = this.opts;
    return getTileIndices({
      viewport,
      maxZoom,
      minZoom,
      zRange,
      tileSize,
      extent,
      modelMatrix: modelMatrix2,
      modelMatrixInverse,
      zoomOffset
    });
  }
  getTileId(index) {
    return "".concat(index.x, "-").concat(index.y, "-").concat(index.z);
  }
  getTileZoom(index) {
    return index.z;
  }
  getTileMetadata(index) {
    const {
      tileSize
    } = this.opts;
    return {
      bbox: tileToBoundingBox(this._viewport, index.x, index.y, index.z, tileSize)
    };
  }
  getParentIndex(index) {
    const x2 = Math.floor(index.x / 2);
    const y2 = Math.floor(index.y / 2);
    const z = index.z - 1;
    return {
      x: x2,
      y: y2,
      z
    };
  }
  updateTileStates() {
    const refinementStrategy = this.opts.refinementStrategy || STRATEGY_DEFAULT;
    const visibilities = new Array(this._cache.size);
    let i2 = 0;
    for (const tile of this._cache.values()) {
      visibilities[i2++] = tile.isVisible;
      tile.isSelected = false;
      tile.isVisible = false;
    }
    for (const tile of this._selectedTiles) {
      tile.isSelected = true;
      tile.isVisible = true;
    }
    (typeof refinementStrategy === "function" ? refinementStrategy : STRATEGIES[refinementStrategy])(Array.from(this._cache.values()));
    i2 = 0;
    for (const tile of this._cache.values()) {
      if (visibilities[i2++] !== tile.isVisible) {
        return true;
      }
    }
    return false;
  }
  _pruneRequests() {
    const {
      maxRequests = 0
    } = this.opts;
    const abortCandidates = [];
    let ongoingRequestCount = 0;
    for (const tile of this._cache.values()) {
      if (tile.isLoading) {
        ongoingRequestCount++;
        if (!tile.isSelected && !tile.isVisible) {
          abortCandidates.push(tile);
        }
      }
    }
    while (maxRequests > 0 && ongoingRequestCount > maxRequests && abortCandidates.length > 0) {
      const tile = abortCandidates.shift();
      tile.abort();
      ongoingRequestCount--;
    }
  }
  _rebuildTree() {
    const {
      _cache
    } = this;
    for (const tile of _cache.values()) {
      tile.parent = null;
      if (tile.children) {
        tile.children.length = 0;
      }
    }
    for (const tile of _cache.values()) {
      const parent = this._getNearestAncestor(tile);
      tile.parent = parent;
      if (parent !== null && parent !== void 0 && parent.children) {
        parent.children.push(tile);
      }
    }
  }
  _resizeCache() {
    const {
      _cache,
      opts
    } = this;
    const maxCacheSize = opts.maxCacheSize || (opts.maxCacheByteSize ? Infinity : DEFAULT_CACHE_SCALE * this.selectedTiles.length);
    const maxCacheByteSize = opts.maxCacheByteSize || Infinity;
    const overflown = _cache.size > maxCacheSize || this._cacheByteSize > maxCacheByteSize;
    if (overflown) {
      for (const [id, tile] of _cache) {
        if (!tile.isVisible && !tile.isSelected) {
          var _this$opts$onTileUnlo, _this$opts2;
          this._cacheByteSize -= opts.maxCacheByteSize ? tile.byteLength : 0;
          _cache.delete(id);
          (_this$opts$onTileUnlo = (_this$opts2 = this.opts).onTileUnload) === null || _this$opts$onTileUnlo === void 0 ? void 0 : _this$opts$onTileUnlo.call(_this$opts2, tile);
        }
        if (_cache.size <= maxCacheSize && this._cacheByteSize <= maxCacheByteSize) {
          break;
        }
      }
      this._rebuildTree();
      this._dirty = true;
    }
    if (this._dirty) {
      this._tiles = Array.from(this._cache.values()).sort((t1, t2) => t1.zoom - t2.zoom);
      this._dirty = false;
    }
  }
  _getTile(index, create) {
    const id = this.getTileId(index);
    let tile = this._cache.get(id);
    let needsReload = false;
    if (!tile && create) {
      tile = new Tile2DHeader(index);
      Object.assign(tile, this.getTileMetadata(tile.index));
      Object.assign(tile, {
        id,
        zoom: this.getTileZoom(tile.index)
      });
      needsReload = true;
      this._cache.set(id, tile);
      this._dirty = true;
    } else if (tile && tile.needsReload) {
      needsReload = true;
    }
    if (tile && needsReload) {
      tile.loadData({
        getData: this.opts.getTileData,
        requestScheduler: this._requestScheduler,
        onLoad: this.onTileLoad,
        onError: this.opts.onTileError
      });
    }
    return tile;
  }
  _getNearestAncestor(tile) {
    const {
      _minZoom = 0
    } = this;
    let index = tile.index;
    while (this.getTileZoom(index) > _minZoom) {
      index = this.getParentIndex(index);
      const parent = this._getTile(index);
      if (parent) {
        return parent;
      }
    }
    return null;
  }
};
function updateTileStateDefault(allTiles) {
  for (const tile of allTiles) {
    tile.state = 0;
  }
  for (const tile of allTiles) {
    if (tile.isSelected && !getPlaceholderInAncestors(tile)) {
      getPlaceholderInChildren(tile);
    }
  }
  for (const tile of allTiles) {
    tile.isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);
  }
}
function updateTileStateReplace(allTiles) {
  for (const tile of allTiles) {
    tile.state = 0;
  }
  for (const tile of allTiles) {
    if (tile.isSelected) {
      getPlaceholderInAncestors(tile);
    }
  }
  const sortedTiles = Array.from(allTiles).sort((t1, t2) => t1.zoom - t2.zoom);
  for (const tile of sortedTiles) {
    tile.isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);
    if (tile.children && (tile.isVisible || tile.state & TILE_STATE_VISITED)) {
      for (const child of tile.children) {
        child.state = TILE_STATE_VISITED;
      }
    } else if (tile.isSelected) {
      getPlaceholderInChildren(tile);
    }
  }
}
function getPlaceholderInAncestors(startTile) {
  let tile = startTile;
  while (tile) {
    if (tile.isLoaded || tile.content) {
      tile.state |= TILE_STATE_VISIBLE;
      return true;
    }
    tile = tile.parent;
  }
  return false;
}
function getPlaceholderInChildren(tile) {
  for (const child of tile.children) {
    if (child.isLoaded || child.content) {
      child.state |= TILE_STATE_VISIBLE;
    } else {
      getPlaceholderInChildren(child);
    }
  }
}

// node_modules/@deck.gl/geo-layers/dist/esm/tile-layer/tile-layer.js
var defaultProps6 = {
  TilesetClass: Tileset2D,
  data: {
    type: "data",
    value: []
  },
  dataComparator: urlType.equal,
  renderSubLayers: {
    type: "function",
    value: (props) => new GeoJsonLayer(props)
  },
  getTileData: {
    type: "function",
    optional: true,
    value: null
  },
  onViewportLoad: {
    type: "function",
    optional: true,
    value: null
  },
  onTileLoad: {
    type: "function",
    value: (tile) => {
    }
  },
  onTileUnload: {
    type: "function",
    value: (tile) => {
    }
  },
  onTileError: {
    type: "function",
    value: (err) => console.error(err)
  },
  extent: {
    type: "array",
    optional: true,
    value: null,
    compare: true
  },
  tileSize: 512,
  maxZoom: null,
  minZoom: 0,
  maxCacheSize: null,
  maxCacheByteSize: null,
  refinementStrategy: STRATEGY_DEFAULT,
  zRange: null,
  maxRequests: 6,
  zoomOffset: 0
};
var TileLayer = class extends CompositeLayer {
  initializeState() {
    this.state = {
      tileset: null,
      isLoaded: false
    };
  }
  finalizeState() {
    var _this$state, _this$state$tileset;
    (_this$state = this.state) === null || _this$state === void 0 ? void 0 : (_this$state$tileset = _this$state.tileset) === null || _this$state$tileset === void 0 ? void 0 : _this$state$tileset.finalize();
  }
  get isLoaded() {
    var _this$state2, _this$state2$tileset;
    return (_this$state2 = this.state) === null || _this$state2 === void 0 ? void 0 : (_this$state2$tileset = _this$state2.tileset) === null || _this$state2$tileset === void 0 ? void 0 : _this$state2$tileset.selectedTiles.every((tile) => tile.isLoaded && tile.layers && tile.layers.every((layer) => layer.isLoaded));
  }
  shouldUpdateState({
    changeFlags
  }) {
    return changeFlags.somethingChanged;
  }
  updateState({
    changeFlags
  }) {
    let {
      tileset
    } = this.state;
    const propsChanged = changeFlags.propsOrDataChanged || changeFlags.updateTriggersChanged;
    const dataChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getTileData);
    if (!tileset) {
      tileset = new this.props.TilesetClass(this._getTilesetOptions());
      this.setState({
        tileset
      });
    } else if (propsChanged) {
      tileset.setOptions(this._getTilesetOptions());
      if (dataChanged) {
        tileset.reloadAll();
      } else {
        this.state.tileset.tiles.forEach((tile) => {
          tile.layers = null;
        });
      }
    }
    this._updateTileset();
  }
  _getTilesetOptions() {
    const {
      tileSize,
      maxCacheSize,
      maxCacheByteSize,
      refinementStrategy,
      extent,
      maxZoom,
      minZoom,
      maxRequests,
      zoomOffset
    } = this.props;
    return {
      maxCacheSize,
      maxCacheByteSize,
      maxZoom,
      minZoom,
      tileSize,
      refinementStrategy,
      extent,
      maxRequests,
      zoomOffset,
      getTileData: this.getTileData.bind(this),
      onTileLoad: this._onTileLoad.bind(this),
      onTileError: this._onTileError.bind(this),
      onTileUnload: this._onTileUnload.bind(this)
    };
  }
  _updateTileset() {
    const {
      tileset
    } = this.state;
    const {
      zRange,
      modelMatrix: modelMatrix2
    } = this.props;
    const frameNumber = tileset.update(this.context.viewport, {
      zRange,
      modelMatrix: modelMatrix2
    });
    const {
      isLoaded
    } = tileset;
    const loadingStateChanged = this.state.isLoaded !== isLoaded;
    const tilesetChanged = this.state.frameNumber !== frameNumber;
    if (isLoaded && (loadingStateChanged || tilesetChanged)) {
      this._onViewportLoad();
    }
    if (tilesetChanged) {
      this.setState({
        frameNumber
      });
    }
    this.state.isLoaded = isLoaded;
  }
  _onViewportLoad() {
    const {
      tileset
    } = this.state;
    const {
      onViewportLoad
    } = this.props;
    if (onViewportLoad) {
      onViewportLoad(tileset.selectedTiles);
    }
  }
  _onTileLoad(tile) {
    this.props.onTileLoad(tile);
    tile.layers = null;
    this.setNeedsUpdate();
  }
  _onTileError(error, tile) {
    this.props.onTileError(error);
    tile.layers = null;
    this.setNeedsUpdate();
  }
  _onTileUnload(tile) {
    this.props.onTileUnload(tile);
  }
  getTileData(tile) {
    const {
      data,
      getTileData,
      fetch: fetch2
    } = this.props;
    const {
      signal
    } = tile;
    tile.url = typeof data === "string" || Array.isArray(data) ? getURLFromTemplate(data, tile) : null;
    if (getTileData) {
      return getTileData(tile);
    }
    if (fetch2 && tile.url) {
      return fetch2(tile.url, {
        propName: "data",
        layer: this,
        signal
      });
    }
    return null;
  }
  renderSubLayers(props) {
    return this.props.renderSubLayers(props);
  }
  getSubLayerPropsByTile(tile) {
    return null;
  }
  getPickingInfo({
    info,
    sourceLayer
  }) {
    const sourceTile = sourceLayer.props.tile;
    if (info.picked) {
      info.tile = sourceTile;
    }
    info.sourceTile = sourceTile;
    return info;
  }
  _updateAutoHighlight(info) {
    const sourceTile = info.sourceTile;
    if (sourceTile && sourceTile.layers) {
      for (const layer of sourceTile.layers) {
        layer.updateAutoHighlight(info);
      }
    }
  }
  renderLayers() {
    return this.state.tileset.tiles.map((tile) => {
      const subLayerProps = this.getSubLayerPropsByTile(tile);
      if (!tile.isLoaded && !tile.content) {
      } else if (!tile.layers) {
        const layers = this.renderSubLayers({
          ...this.props,
          ...this.getSubLayerProps({
            id: tile.id,
            updateTriggers: this.props.updateTriggers
          }),
          data: tile.content,
          _offset: 0,
          tile
        });
        tile.layers = flatten(layers, Boolean).map((layer) => layer.clone({
          tile,
          ...subLayerProps
        }));
      } else if (subLayerProps && tile.layers[0] && Object.keys(subLayerProps).some((propName) => tile.layers[0].props[propName] !== subLayerProps[propName])) {
        tile.layers = tile.layers.map((layer) => layer.clone(subLayerProps));
      }
      return tile.layers;
    });
  }
  filterSubLayer({
    layer,
    cullRect
  }) {
    const {
      tile
    } = layer.props;
    return this.state.tileset.isTileVisible(tile, cullRect);
  }
};
_defineProperty(TileLayer, "defaultProps", defaultProps6);
_defineProperty(TileLayer, "layerName", "TileLayer");

// node_modules/@deck.gl/geo-layers/dist/esm/trips-layer/trips-layer.js
var defaultProps7 = {
  fadeTrail: true,
  trailLength: {
    type: "number",
    value: 120,
    min: 0
  },
  currentTime: {
    type: "number",
    value: 0,
    min: 0
  },
  getTimestamps: {
    type: "accessor",
    value: (d) => d.timestamps
  }
};
var TripsLayer = class extends PathLayer {
  getShaders() {
    const shaders = super.getShaders();
    shaders.inject = {
      "vs:#decl": "uniform float trailLength;\nattribute float instanceTimestamps;\nattribute float instanceNextTimestamps;\nvarying float vTime;\n",
      "vs:#main-end": "vTime = instanceTimestamps + (instanceNextTimestamps - instanceTimestamps) * vPathPosition.y / vPathLength;\n",
      "fs:#decl": "uniform bool fadeTrail;\nuniform float trailLength;\nuniform float currentTime;\nvarying float vTime;\n",
      "fs:#main-start": "if(vTime > currentTime || (fadeTrail && (vTime < currentTime - trailLength))) {\n  discard;\n}\n",
      "fs:DECKGL_FILTER_COLOR": "if(fadeTrail) {\n  color.a *= 1.0 - (currentTime - vTime) / trailLength;\n}\n"
    };
    return shaders;
  }
  initializeState() {
    super.initializeState();
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      timestamps: {
        size: 1,
        accessor: "getTimestamps",
        shaderAttributes: {
          instanceTimestamps: {
            vertexOffset: 0
          },
          instanceNextTimestamps: {
            vertexOffset: 1
          }
        }
      }
    });
  }
  draw(params) {
    const {
      fadeTrail,
      trailLength,
      currentTime
    } = this.props;
    params.uniforms = {
      ...params.uniforms,
      fadeTrail,
      trailLength,
      currentTime
    };
    super.draw(params);
  }
};
_defineProperty(TripsLayer, "layerName", "TripsLayer");
_defineProperty(TripsLayer, "defaultProps", defaultProps7);

// node_modules/h3-js/dist/browser/h3-js.es.js
var libh3 = function(libh32) {
  libh32 = libh32 || {};
  var Module = typeof libh32 !== "undefined" ? libh32 : {};
  var moduleOverrides = {};
  var key;
  for (key in Module) {
    if (Module.hasOwnProperty(key)) {
      moduleOverrides[key] = Module[key];
    }
  }
  var arguments_ = [];
  var scriptDirectory = "";
  function locateFile(path) {
    if (Module["locateFile"]) {
      return Module["locateFile"](path, scriptDirectory);
    }
    return scriptDirectory + path;
  }
  var readAsync;
  {
    if (document.currentScript) {
      scriptDirectory = document.currentScript.src;
    }
    if (scriptDirectory.indexOf("blob:") !== 0) {
      scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf("/") + 1);
    } else {
      scriptDirectory = "";
    }
    readAsync = function readAsync2(url, onload, onerror) {
      var xhr = new XMLHttpRequest();
      xhr.open("GET", url, true);
      xhr.responseType = "arraybuffer";
      xhr.onload = function xhr_onload() {
        if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
          onload(xhr.response);
          return;
        }
        var data = tryParseAsDataURI(url);
        if (data) {
          onload(data.buffer);
          return;
        }
        onerror();
      };
      xhr.onerror = onerror;
      xhr.send(null);
    };
  }
  var out = Module["print"] || console.log.bind(console);
  var err = Module["printErr"] || console.warn.bind(console);
  for (key in moduleOverrides) {
    if (moduleOverrides.hasOwnProperty(key)) {
      Module[key] = moduleOverrides[key];
    }
  }
  moduleOverrides = null;
  if (Module["arguments"]) {
    arguments_ = Module["arguments"];
  }
  var tempRet0 = 0;
  var setTempRet0 = function(value) {
    tempRet0 = value;
  };
  var getTempRet0 = function() {
    return tempRet0;
  };
  var GLOBAL_BASE = 8;
  function setValue(ptr, value, type, noSafe) {
    type = type || "i8";
    if (type.charAt(type.length - 1) === "*") {
      type = "i32";
    }
    switch (type) {
      case "i1":
        HEAP8[ptr >> 0] = value;
        break;
      case "i8":
        HEAP8[ptr >> 0] = value;
        break;
      case "i16":
        HEAP16[ptr >> 1] = value;
        break;
      case "i32":
        HEAP32[ptr >> 2] = value;
        break;
      case "i64":
        tempI64 = [value >>> 0, (tempDouble = value, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1];
        break;
      case "float":
        HEAPF32[ptr >> 2] = value;
        break;
      case "double":
        HEAPF64[ptr >> 3] = value;
        break;
      default:
        abort("invalid type for setValue: " + type);
    }
  }
  function getValue(ptr, type, noSafe) {
    type = type || "i8";
    if (type.charAt(type.length - 1) === "*") {
      type = "i32";
    }
    switch (type) {
      case "i1":
        return HEAP8[ptr >> 0];
      case "i8":
        return HEAP8[ptr >> 0];
      case "i16":
        return HEAP16[ptr >> 1];
      case "i32":
        return HEAP32[ptr >> 2];
      case "i64":
        return HEAP32[ptr >> 2];
      case "float":
        return HEAPF32[ptr >> 2];
      case "double":
        return HEAPF64[ptr >> 3];
      default:
        abort("invalid type for getValue: " + type);
    }
    return null;
  }
  var ABORT = false;
  function assert2(condition, text) {
    if (!condition) {
      abort("Assertion failed: " + text);
    }
  }
  function getCFunc(ident) {
    var func = Module["_" + ident];
    assert2(func, "Cannot call unknown function " + ident + ", make sure it is exported");
    return func;
  }
  function ccall(ident, returnType, argTypes, args, opts) {
    var toC = {
      "string": function(str) {
        var ret2 = 0;
        if (str !== null && str !== void 0 && str !== 0) {
          var len = (str.length << 2) + 1;
          ret2 = stackAlloc(len);
          stringToUTF8(str, ret2, len);
        }
        return ret2;
      },
      "array": function(arr) {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      }
    };
    function convertReturnValue(ret2) {
      if (returnType === "string") {
        return UTF8ToString(ret2);
      }
      if (returnType === "boolean") {
        return Boolean(ret2);
      }
      return ret2;
    }
    var func = getCFunc(ident);
    var cArgs = [];
    var stack = 0;
    if (args) {
      for (var i2 = 0; i2 < args.length; i2++) {
        var converter = toC[argTypes[i2]];
        if (converter) {
          if (stack === 0) {
            stack = stackSave();
          }
          cArgs[i2] = converter(args[i2]);
        } else {
          cArgs[i2] = args[i2];
        }
      }
    }
    var ret = func.apply(null, cArgs);
    ret = convertReturnValue(ret);
    if (stack !== 0) {
      stackRestore(stack);
    }
    return ret;
  }
  function cwrap(ident, returnType, argTypes, opts) {
    argTypes = argTypes || [];
    var numericArgs = argTypes.every(function(type) {
      return type === "number";
    });
    var numericRet = returnType !== "string";
    if (numericRet && numericArgs && !opts) {
      return getCFunc(ident);
    }
    return function() {
      return ccall(ident, returnType, argTypes, arguments, opts);
    };
  }
  var UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : void 0;
  function UTF8ArrayToString(u8Array, idx, maxBytesToRead) {
    var endIdx = idx + maxBytesToRead;
    var endPtr = idx;
    while (u8Array[endPtr] && !(endPtr >= endIdx)) {
      ++endPtr;
    }
    if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {
      return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));
    } else {
      var str = "";
      while (idx < endPtr) {
        var u0 = u8Array[idx++];
        if (!(u0 & 128)) {
          str += String.fromCharCode(u0);
          continue;
        }
        var u1 = u8Array[idx++] & 63;
        if ((u0 & 224) == 192) {
          str += String.fromCharCode((u0 & 31) << 6 | u1);
          continue;
        }
        var u2 = u8Array[idx++] & 63;
        if ((u0 & 240) == 224) {
          u0 = (u0 & 15) << 12 | u1 << 6 | u2;
        } else {
          u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | u8Array[idx++] & 63;
        }
        if (u0 < 65536) {
          str += String.fromCharCode(u0);
        } else {
          var ch = u0 - 65536;
          str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
        }
      }
    }
    return str;
  }
  function UTF8ToString(ptr, maxBytesToRead) {
    return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
  }
  function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {
    if (!(maxBytesToWrite > 0)) {
      return 0;
    }
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1;
    for (var i2 = 0; i2 < str.length; ++i2) {
      var u = str.charCodeAt(i2);
      if (u >= 55296 && u <= 57343) {
        var u1 = str.charCodeAt(++i2);
        u = 65536 + ((u & 1023) << 10) | u1 & 1023;
      }
      if (u <= 127) {
        if (outIdx >= endIdx) {
          break;
        }
        outU8Array[outIdx++] = u;
      } else if (u <= 2047) {
        if (outIdx + 1 >= endIdx) {
          break;
        }
        outU8Array[outIdx++] = 192 | u >> 6;
        outU8Array[outIdx++] = 128 | u & 63;
      } else if (u <= 65535) {
        if (outIdx + 2 >= endIdx) {
          break;
        }
        outU8Array[outIdx++] = 224 | u >> 12;
        outU8Array[outIdx++] = 128 | u >> 6 & 63;
        outU8Array[outIdx++] = 128 | u & 63;
      } else {
        if (outIdx + 3 >= endIdx) {
          break;
        }
        outU8Array[outIdx++] = 240 | u >> 18;
        outU8Array[outIdx++] = 128 | u >> 12 & 63;
        outU8Array[outIdx++] = 128 | u >> 6 & 63;
        outU8Array[outIdx++] = 128 | u & 63;
      }
    }
    outU8Array[outIdx] = 0;
    return outIdx - startIdx;
  }
  function stringToUTF8(str, outPtr, maxBytesToWrite) {
    return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
  }
  var UTF16Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-16le") : void 0;
  function writeArrayToMemory(array, buffer2) {
    HEAP8.set(array, buffer2);
  }
  function alignUp(x2, multiple) {
    if (x2 % multiple > 0) {
      x2 += multiple - x2 % multiple;
    }
    return x2;
  }
  var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
  function updateGlobalBufferAndViews(buf) {
    buffer = buf;
    Module["HEAP8"] = HEAP8 = new Int8Array(buf);
    Module["HEAP16"] = HEAP16 = new Int16Array(buf);
    Module["HEAP32"] = HEAP32 = new Int32Array(buf);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
    Module["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
    Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
    Module["HEAPF32"] = HEAPF32 = new Float32Array(buf);
    Module["HEAPF64"] = HEAPF64 = new Float64Array(buf);
  }
  var DYNAMIC_BASE = 5266928, DYNAMICTOP_PTR = 24016;
  var INITIAL_TOTAL_MEMORY = Module["TOTAL_MEMORY"] || 33554432;
  if (Module["buffer"]) {
    buffer = Module["buffer"];
  } else {
    buffer = new ArrayBuffer(INITIAL_TOTAL_MEMORY);
  }
  INITIAL_TOTAL_MEMORY = buffer.byteLength;
  updateGlobalBufferAndViews(buffer);
  HEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;
  function callRuntimeCallbacks(callbacks) {
    while (callbacks.length > 0) {
      var callback = callbacks.shift();
      if (typeof callback == "function") {
        callback();
        continue;
      }
      var func = callback.func;
      if (typeof func === "number") {
        if (callback.arg === void 0) {
          Module["dynCall_v"](func);
        } else {
          Module["dynCall_vi"](func, callback.arg);
        }
      } else {
        func(callback.arg === void 0 ? null : callback.arg);
      }
    }
  }
  var __ATPRERUN__ = [];
  var __ATINIT__ = [];
  var __ATMAIN__ = [];
  var __ATPOSTRUN__ = [];
  function preRun() {
    if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function") {
        Module["preRun"] = [Module["preRun"]];
      }
      while (Module["preRun"].length) {
        addOnPreRun(Module["preRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPRERUN__);
  }
  function initRuntime() {
    callRuntimeCallbacks(__ATINIT__);
  }
  function preMain() {
    callRuntimeCallbacks(__ATMAIN__);
  }
  function postRun() {
    if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function") {
        Module["postRun"] = [Module["postRun"]];
      }
      while (Module["postRun"].length) {
        addOnPostRun(Module["postRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPOSTRUN__);
  }
  function addOnPreRun(cb) {
    __ATPRERUN__.unshift(cb);
  }
  function addOnPostRun(cb) {
    __ATPOSTRUN__.unshift(cb);
  }
  var Math_abs = Math.abs;
  var Math_ceil = Math.ceil;
  var Math_floor = Math.floor;
  var Math_min = Math.min;
  var runDependencies = 0;
  var runDependencyWatcher = null;
  var dependenciesFulfilled = null;
  function addRunDependency(id) {
    runDependencies++;
    if (Module["monitorRunDependencies"]) {
      Module["monitorRunDependencies"](runDependencies);
    }
  }
  function removeRunDependency(id) {
    runDependencies--;
    if (Module["monitorRunDependencies"]) {
      Module["monitorRunDependencies"](runDependencies);
    }
    if (runDependencies == 0) {
      if (runDependencyWatcher !== null) {
        clearInterval(runDependencyWatcher);
        runDependencyWatcher = null;
      }
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  Module["preloadedImages"] = {};
  Module["preloadedAudios"] = {};
  var memoryInitializer = null;
  var dataURIPrefix = "data:application/octet-stream;base64,";
  function isDataURI(filename) {
    return String.prototype.startsWith ? filename.startsWith(dataURIPrefix) : filename.indexOf(dataURIPrefix) === 0;
  }
  var tempDouble;
  var tempI64;
  memoryInitializer = "data:application/octet-stream;base64,AAAAAAAAAAACAAAAAwAAAAEAAAAFAAAABAAAAAYAAAAAAAAAAAAAAAAAAAABAAAAAgAAAAMAAAAEAAAABQAAAAYAAAABAAAABAAAAAMAAAAGAAAABQAAAAIAAAAAAAAAAgAAAAMAAAABAAAABAAAAAYAAAAAAAAABQAAAAMAAAAGAAAABAAAAAUAAAAAAAAAAQAAAAIAAAAEAAAABQAAAAYAAAAAAAAAAgAAAAMAAAABAAAABQAAAAIAAAAAAAAAAQAAAAMAAAAGAAAABAAAAAYAAAAAAAAABQAAAAIAAAABAAAABAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAgAAAAMAAAAAAAAAAAAAAAIAAAAAAAAAAQAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAEAAAABgAAAAAAAAAFAAAAAAAAAAAAAAAEAAAABQAAAAAAAAAAAAAAAAAAAAIAAAAAAAAABgAAAAAAAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAACAAAAAwAAAAQAAAAFAAAABgAAAAEAAAACAAAAAwAAAAQAAAAFAAAABgAAAAAAAAACAAAAAwAAAAQAAAAFAAAABgAAAAAAAAABAAAAAwAAAAQAAAAFAAAABgAAAAAAAAABAAAAAgAAAAQAAAAFAAAABgAAAAAAAAABAAAAAgAAAAMAAAAFAAAABgAAAAAAAAABAAAAAgAAAAMAAAAEAAAABgAAAAAAAAABAAAAAgAAAAMAAAAEAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAADAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAACAAAAAgAAAAAAAAAAAAAABgAAAAAAAAADAAAAAgAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAUAAAAEAAAAAAAAAAEAAAAAAAAAAAAAAAUAAAAFAAAAAAAAAAAAAAAAAAAABgAAAAAAAAAEAAAAAAAAAAYAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAUAAAACAAAABAAAAAMAAAAIAAAAAQAAAAcAAAAGAAAACQAAAAAAAAADAAAAAgAAAAIAAAAGAAAACgAAAAsAAAAAAAAAAQAAAAUAAAADAAAADQAAAAEAAAAHAAAABAAAAAwAAAAAAAAABAAAAH8AAAAPAAAACAAAAAMAAAAAAAAADAAAAAUAAAACAAAAEgAAAAoAAAAIAAAAAAAAABAAAAAGAAAADgAAAAsAAAARAAAAAQAAAAkAAAACAAAABwAAABUAAAAJAAAAEwAAAAMAAAANAAAAAQAAAAgAAAAFAAAAFgAAABAAAAAEAAAAAAAAAA8AAAAJAAAAEwAAAA4AAAAUAAAAAQAAAAcAAAAGAAAACgAAAAsAAAAYAAAAFwAAAAUAAAACAAAAEgAAAAsAAAARAAAAFwAAABkAAAACAAAABgAAAAoAAAAMAAAAHAAAAA0AAAAaAAAABAAAAA8AAAADAAAADQAAABoAAAAVAAAAHQAAAAMAAAAMAAAABwAAAA4AAAB/AAAAEQAAABsAAAAJAAAAFAAAAAYAAAAPAAAAFgAAABwAAAAfAAAABAAAAAgAAAAMAAAAEAAAABIAAAAhAAAAHgAAAAgAAAAFAAAAFgAAABEAAAALAAAADgAAAAYAAAAjAAAAGQAAABsAAAASAAAAGAAAAB4AAAAgAAAABQAAAAoAAAAQAAAAEwAAACIAAAAUAAAAJAAAAAcAAAAVAAAACQAAABQAAAAOAAAAEwAAAAkAAAAoAAAAGwAAACQAAAAVAAAAJgAAABMAAAAiAAAADQAAAB0AAAAHAAAAFgAAABAAAAApAAAAIQAAAA8AAAAIAAAAHwAAABcAAAAYAAAACwAAAAoAAAAnAAAAJQAAABkAAAAYAAAAfwAAACAAAAAlAAAACgAAABcAAAASAAAAGQAAABcAAAARAAAACwAAAC0AAAAnAAAAIwAAABoAAAAqAAAAHQAAACsAAAAMAAAAHAAAAA0AAAAbAAAAKAAAACMAAAAuAAAADgAAABQAAAARAAAAHAAAAB8AAAAqAAAALAAAAAwAAAAPAAAAGgAAAB0AAAArAAAAJgAAAC8AAAANAAAAGgAAABUAAAAeAAAAIAAAADAAAAAyAAAAEAAAABIAAAAhAAAAHwAAACkAAAAsAAAANQAAAA8AAAAWAAAAHAAAACAAAAAeAAAAGAAAABIAAAA0AAAAMgAAACUAAAAhAAAAHgAAADEAAAAwAAAAFgAAABAAAAApAAAAIgAAABMAAAAmAAAAFQAAADYAAAAkAAAAMwAAACMAAAAuAAAALQAAADgAAAARAAAAGwAAABkAAAAkAAAAFAAAACIAAAATAAAANwAAACgAAAA2AAAAJQAAACcAAAA0AAAAOQAAABgAAAAXAAAAIAAAACYAAAB/AAAAIgAAADMAAAAdAAAALwAAABUAAAAnAAAAJQAAABkAAAAXAAAAOwAAADkAAAAtAAAAKAAAABsAAAAkAAAAFAAAADwAAAAuAAAANwAAACkAAAAxAAAANQAAAD0AAAAWAAAAIQAAAB8AAAAqAAAAOgAAACsAAAA+AAAAHAAAACwAAAAaAAAAKwAAAD4AAAAvAAAAQAAAABoAAAAqAAAAHQAAACwAAAA1AAAAOgAAAEEAAAAcAAAAHwAAACoAAAAtAAAAJwAAACMAAAAZAAAAPwAAADsAAAA4AAAALgAAADwAAAA4AAAARAAAABsAAAAoAAAAIwAAAC8AAAAmAAAAKwAAAB0AAABFAAAAMwAAAEAAAAAwAAAAMQAAAB4AAAAhAAAAQwAAAEIAAAAyAAAAMQAAAH8AAAA9AAAAQgAAACEAAAAwAAAAKQAAADIAAAAwAAAAIAAAAB4AAABGAAAAQwAAADQAAAAzAAAARQAAADYAAABHAAAAJgAAAC8AAAAiAAAANAAAADkAAABGAAAASgAAACAAAAAlAAAAMgAAADUAAAA9AAAAQQAAAEsAAAAfAAAAKQAAACwAAAA2AAAARwAAADcAAABJAAAAIgAAADMAAAAkAAAANwAAACgAAAA2AAAAJAAAAEgAAAA8AAAASQAAADgAAABEAAAAPwAAAE0AAAAjAAAALgAAAC0AAAA5AAAAOwAAAEoAAABOAAAAJQAAACcAAAA0AAAAOgAAAH8AAAA+AAAATAAAACwAAABBAAAAKgAAADsAAAA/AAAATgAAAE8AAAAnAAAALQAAADkAAAA8AAAASAAAAEQAAABQAAAAKAAAADcAAAAuAAAAPQAAADUAAAAxAAAAKQAAAFEAAABLAAAAQgAAAD4AAAArAAAAOgAAACoAAABSAAAAQAAAAEwAAAA/AAAAfwAAADgAAAAtAAAATwAAADsAAABNAAAAQAAAAC8AAAA+AAAAKwAAAFQAAABFAAAAUgAAAEEAAAA6AAAANQAAACwAAABWAAAATAAAAEsAAABCAAAAQwAAAFEAAABVAAAAMQAAADAAAAA9AAAAQwAAAEIAAAAyAAAAMAAAAFcAAABVAAAARgAAAEQAAAA4AAAAPAAAAC4AAABaAAAATQAAAFAAAABFAAAAMwAAAEAAAAAvAAAAWQAAAEcAAABUAAAARgAAAEMAAAA0AAAAMgAAAFMAAABXAAAASgAAAEcAAABZAAAASQAAAFsAAAAzAAAARQAAADYAAABIAAAAfwAAAEkAAAA3AAAAUAAAADwAAABYAAAASQAAAFsAAABIAAAAWAAAADYAAABHAAAANwAAAEoAAABOAAAAUwAAAFwAAAA0AAAAOQAAAEYAAABLAAAAQQAAAD0AAAA1AAAAXgAAAFYAAABRAAAATAAAAFYAAABSAAAAYAAAADoAAABBAAAAPgAAAE0AAAA/AAAARAAAADgAAABdAAAATwAAAFoAAABOAAAASgAAADsAAAA5AAAAXwAAAFwAAABPAAAATwAAAE4AAAA/AAAAOwAAAF0AAABfAAAATQAAAFAAAABEAAAASAAAADwAAABjAAAAWgAAAFgAAABRAAAAVQAAAF4AAABlAAAAPQAAAEIAAABLAAAAUgAAAGAAAABUAAAAYgAAAD4AAABMAAAAQAAAAFMAAAB/AAAASgAAAEYAAABkAAAAVwAAAFwAAABUAAAARQAAAFIAAABAAAAAYQAAAFkAAABiAAAAVQAAAFcAAABlAAAAZgAAAEIAAABDAAAAUQAAAFYAAABMAAAASwAAAEEAAABoAAAAYAAAAF4AAABXAAAAUwAAAGYAAABkAAAAQwAAAEYAAABVAAAAWAAAAEgAAABbAAAASQAAAGMAAABQAAAAaQAAAFkAAABhAAAAWwAAAGcAAABFAAAAVAAAAEcAAABaAAAATQAAAFAAAABEAAAAagAAAF0AAABjAAAAWwAAAEkAAABZAAAARwAAAGkAAABYAAAAZwAAAFwAAABTAAAATgAAAEoAAABsAAAAZAAAAF8AAABdAAAATwAAAFoAAABNAAAAbQAAAF8AAABqAAAAXgAAAFYAAABRAAAASwAAAGsAAABoAAAAZQAAAF8AAABcAAAATwAAAE4AAABtAAAAbAAAAF0AAABgAAAAaAAAAGIAAABuAAAATAAAAFYAAABSAAAAYQAAAH8AAABiAAAAVAAAAGcAAABZAAAAbwAAAGIAAABuAAAAYQAAAG8AAABSAAAAYAAAAFQAAABjAAAAUAAAAGkAAABYAAAAagAAAFoAAABxAAAAZAAAAGYAAABTAAAAVwAAAGwAAAByAAAAXAAAAGUAAABmAAAAawAAAHAAAABRAAAAVQAAAF4AAABmAAAAZQAAAFcAAABVAAAAcgAAAHAAAABkAAAAZwAAAFsAAABhAAAAWQAAAHQAAABpAAAAbwAAAGgAAABrAAAAbgAAAHMAAABWAAAAXgAAAGAAAABpAAAAWAAAAGcAAABbAAAAcQAAAGMAAAB0AAAAagAAAF0AAABjAAAAWgAAAHUAAABtAAAAcQAAAGsAAAB/AAAAZQAAAF4AAABzAAAAaAAAAHAAAABsAAAAZAAAAF8AAABcAAAAdgAAAHIAAABtAAAAbQAAAGwAAABdAAAAXwAAAHUAAAB2AAAAagAAAG4AAABiAAAAaAAAAGAAAAB3AAAAbwAAAHMAAABvAAAAYQAAAG4AAABiAAAAdAAAAGcAAAB3AAAAcAAAAGsAAABmAAAAZQAAAHgAAABzAAAAcgAAAHEAAABjAAAAdAAAAGkAAAB1AAAAagAAAHkAAAByAAAAcAAAAGQAAABmAAAAdgAAAHgAAABsAAAAcwAAAG4AAABrAAAAaAAAAHgAAAB3AAAAcAAAAHQAAABnAAAAdwAAAG8AAABxAAAAaQAAAHkAAAB1AAAAfwAAAG0AAAB2AAAAcQAAAHkAAABqAAAAdgAAAHgAAABsAAAAcgAAAHUAAAB5AAAAbQAAAHcAAABvAAAAcwAAAG4AAAB5AAAAdAAAAHgAAAB4AAAAcwAAAHIAAABwAAAAeQAAAHcAAAB2AAAAeQAAAHQAAAB4AAAAdwAAAHUAAABxAAAAdgAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAEAAAAFAAAAAQAAAAAAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAIAAAAFAAAAAQAAAAAAAAD/////AQAAAAAAAAADAAAABAAAAAIAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAwAAAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAUAAAABAAAAAAAAAAAAAAABAAAAAwAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAQAAAAMAAAAAAAAAAAAAAAEAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAMAAAAFAAAAAQAAAAAAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAA/////wMAAAAAAAAABQAAAAIAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAQAAAAFAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAUAAAAFAAAAAAAAAAAAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAUAAAAFAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAMAAAAAAAAAAAAAAP////8DAAAAAAAAAAUAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAADAAAAAwAAAAAAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAADAAAAAAAAAAAAAAABAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAABAAAAAwAAAAAAAAAAAAAAAQAAAAAAAAADAAAAAwAAAAMAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAMAAAAAAAAA/////wMAAAAAAAAABQAAAAIAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAADAAAABQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAUAAAAFAAAAAAAAAAAAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAADAAAAAAAAAAAAAAABAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAD/////AwAAAAAAAAAFAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAAAAAD/////AwAAAAAAAAAFAAAAAgAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAMAAAADAAAAAAAAAAAAAAADAAAAAwAAAAMAAAADAAAAAAAAAAMAAAAAAAAAAwAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAP////8DAAAAAAAAAAUAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAAAAAP////8DAAAAAAAAAAUAAAACAAAAAAAAAAAAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAUAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAMAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAADAAAAAQAAAAAAAAABAAAAAAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAAAAAAAA/////wMAAAAAAAAABQAAAAIAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAABQAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAUAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAUAAAAFAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAAAAAD/////AwAAAAAAAAAFAAAAAgAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAADAAAAAAAAAAUAAAAAAAAAAAAAAAUAAAAFAAAAAAAAAAAAAAAAAAAAAQAAAAMAAAABAAAAAAAAAAEAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAADAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAMAAAABAAAAAAAAAAEAAAAAAAAAAwAAAAMAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAQAAAAAAAAADAAAABQAAAAEAAAAAAAAA/////wMAAAAAAAAABQAAAAIAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAUAAAAFAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAEAAAABQAAAAEAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAgAAAAUAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAQAAAAMAAAABAAAAAAAAAAEAAAAAAAAABQAAAAAAAAAAAAAABQAAAAUAAAAAAAAAAAAAAP////8BAAAAAAAAAAMAAAAEAAAAAgAAAAAAAAAAAAAAAQAAAAAAAAAAAAAABQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAUAAAAAAAAAAAAAAAUAAAAFAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAABAAAABQAAAAEAAAAAAAAAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAQAAAP//////////AQAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAMAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAIAAAAAAAAAAAAAAAEAAAACAAAABgAAAAQAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAABgAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAoAAAACAAAAAAAAAAAAAAABAAAAAQAAAAUAAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAsAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAIAAAAAAAAAAAAAAAEAAAADAAAABwAAAAYAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAHAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAABAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAOAAAAAgAAAAAAAAAAAAAAAQAAAAAAAAAJAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAwAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANAAAAAgAAAAAAAAAAAAAAAQAAAAQAAAAIAAAACgAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAsAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAJAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAACAAAAAAAAAAAAAAABAAAACwAAAA8AAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAA4AAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAgAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAFAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAAACAAAAAAAAAAAAAAABAAAADAAAABAAAAAMAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAACgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAA8AAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAPAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAANAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAIAAAAAAAAAAAAAAAEAAAAKAAAAEwAAAAgAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAARAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARAAAAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAADwAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAABAAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAJAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAgAAAAAAAAAAAAAAAQAAAA0AAAARAAAADQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAABEAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAATAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAABMAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAARAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAADQAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAABEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQAAAAIAAAAAAAAAAAAAAAEAAAAOAAAAEgAAAA8AAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAPAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEgAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAABIAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAATAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAEQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAEgAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAABMAAAACAAAAAAAAAAAAAAABAAAA//////////8TAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABMAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAASAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAABIAAAAAAAAAGAAAAAAAAAAhAAAAAAAAAB4AAAAAAAAAIAAAAAMAAAAxAAAAAQAAADAAAAADAAAAMgAAAAMAAAAIAAAAAAAAAAUAAAAFAAAACgAAAAUAAAAWAAAAAAAAABAAAAAAAAAAEgAAAAAAAAApAAAAAQAAACEAAAAAAAAAHgAAAAAAAAAEAAAAAAAAAAAAAAAFAAAAAgAAAAUAAAAPAAAAAQAAAAgAAAAAAAAABQAAAAUAAAAfAAAAAQAAABYAAAAAAAAAEAAAAAAAAAACAAAAAAAAAAYAAAAAAAAADgAAAAAAAAAKAAAAAAAAAAsAAAAAAAAAEQAAAAMAAAAYAAAAAQAAABcAAAADAAAAGQAAAAMAAAAAAAAAAAAAAAEAAAAFAAAACQAAAAUAAAAFAAAAAAAAAAIAAAAAAAAABgAAAAAAAAASAAAAAQAAAAoAAAAAAAAACwAAAAAAAAAEAAAAAQAAAAMAAAAFAAAABwAAAAUAAAAIAAAAAQAAAAAAAAAAAAAAAQAAAAUAAAAQAAAAAQAAAAUAAAAAAAAAAgAAAAAAAAAHAAAAAAAAABUAAAAAAAAAJgAAAAAAAAAJAAAAAAAAABMAAAAAAAAAIgAAAAMAAAAOAAAAAQAAABQAAAADAAAAJAAAAAMAAAADAAAAAAAAAA0AAAAFAAAAHQAAAAUAAAABAAAAAAAAAAcAAAAAAAAAFQAAAAAAAAAGAAAAAQAAAAkAAAAAAAAAEwAAAAAAAAAEAAAAAgAAAAwAAAAFAAAAGgAAAAUAAAAAAAAAAQAAAAMAAAAAAAAADQAAAAUAAAACAAAAAQAAAAEAAAAAAAAABwAAAAAAAAAaAAAAAAAAACoAAAAAAAAAOgAAAAAAAAAdAAAAAAAAACsAAAAAAAAAPgAAAAMAAAAmAAAAAQAAAC8AAAADAAAAQAAAAAMAAAAMAAAAAAAAABwAAAAFAAAALAAAAAUAAAANAAAAAAAAABoAAAAAAAAAKgAAAAAAAAAVAAAAAQAAAB0AAAAAAAAAKwAAAAAAAAAEAAAAAwAAAA8AAAAFAAAAHwAAAAUAAAADAAAAAQAAAAwAAAAAAAAAHAAAAAUAAAAHAAAAAQAAAA0AAAAAAAAAGgAAAAAAAAAfAAAAAAAAACkAAAAAAAAAMQAAAAAAAAAsAAAAAAAAADUAAAAAAAAAPQAAAAMAAAA6AAAAAQAAAEEAAAADAAAASwAAAAMAAAAPAAAAAAAAABYAAAAFAAAAIQAAAAUAAAAcAAAAAAAAAB8AAAAAAAAAKQAAAAAAAAAqAAAAAQAAACwAAAAAAAAANQAAAAAAAAAEAAAABAAAAAgAAAAFAAAAEAAAAAUAAAAMAAAAAQAAAA8AAAAAAAAAFgAAAAUAAAAaAAAAAQAAABwAAAAAAAAAHwAAAAAAAAAyAAAAAAAAADAAAAAAAAAAMQAAAAMAAAAgAAAAAAAAAB4AAAADAAAAIQAAAAMAAAAYAAAAAwAAABIAAAADAAAAEAAAAAMAAABGAAAAAAAAAEMAAAAAAAAAQgAAAAMAAAA0AAAAAwAAADIAAAAAAAAAMAAAAAAAAAAlAAAAAwAAACAAAAAAAAAAHgAAAAMAAABTAAAAAAAAAFcAAAADAAAAVQAAAAMAAABKAAAAAwAAAEYAAAAAAAAAQwAAAAAAAAA5AAAAAQAAADQAAAADAAAAMgAAAAAAAAAZAAAAAAAAABcAAAAAAAAAGAAAAAMAAAARAAAAAAAAAAsAAAADAAAACgAAAAMAAAAOAAAAAwAAAAYAAAADAAAAAgAAAAMAAAAtAAAAAAAAACcAAAAAAAAAJQAAAAMAAAAjAAAAAwAAABkAAAAAAAAAFwAAAAAAAAAbAAAAAwAAABEAAAAAAAAACwAAAAMAAAA/AAAAAAAAADsAAAADAAAAOQAAAAMAAAA4AAAAAwAAAC0AAAAAAAAAJwAAAAAAAAAuAAAAAwAAACMAAAADAAAAGQAAAAAAAAAkAAAAAAAAABQAAAAAAAAADgAAAAMAAAAiAAAAAAAAABMAAAADAAAACQAAAAMAAAAmAAAAAwAAABUAAAADAAAABwAAAAMAAAA3AAAAAAAAACgAAAAAAAAAGwAAAAMAAAA2AAAAAwAAACQAAAAAAAAAFAAAAAAAAAAzAAAAAwAAACIAAAAAAAAAEwAAAAMAAABIAAAAAAAAADwAAAADAAAALgAAAAMAAABJAAAAAwAAADcAAAAAAAAAKAAAAAAAAABHAAAAAwAAADYAAAADAAAAJAAAAAAAAABAAAAAAAAAAC8AAAAAAAAAJgAAAAMAAAA+AAAAAAAAACsAAAADAAAAHQAAAAMAAAA6AAAAAwAAACoAAAADAAAAGgAAAAMAAABUAAAAAAAAAEUAAAAAAAAAMwAAAAMAAABSAAAAAwAAAEAAAAAAAAAALwAAAAAAAABMAAAAAwAAAD4AAAAAAAAAKwAAAAMAAABhAAAAAAAAAFkAAAADAAAARwAAAAMAAABiAAAAAwAAAFQAAAAAAAAARQAAAAAAAABgAAAAAwAAAFIAAAADAAAAQAAAAAAAAABLAAAAAAAAAEEAAAAAAAAAOgAAAAMAAAA9AAAAAAAAADUAAAADAAAALAAAAAMAAAAxAAAAAwAAACkAAAADAAAAHwAAAAMAAABeAAAAAAAAAFYAAAAAAAAATAAAAAMAAABRAAAAAwAAAEsAAAAAAAAAQQAAAAAAAABCAAAAAwAAAD0AAAAAAAAANQAAAAMAAABrAAAAAAAAAGgAAAADAAAAYAAAAAMAAABlAAAAAwAAAF4AAAAAAAAAVgAAAAAAAABVAAAAAwAAAFEAAAADAAAASwAAAAAAAAA5AAAAAAAAADsAAAAAAAAAPwAAAAMAAABKAAAAAAAAAE4AAAADAAAATwAAAAMAAABTAAAAAwAAAFwAAAADAAAAXwAAAAMAAAAlAAAAAAAAACcAAAADAAAALQAAAAMAAAA0AAAAAAAAADkAAAAAAAAAOwAAAAAAAABGAAAAAwAAAEoAAAAAAAAATgAAAAMAAAAYAAAAAAAAABcAAAADAAAAGQAAAAMAAAAgAAAAAwAAACUAAAAAAAAAJwAAAAMAAAAyAAAAAwAAADQAAAAAAAAAOQAAAAAAAAAuAAAAAAAAADwAAAAAAAAASAAAAAMAAAA4AAAAAAAAAEQAAAADAAAAUAAAAAMAAAA/AAAAAwAAAE0AAAADAAAAWgAAAAMAAAAbAAAAAAAAACgAAAADAAAANwAAAAMAAAAjAAAAAAAAAC4AAAAAAAAAPAAAAAAAAAAtAAAAAwAAADgAAAAAAAAARAAAAAMAAAAOAAAAAAAAABQAAAADAAAAJAAAAAMAAAARAAAAAwAAABsAAAAAAAAAKAAAAAMAAAAZAAAAAwAAACMAAAAAAAAALgAAAAAAAABHAAAAAAAAAFkAAAAAAAAAYQAAAAMAAABJAAAAAAAAAFsAAAADAAAAZwAAAAMAAABIAAAAAwAAAFgAAAADAAAAaQAAAAMAAAAzAAAAAAAAAEUAAAADAAAAVAAAAAMAAAA2AAAAAAAAAEcAAAAAAAAAWQAAAAAAAAA3AAAAAwAAAEkAAAAAAAAAWwAAAAMAAAAmAAAAAAAAAC8AAAADAAAAQAAAAAMAAAAiAAAAAwAAADMAAAAAAAAARQAAAAMAAAAkAAAAAwAAADYAAAAAAAAARwAAAAAAAABgAAAAAAAAAGgAAAAAAAAAawAAAAMAAABiAAAAAAAAAG4AAAADAAAAcwAAAAMAAABhAAAAAwAAAG8AAAADAAAAdwAAAAMAAABMAAAAAAAAAFYAAAADAAAAXgAAAAMAAABSAAAAAAAAAGAAAAAAAAAAaAAAAAAAAABUAAAAAwAAAGIAAAAAAAAAbgAAAAMAAAA6AAAAAAAAAEEAAAADAAAASwAAAAMAAAA+AAAAAwAAAEwAAAAAAAAAVgAAAAMAAABAAAAAAwAAAFIAAAAAAAAAYAAAAAAAAABVAAAAAAAAAFcAAAAAAAAAUwAAAAMAAABlAAAAAAAAAGYAAAADAAAAZAAAAAMAAABrAAAAAwAAAHAAAAADAAAAcgAAAAMAAABCAAAAAAAAAEMAAAADAAAARgAAAAMAAABRAAAAAAAAAFUAAAAAAAAAVwAAAAAAAABeAAAAAwAAAGUAAAAAAAAAZgAAAAMAAAAxAAAAAAAAADAAAAADAAAAMgAAAAMAAAA9AAAAAwAAAEIAAAAAAAAAQwAAAAMAAABLAAAAAwAAAFEAAAAAAAAAVQAAAAAAAABfAAAAAAAAAFwAAAAAAAAAUwAAAAAAAABPAAAAAAAAAE4AAAAAAAAASgAAAAMAAAA/AAAAAQAAADsAAAADAAAAOQAAAAMAAABtAAAAAAAAAGwAAAAAAAAAZAAAAAUAAABdAAAAAQAAAF8AAAAAAAAAXAAAAAAAAABNAAAAAQAAAE8AAAAAAAAATgAAAAAAAAB1AAAABAAAAHYAAAAFAAAAcgAAAAUAAABqAAAAAQAAAG0AAAAAAAAAbAAAAAAAAABaAAAAAQAAAF0AAAABAAAAXwAAAAAAAABaAAAAAAAAAE0AAAAAAAAAPwAAAAAAAABQAAAAAAAAAEQAAAAAAAAAOAAAAAMAAABIAAAAAQAAADwAAAADAAAALgAAAAMAAABqAAAAAAAAAF0AAAAAAAAATwAAAAUAAABjAAAAAQAAAFoAAAAAAAAATQAAAAAAAABYAAAAAQAAAFAAAAAAAAAARAAAAAAAAAB1AAAAAwAAAG0AAAAFAAAAXwAAAAUAAABxAAAAAQAAAGoAAAAAAAAAXQAAAAAAAABpAAAAAQAAAGMAAAABAAAAWgAAAAAAAABpAAAAAAAAAFgAAAAAAAAASAAAAAAAAABnAAAAAAAAAFsAAAAAAAAASQAAAAMAAABhAAAAAQAAAFkAAAADAAAARwAAAAMAAABxAAAAAAAAAGMAAAAAAAAAUAAAAAUAAAB0AAAAAQAAAGkAAAAAAAAAWAAAAAAAAABvAAAAAQAAAGcAAAAAAAAAWwAAAAAAAAB1AAAAAgAAAGoAAAAFAAAAWgAAAAUAAAB5AAAAAQAAAHEAAAAAAAAAYwAAAAAAAAB3AAAAAQAAAHQAAAABAAAAaQAAAAAAAAB3AAAAAAAAAG8AAAAAAAAAYQAAAAAAAABzAAAAAAAAAG4AAAAAAAAAYgAAAAMAAABrAAAAAQAAAGgAAAADAAAAYAAAAAMAAAB5AAAAAAAAAHQAAAAAAAAAZwAAAAUAAAB4AAAAAQAAAHcAAAAAAAAAbwAAAAAAAABwAAAAAQAAAHMAAAAAAAAAbgAAAAAAAAB1AAAAAQAAAHEAAAAFAAAAaQAAAAUAAAB2AAAAAQAAAHkAAAAAAAAAdAAAAAAAAAByAAAAAQAAAHgAAAABAAAAdwAAAAAAAAByAAAAAAAAAHAAAAAAAAAAawAAAAAAAABkAAAAAAAAAGYAAAAAAAAAZQAAAAMAAABTAAAAAQAAAFcAAAADAAAAVQAAAAMAAAB2AAAAAAAAAHgAAAAAAAAAcwAAAAUAAABsAAAAAQAAAHIAAAAAAAAAcAAAAAAAAABcAAAAAQAAAGQAAAAAAAAAZgAAAAAAAAB1AAAAAAAAAHkAAAAFAAAAdwAAAAUAAABtAAAAAQAAAHYAAAAAAAAAeAAAAAAAAABfAAAAAQAAAGwAAAABAAAAcgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAQAAAAEAAAABAAAAAAAAAAAAAAABAAAAAAAAAAEAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAB+ogX28rbpPxqumpJv+fM/165tC4ns9D+XaEnTqUsEQFrOtNlC4PA/3U+0XG6P9b9TdUUBxTTjP4PUp8ex1ty/B1rD/EN43z+lcDi6LLrZP/a45NWEHMY/oJ5ijLDZ+j/xw3rjxWPjP2B8A46ioQdAotff3wla2z+FMSpA1jj+v6b5Y1mtPbS/cIu8K0F457/2esiyJpDNv98k5Ts2NeA/pvljWa09tD88ClUJ60MDQPZ6yLImkM0/4ONKxa0UBcD2uOTVhBzGv5G7JRxGave/8cN648Vj47+HCwtkjAXIv6LX398JWtu/qyheaCAL9D9TdUUBxTTjv4gyTxslhwVAB1rD/EN4378EH/28teoFwH6iBfbytum/F6ztFYdK/r/Xrm0Liez0vwcS6wNGWeO/Ws602ULg8L9TCtRLiLT8P8pi5RexJsw/BlIKPVwR5T95Wyu0/QjnP5PjoT7YYcu/mBhKZ6zrwj8wRYS7NebuP3qW6geh+Ls/SLrixebL3r+pcyymN9XrPwmkNHp7xec/GWNMZVAA17+82s+x2BLiPwn2ytbJ9ek/LgEH1sMS1j8yp/2LhTfeP+SnWwtQBbu/d38gkp5X7z8ytsuHaADGPzUYObdf1+m/7IauECWhwz+cjSACjzniP76Z+wUhN9K/1+GEKzup67+/GYr/04baPw6idWOvsuc/ZedTWsRa5b/EJQOuRzi0v/OncYhHPes/h49PixY53j+i8wWfC03Nvw2idWOvsue/ZedTWsRa5T/EJQOuRzi0P/KncYhHPeu/iY9PixY53r+i8wWfC03NP9anWwtQBbs/d38gkp5X778ytsuHaADGvzUYObdf1+k/74auECWhw7+cjSACjzniv8CZ+wUhN9I/1uGEKzup6z+/GYr/04bavwmkNHp7xee/F2NMZVAA1z+82s+x2BLivwr2ytbJ9em/KwEH1sMS1r8yp/2LhTfev81i5RexJsy/BlIKPVwR5b95Wyu0/Qjnv5DjoT7YYcs/nBhKZ6zrwr8wRYS7Nebuv3OW6geh+Lu/SLrixebL3j+pcyymN9Xrv8rHIFfWehZAMBwUdlo0DECTUc17EOb2PxpVB1SWChdAzjbhb9pTDUDQhmdvECX5P9FlMKCC9+g/IIAzjELgE0DajDngMv8GQFhWDmDPjNs/y1guLh96EkAxPi8k7DIEQJCc4URlhRhA3eLKKLwkEECqpNAyTBD/P6xpjXcDiwVAFtl//cQm4z+Ibt3XKiYTQM7mCLUb3QdAoM1t8yVv7D8aLZv2Nk8UQEAJPV5nQwxAtSsfTCoE9z9TPjXLXIIWQBVanC5W9AtAYM3d7Adm9j++5mQz1FoWQBUThyaVBghAwH5muQsV7T89Q1qv82MUQJoWGOfNuBdAzrkClkmwDkDQjKq77t37Py+g0dtitsE/ZwAMTwVPEUBojepluNwBQGYbtuW+t9w/HNWIJs6MEkDTNuQUSlgEQKxktPP5TcQ/ixbLB8JjEUCwuWjXMQYCQAS/R09FkRdAowpiZjhhDkB7LmlczD/7P01iQmhhsAVAnrtTwDy84z/Z6jfQ2TgTQChOCXMnWwpAhrW3daoz8z/HYJvVPI4VQLT3ik5FcA5Angi7LOZd+z+NNVzDy5gXQBXdvVTFUA1AYNMgOeYe+T8+qHXGCwkXQKQTOKwa5AJA8gFVoEMW0T+FwzJyttIRQAEAAAD/////BwAAAP////8xAAAA/////1cBAAD/////YQkAAP////+nQQAA/////5HLAQD/////95AMAP/////B9lcAAAAAAAAAAAAAAAAAAgAAAP////8OAAAA/////2IAAAD/////rgIAAP/////CEgAA/////06DAAD/////IpcDAP/////uIRkA/////4LtrwAAAAAAAAAAAAAAAAAAAAAAAgAAAP//////////AQAAAAMAAAD//////////////////////////////////////////////////////////////////////////wEAAAAAAAAAAgAAAP///////////////wMAAAD//////////////////////////////////////////////////////////////////////////wEAAAAAAAAAAgAAAP///////////////wMAAAD//////////////////////////////////////////////////////////////////////////wEAAAAAAAAAAgAAAP///////////////wMAAAD//////////////////////////////////////////////////////////wIAAAD//////////wEAAAAAAAAA/////////////////////wMAAAD/////////////////////////////////////////////////////AwAAAP////////////////////8AAAAA/////////////////////wEAAAD///////////////8CAAAA////////////////////////////////AwAAAP////////////////////8AAAAA////////////////AgAAAAEAAAD/////////////////////////////////////////////////////AwAAAP////////////////////8AAAAA////////////////AgAAAAEAAAD/////////////////////////////////////////////////////AwAAAP////////////////////8AAAAA////////////////AgAAAAEAAAD/////////////////////////////////////////////////////AwAAAP////////////////////8AAAAA////////////////AgAAAAEAAAD/////////////////////////////////////////////////////AQAAAAIAAAD///////////////8AAAAA/////////////////////wMAAAD/////////////////////////////////////////////////////AQAAAAIAAAD///////////////8AAAAA/////////////////////wMAAAD/////////////////////////////////////////////////////AQAAAAIAAAD///////////////8AAAAA/////////////////////wMAAAD/////////////////////////////////////////////////////AQAAAAIAAAD///////////////8AAAAA/////////////////////wMAAAD///////////////////////////////8CAAAA////////////////AQAAAP////////////////////8AAAAA/////////////////////wMAAAD/////////////////////////////////////////////////////AwAAAP////////////////////8AAAAAAQAAAP//////////AgAAAP//////////////////////////////////////////////////////////AwAAAP///////////////wIAAAAAAAAAAQAAAP//////////////////////////////////////////////////////////////////////////AwAAAP///////////////wIAAAAAAAAAAQAAAP//////////////////////////////////////////////////////////////////////////AwAAAP///////////////wIAAAAAAAAAAQAAAP//////////////////////////////////////////////////////////////////////////AwAAAAEAAAD//////////wIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAgAAAAAAAAACAAAAAQAAAAEAAAACAAAAAgAAAAAAAAAFAAAABQAAAAAAAAACAAAAAgAAAAMAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAIAAAABAAAAAgAAAAIAAAACAAAAAAAAAAUAAAAGAAAAAAAAAAIAAAACAAAAAwAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAIAAAAAAAAAAgAAAAEAAAADAAAAAgAAAAIAAAAAAAAABQAAAAcAAAAAAAAAAgAAAAIAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAgAAAAAAAAACAAAAAQAAAAQAAAACAAAAAgAAAAAAAAAFAAAACAAAAAAAAAACAAAAAgAAAAMAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAACAAAAAAAAAAIAAAABAAAAAAAAAAIAAAACAAAAAAAAAAUAAAAJAAAAAAAAAAIAAAACAAAAAwAAAAUAAAAAAAAAAAAAAAAAAAAAAAAACgAAAAIAAAACAAAAAAAAAAMAAAAOAAAAAgAAAAAAAAACAAAAAwAAAAAAAAAAAAAAAgAAAAIAAAADAAAABgAAAAAAAAAAAAAAAAAAAAAAAAALAAAAAgAAAAIAAAAAAAAAAwAAAAoAAAACAAAAAAAAAAIAAAADAAAAAQAAAAAAAAACAAAAAgAAAAMAAAAHAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAACAAAAAgAAAAAAAAADAAAACwAAAAIAAAAAAAAAAgAAAAMAAAACAAAAAAAAAAIAAAACAAAAAwAAAAgAAAAAAAAAAAAAAAAAAAAAAAAADQAAAAIAAAACAAAAAAAAAAMAAAAMAAAAAgAAAAAAAAACAAAAAwAAAAMAAAAAAAAAAgAAAAIAAAADAAAACQAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAgAAAAIAAAAAAAAAAwAAAA0AAAACAAAAAAAAAAIAAAADAAAABAAAAAAAAAACAAAAAgAAAAMAAAAKAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAACAAAAAgAAAAAAAAADAAAABgAAAAIAAAAAAAAAAgAAAAMAAAAPAAAAAAAAAAIAAAACAAAAAwAAAAsAAAAAAAAAAAAAAAAAAAAAAAAABgAAAAIAAAACAAAAAAAAAAMAAAAHAAAAAgAAAAAAAAACAAAAAwAAABAAAAAAAAAAAgAAAAIAAAADAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAgAAAAIAAAAAAAAAAwAAAAgAAAACAAAAAAAAAAIAAAADAAAAEQAAAAAAAAACAAAAAgAAAAMAAAANAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAACAAAAAgAAAAAAAAADAAAACQAAAAIAAAAAAAAAAgAAAAMAAAASAAAAAAAAAAIAAAACAAAAAwAAAA4AAAAAAAAAAAAAAAAAAAAAAAAACQAAAAIAAAACAAAAAAAAAAMAAAAFAAAAAgAAAAAAAAACAAAAAwAAABMAAAAAAAAAAgAAAAIAAAADAAAADwAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAgAAAAAAAAACAAAAAQAAABMAAAACAAAAAgAAAAAAAAAFAAAACgAAAAAAAAACAAAAAgAAAAMAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABEAAAACAAAAAAAAAAIAAAABAAAADwAAAAIAAAACAAAAAAAAAAUAAAALAAAAAAAAAAIAAAACAAAAAwAAABEAAAAAAAAAAAAAAAAAAAAAAAAAEgAAAAIAAAAAAAAAAgAAAAEAAAAQAAAAAgAAAAIAAAAAAAAABQAAAAwAAAAAAAAAAgAAAAIAAAADAAAAEgAAAAAAAAAAAAAAAAAAAAAAAAATAAAAAgAAAAAAAAACAAAAAQAAABEAAAACAAAAAgAAAAAAAAAFAAAADQAAAAAAAAACAAAAAgAAAAMAAAATAAAAAAAAAAAAAAAAAAAAAAAAAA8AAAACAAAAAAAAAAIAAAABAAAAEgAAAAIAAAACAAAAAAAAAAUAAAAOAAAAAAAAAAIAAAACAAAAAwAAAAIAAAABAAAAAAAAAAEAAAACAAAAAAAAAAAAAAACAAAAAQAAAAAAAAABAAAAAgAAAAEAAAAAAAAAAgAAAAAAAAAFAAAABAAAAAAAAAABAAAABQAAAAAAAAAAAAAABQAAAAQAAAAAAAAAAQAAAAUAAAAEAAAAAAAAAAUAAAAAAAAAAgAAAAEAAAAAAAAAAQAAAAIAAAAAAAAAAAAAAAIAAAABAAAAAAAAAAEAAAACAAAAAQAAAAAAAAACAAAAAgAAAAAAAAABAAAAAAAAAAAAAAAFAAAABAAAAAAAAAABAAAABQAAAAAAAAAAAAAABQAAAAQAAAAAAAAAAQAAAAUAAAAEAAAAAAAAAAUAAAAFAAAAAAAAAAEAAAAAAAAAAAAAAMuhRbbsNlBBYqHW9OmHIkF9XBuqnS31QAK37uYhNMhAOSo3UUupm0DC+6pc6JxvQHV9eseEEEJAzURsCyqlFEB8BQ4NMJjnPyy3tBoS97o/xawXQznRjj89J2K2CZxhP6vX43RIIDQ/S8isgygEBz+LvFHQkmzaPjFFFO7wMq4+AADMLkTtjkIAAOgkJqxhQgAAU7B0MjRCAADwpBcVB0IAAACYP2HaQQAAAIn/Ja5BzczM4Eg6gUHNzMxMU7BTQTMzMzNfgCZBAAAAAEi3+UAAAAAAwGPNQDMzMzMzy6BAmpmZmZkxc0AzMzMzM/NFQDMzMzMzMxlAzczMzMzM7D+ygXSx2U6RQKimJOvQKnpA23hmONTHY0A/AGcxyudNQNb3K647mzZA+S56rrwWIUAm4kUQ+9UJQKre9hGzh/M/BLvoy9WG3T+LmqMf8VHGP2m3nYNV37A/gbFHcyeCmT+cBPWBckiDP61tZACjKW0/q2RbYVUYVj8uDypVyLNAP6jGS5cA5zBBwcqhBdCNGUEGEhQ/JVEDQT6WPnRbNO1AB/AWSJgT1kDfUWNCNLDAQNk+5C33OqlAchWL34QSk0DKvtDIrNV8QNF0G3kFzGVASSeWhBl6UED+/0mNGuk4QGjA/dm/1CJALPLPMql6DEDSHoDrwpP1P2jouzWST+A/egAAAAAAAABKAwAAAAAAAPoWAAAAAAAAyqAAAAAAAAB6ZQQAAAAAAErGHgAAAAAA+mvXAAAAAADK8+MFAAAAAHqqOykAAAAASqmhIAEAAAD6oGvkBwAAAMpm8T43AAAAes+ZuIIBAABKrDQMkwoAAPq1cFUFSgAAyvkUViUGAgAAAAAAAwAAAAYAAAACAAAABQAAAAEAAAAEAAAAAAAAAAAAAAAFAAAAAwAAAAEAAAAGAAAABAAAAAIAAAAAAAAAAAAAAP////8AAAAAAAAAAAAAAAAAAAAAAAAAAP////////////////////////////////////8AAAAA/////wAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAP////8AAAAAAAAAAAEAAAABAAAAAAAAAAAAAAD/////AAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAA/////wUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////////////////////////////////////AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////////////////////////////////////wAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAUAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////////////////////////////////////8AAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAABAAAAAAAAAAAAAAABAAAAAQAAAAEAAAAAAAAAAQAAAAAAAAAFAAAAAQAAAAEAAAAAAAAAAAAAAAEAAAABAAAAAAAAAAEAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAAAAAABAAEAAAEBAAAAAAABAAAAAQAAAAEAAQAAAAAAAAAAAAAAAAAAAAAEAAAABAAAAAAAAAACAAAAAQAAAAMAAAAOAAAABgAAAAsAAAACAAAABwAAAAEAAAAYAAAABQAAAAoAAAABAAAABgAAAAAAAAAmAAAABwAAAAwAAAADAAAACAAAAAIAAAAxAAAACQAAAA4AAAAAAAAABQAAAAQAAAA6AAAACAAAAA0AAAAEAAAACQAAAAMAAAA/AAAACwAAAAYAAAAPAAAACgAAABAAAABIAAAADAAAAAcAAAAQAAAACwAAABEAAABTAAAACgAAAAUAAAATAAAADgAAAA8AAABhAAAADQAAAAgAAAARAAAADAAAABIAAABrAAAADgAAAAkAAAASAAAADQAAABMAAAB1AAAADwAAABMAAAARAAAAEgAAABAAAAAHAAAABwAAAAEAAAACAAAABAAAAAMAAAAAAAAAAAAAAAcAAAADAAAAAQAAAAIAAAAFAAAABAAAAAAAAAAAAAAAYWxnb3MuYwBfcG9seWZpbGxJbnRlcm5hbABhZGphY2VudEZhY2VEaXJbdG1wRmlqay5mYWNlXVtmaWprLmZhY2VdID09IEtJAGZhY2VpamsuYwBfZmFjZUlqa1BlbnRUb0dlb0JvdW5kYXJ5AGFkamFjZW50RmFjZURpcltjZW50ZXJJSksuZmFjZV1bZmFjZTJdID09IEtJAF9mYWNlSWprVG9HZW9Cb3VuZGFyeQBwb2x5Z29uLT5uZXh0ID09IE5VTEwAbGlua2VkR2VvLmMAYWRkTmV3TGlua2VkUG9seWdvbgBuZXh0ICE9IE5VTEwAbG9vcCAhPSBOVUxMAGFkZE5ld0xpbmtlZExvb3AAcG9seWdvbi0+Zmlyc3QgPT0gTlVMTABhZGRMaW5rZWRMb29wAGNvb3JkICE9IE5VTEwAYWRkTGlua2VkQ29vcmQAbG9vcC0+Zmlyc3QgPT0gTlVMTABpbm5lckxvb3BzICE9IE5VTEwAbm9ybWFsaXplTXVsdGlQb2x5Z29uAGJib3hlcyAhPSBOVUxMAGNhbmRpZGF0ZXMgIT0gTlVMTABmaW5kUG9seWdvbkZvckhvbGUAY2FuZGlkYXRlQkJveGVzICE9IE5VTEwAcmV2RGlyICE9IElOVkFMSURfRElHSVQAbG9jYWxpai5jAGgzVG9Mb2NhbElqawBiYXNlQ2VsbCAhPSBvcmlnaW5CYXNlQ2VsbAAhKG9yaWdpbk9uUGVudCAmJiBpbmRleE9uUGVudCkAcGVudGFnb25Sb3RhdGlvbnMgPj0gMABkaXJlY3Rpb25Sb3RhdGlvbnMgPj0gMABiYXNlQ2VsbCA9PSBvcmlnaW5CYXNlQ2VsbABiYXNlQ2VsbCAhPSBJTlZBTElEX0JBU0VfQ0VMTABsb2NhbElqa1RvSDMAIV9pc0Jhc2VDZWxsUGVudGFnb24oYmFzZUNlbGwpAGJhc2VDZWxsUm90YXRpb25zID49IDAAd2l0aGluUGVudGFnb25Sb3RhdGlvbnMgPj0gMABncmFwaC0+YnVja2V0cyAhPSBOVUxMAHZlcnRleEdyYXBoLmMAaW5pdFZlcnRleEdyYXBoAG5vZGUgIT0gTlVMTABhZGRWZXJ0ZXhOb2Rl";
  var tempDoublePtr = 24032;
  function demangle(func) {
    return func;
  }
  function demangleAll(text) {
    var regex = /\b__Z[\w\d_]+/g;
    return text.replace(regex, function(x2) {
      var y2 = demangle(x2);
      return x2 === y2 ? x2 : y2 + " [" + x2 + "]";
    });
  }
  function jsStackTrace() {
    var err2 = new Error();
    if (!err2.stack) {
      try {
        throw new Error(0);
      } catch (e) {
        err2 = e;
      }
      if (!err2.stack) {
        return "(no stack trace available)";
      }
    }
    return err2.stack.toString();
  }
  function stackTrace() {
    var js = jsStackTrace();
    if (Module["extraStackTrace"]) {
      js += "\n" + Module["extraStackTrace"]();
    }
    return demangleAll(js);
  }
  function ___assert_fail(condition, filename, line, func) {
    abort("Assertion failed: " + UTF8ToString(condition) + ", at: " + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
  }
  function _emscripten_get_heap_size() {
    return HEAP8.length;
  }
  function _emscripten_memcpy_big(dest, src, num) {
    HEAPU8.set(HEAPU8.subarray(src, src + num), dest);
  }
  function ___setErrNo(value) {
    if (Module["___errno_location"]) {
      HEAP32[Module["___errno_location"]() >> 2] = value;
    }
    return value;
  }
  function abortOnCannotGrowMemory(requestedSize) {
    abort("OOM");
  }
  function emscripten_realloc_buffer(size) {
    try {
      var newBuffer = new ArrayBuffer(size);
      if (newBuffer.byteLength != size) {
        return;
      }
      new Int8Array(newBuffer).set(HEAP8);
      _emscripten_replace_memory(newBuffer);
      updateGlobalBufferAndViews(newBuffer);
      return 1;
    } catch (e) {
    }
  }
  function _emscripten_resize_heap(requestedSize) {
    var oldSize = _emscripten_get_heap_size();
    var PAGE_MULTIPLE = 16777216;
    var LIMIT = 2147483648 - PAGE_MULTIPLE;
    if (requestedSize > LIMIT) {
      return false;
    }
    var MIN_TOTAL_MEMORY = 16777216;
    var newSize = Math.max(oldSize, MIN_TOTAL_MEMORY);
    while (newSize < requestedSize) {
      if (newSize <= 536870912) {
        newSize = alignUp(2 * newSize, PAGE_MULTIPLE);
      } else {
        newSize = Math.min(alignUp((3 * newSize + 2147483648) / 4, PAGE_MULTIPLE), LIMIT);
      }
    }
    var replacement = emscripten_realloc_buffer(newSize);
    if (!replacement) {
      return false;
    }
    return true;
  }
  var decodeBase64 = typeof atob === "function" ? atob : function(input) {
    var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var output = "";
    var chr1, chr2, chr3;
    var enc1, enc2, enc3, enc4;
    var i2 = 0;
    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
    do {
      enc1 = keyStr.indexOf(input.charAt(i2++));
      enc2 = keyStr.indexOf(input.charAt(i2++));
      enc3 = keyStr.indexOf(input.charAt(i2++));
      enc4 = keyStr.indexOf(input.charAt(i2++));
      chr1 = enc1 << 2 | enc2 >> 4;
      chr2 = (enc2 & 15) << 4 | enc3 >> 2;
      chr3 = (enc3 & 3) << 6 | enc4;
      output = output + String.fromCharCode(chr1);
      if (enc3 !== 64) {
        output = output + String.fromCharCode(chr2);
      }
      if (enc4 !== 64) {
        output = output + String.fromCharCode(chr3);
      }
    } while (i2 < input.length);
    return output;
  };
  function intArrayFromBase64(s) {
    try {
      var decoded = decodeBase64(s);
      var bytes = new Uint8Array(decoded.length);
      for (var i2 = 0; i2 < decoded.length; ++i2) {
        bytes[i2] = decoded.charCodeAt(i2);
      }
      return bytes;
    } catch (_) {
      throw new Error("Converting base64 string to bytes failed.");
    }
  }
  function tryParseAsDataURI(filename) {
    if (!isDataURI(filename)) {
      return;
    }
    return intArrayFromBase64(filename.slice(dataURIPrefix.length));
  }
  var asmGlobalArg = {
    "Math": Math,
    "Int8Array": Int8Array,
    "Int32Array": Int32Array,
    "Uint8Array": Uint8Array,
    "Float32Array": Float32Array,
    "Float64Array": Float64Array
  };
  var asmLibraryArg = {
    "a": abort,
    "b": setTempRet0,
    "c": getTempRet0,
    "d": ___assert_fail,
    "e": ___setErrNo,
    "f": _emscripten_get_heap_size,
    "g": _emscripten_memcpy_big,
    "h": _emscripten_resize_heap,
    "i": abortOnCannotGrowMemory,
    "j": demangle,
    "k": demangleAll,
    "l": emscripten_realloc_buffer,
    "m": jsStackTrace,
    "n": stackTrace,
    "o": tempDoublePtr,
    "p": DYNAMICTOP_PTR
  };
  var asm = (
    /** @suppress {uselessCode} */
    function(global, env, buffer2) {
      "almost asm";
      var a = new global.Int8Array(buffer2), b = new global.Int32Array(buffer2), c = new global.Uint8Array(buffer2), d = new global.Float32Array(buffer2), e = new global.Float64Array(buffer2), g = env.p | 0, p = global.Math.floor, q = global.Math.abs, r = global.Math.sqrt, s = global.Math.pow, t = global.Math.cos, u = global.Math.sin, v = global.Math.tan, w = global.Math.acos, x2 = global.Math.asin, y2 = global.Math.atan, z = global.Math.atan2, A = global.Math.ceil, B = global.Math.imul, C = global.Math.min, D = global.Math.clz32, F = env.b, G = env.c, H = env.d, I = env.e, J = env.f, K = env.g, L = env.h, M = env.i, S = 24048;
      function V(newBuffer) {
        a = new Int8Array(newBuffer);
        c = new Uint8Array(newBuffer);
        b = new Int32Array(newBuffer);
        d = new Float32Array(newBuffer);
        e = new Float64Array(newBuffer);
        buffer2 = newBuffer;
        return true;
      }
      function W(a2) {
        a2 = a2 | 0;
        var b2 = 0;
        b2 = S;
        S = S + a2 | 0;
        S = S + 15 & -16;
        return b2 | 0;
      }
      function X() {
        return S | 0;
      }
      function Y(a2) {
        a2 = a2 | 0;
        S = a2;
      }
      function Z(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        S = a2;
      }
      function _(a2) {
        a2 = a2 | 0;
        return (B(a2 * 3 | 0, a2 + 1 | 0) | 0) + 1 | 0;
      }
      function $(a2, b2, c2, d2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        var e2 = 0, f = 0;
        if (!(ba(a2, b2, c2, d2, 0) | 0)) {
          return;
        }
        f = (B(c2 * 3 | 0, c2 + 1 | 0) | 0) + 1 | 0;
        hd(d2 | 0, 0, f << 3 | 0) | 0;
        e2 = Yc(f, 4) | 0;
        if (!e2) {
          return;
        }
        ca(a2, b2, c2, d2, e2, f, 0);
        Xc(e2);
        return;
      }
      function aa(a2, b2, c2, d2, e2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        var f = 0;
        if (!(ba(a2, b2, c2, d2, e2) | 0)) {
          return;
        }
        f = (B(c2 * 3 | 0, c2 + 1 | 0) | 0) + 1 | 0;
        hd(d2 | 0, 0, f << 3 | 0) | 0;
        if (e2 | 0) {
          hd(e2 | 0, 0, f << 2 | 0) | 0;
          ca(a2, b2, c2, d2, e2, f, 0);
          return;
        }
        e2 = Yc(f, 4) | 0;
        if (!e2) {
          return;
        }
        ca(a2, b2, c2, d2, e2, f, 0);
        Xc(e2);
        return;
      }
      function ba(a2, c2, d2, e2, f) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        f = f | 0;
        var g2 = 0, h = 0, i2 = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0;
        o = S;
        S = S + 16 | 0;
        n = o;
        g2 = e2;
        b[g2 >> 2] = a2;
        b[g2 + 4 >> 2] = c2;
        g2 = (f | 0) != 0;
        if (g2) {
          b[f >> 2] = 0;
        }
        if (Fb(a2, c2) | 0) {
          n = 1;
          S = o;
          return n | 0;
        }
        b[n >> 2] = 0;
        a:
          do {
            if ((d2 | 0) >= 1) {
              if (g2) {
                k = 0;
                l = 1;
                m = 1;
                h = 0;
                g2 = a2;
                while (1) {
                  if (!(h | k)) {
                    g2 = da(g2, c2, 4, n) | 0;
                    c2 = G() | 0;
                    if ((g2 | 0) == 0 & (c2 | 0) == 0) {
                      g2 = 2;
                      break a;
                    }
                    if (Fb(g2, c2) | 0) {
                      g2 = 1;
                      break a;
                    }
                  }
                  g2 = da(g2, c2, b[16 + (k << 2) >> 2] | 0, n) | 0;
                  c2 = G() | 0;
                  if ((g2 | 0) == 0 & (c2 | 0) == 0) {
                    g2 = 2;
                    break a;
                  }
                  a2 = e2 + (m << 3) | 0;
                  b[a2 >> 2] = g2;
                  b[a2 + 4 >> 2] = c2;
                  b[f + (m << 2) >> 2] = l;
                  h = h + 1 | 0;
                  a2 = (h | 0) == (l | 0);
                  i2 = k + 1 | 0;
                  j = (i2 | 0) == 6;
                  if (Fb(g2, c2) | 0) {
                    g2 = 1;
                    break a;
                  }
                  l = l + (j & a2 & 1) | 0;
                  if ((l | 0) > (d2 | 0)) {
                    g2 = 0;
                    break;
                  } else {
                    k = a2 ? j ? 0 : i2 : k;
                    m = m + 1 | 0;
                    h = a2 ? 0 : h;
                  }
                }
              } else {
                k = 0;
                l = 1;
                m = 1;
                h = 0;
                g2 = a2;
                while (1) {
                  if (!(h | k)) {
                    g2 = da(g2, c2, 4, n) | 0;
                    c2 = G() | 0;
                    if ((g2 | 0) == 0 & (c2 | 0) == 0) {
                      g2 = 2;
                      break a;
                    }
                    if (Fb(g2, c2) | 0) {
                      g2 = 1;
                      break a;
                    }
                  }
                  g2 = da(g2, c2, b[16 + (k << 2) >> 2] | 0, n) | 0;
                  c2 = G() | 0;
                  if ((g2 | 0) == 0 & (c2 | 0) == 0) {
                    g2 = 2;
                    break a;
                  }
                  a2 = e2 + (m << 3) | 0;
                  b[a2 >> 2] = g2;
                  b[a2 + 4 >> 2] = c2;
                  h = h + 1 | 0;
                  a2 = (h | 0) == (l | 0);
                  i2 = k + 1 | 0;
                  j = (i2 | 0) == 6;
                  if (Fb(g2, c2) | 0) {
                    g2 = 1;
                    break a;
                  }
                  l = l + (j & a2 & 1) | 0;
                  if ((l | 0) > (d2 | 0)) {
                    g2 = 0;
                    break;
                  } else {
                    k = a2 ? j ? 0 : i2 : k;
                    m = m + 1 | 0;
                    h = a2 ? 0 : h;
                  }
                }
              }
            } else {
              g2 = 0;
            }
          } while (0);
        n = g2;
        S = o;
        return n | 0;
      }
      function ca(a2, c2, d2, e2, f, g2, h) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        f = f | 0;
        g2 = g2 | 0;
        h = h | 0;
        var i2 = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0;
        m = S;
        S = S + 16 | 0;
        l = m;
        if ((a2 | 0) == 0 & (c2 | 0) == 0) {
          S = m;
          return;
        }
        i2 = bd(a2 | 0, c2 | 0, g2 | 0, ((g2 | 0) < 0) << 31 >> 31 | 0) | 0;
        G() | 0;
        j = e2 + (i2 << 3) | 0;
        n = j;
        o = b[n >> 2] | 0;
        n = b[n + 4 >> 2] | 0;
        k = (o | 0) == (a2 | 0) & (n | 0) == (c2 | 0);
        if (!((o | 0) == 0 & (n | 0) == 0 | k)) {
          do {
            i2 = (i2 + 1 | 0) % (g2 | 0) | 0;
            j = e2 + (i2 << 3) | 0;
            o = j;
            n = b[o >> 2] | 0;
            o = b[o + 4 >> 2] | 0;
            k = (n | 0) == (a2 | 0) & (o | 0) == (c2 | 0);
          } while (!((n | 0) == 0 & (o | 0) == 0 | k));
        }
        i2 = f + (i2 << 2) | 0;
        if (k ? (b[i2 >> 2] | 0) <= (h | 0) : 0) {
          S = m;
          return;
        }
        o = j;
        b[o >> 2] = a2;
        b[o + 4 >> 2] = c2;
        b[i2 >> 2] = h;
        if ((h | 0) >= (d2 | 0)) {
          S = m;
          return;
        }
        o = h + 1 | 0;
        b[l >> 2] = 0;
        n = da(a2, c2, 2, l) | 0;
        ca(n, G() | 0, d2, e2, f, g2, o);
        b[l >> 2] = 0;
        n = da(a2, c2, 3, l) | 0;
        ca(n, G() | 0, d2, e2, f, g2, o);
        b[l >> 2] = 0;
        n = da(a2, c2, 1, l) | 0;
        ca(n, G() | 0, d2, e2, f, g2, o);
        b[l >> 2] = 0;
        n = da(a2, c2, 5, l) | 0;
        ca(n, G() | 0, d2, e2, f, g2, o);
        b[l >> 2] = 0;
        n = da(a2, c2, 4, l) | 0;
        ca(n, G() | 0, d2, e2, f, g2, o);
        b[l >> 2] = 0;
        n = da(a2, c2, 6, l) | 0;
        ca(n, G() | 0, d2, e2, f, g2, o);
        S = m;
        return;
      }
      function da(a2, c2, d2, e2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        var f = 0, g2 = 0, h = 0, i2 = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0;
        if ((b[e2 >> 2] | 0) > 0) {
          f = 0;
          do {
            d2 = Pa(d2) | 0;
            f = f + 1 | 0;
          } while ((f | 0) < (b[e2 >> 2] | 0));
        }
        i2 = cd(a2 | 0, c2 | 0, 45) | 0;
        G() | 0;
        j = i2 & 127;
        g2 = Lb(a2, c2) | 0;
        f = cd(a2 | 0, c2 | 0, 52) | 0;
        G() | 0;
        f = f & 15;
        a:
          do {
            if (!f) {
              h = 6;
            } else {
              while (1) {
                m = (15 - f | 0) * 3 | 0;
                n = cd(a2 | 0, c2 | 0, m | 0) | 0;
                G() | 0;
                n = n & 7;
                o = (Rb(f) | 0) == 0;
                f = f + -1 | 0;
                l = dd(7, 0, m | 0) | 0;
                c2 = c2 & ~(G() | 0);
                m = dd(b[(o ? 464 : 48) + (n * 28 | 0) + (d2 << 2) >> 2] | 0, 0, m | 0) | 0;
                k = G() | 0;
                d2 = b[(o ? 672 : 256) + (n * 28 | 0) + (d2 << 2) >> 2] | 0;
                a2 = m | a2 & ~l;
                c2 = k | c2;
                if (!d2) {
                  d2 = 0;
                  break a;
                }
                if (!f) {
                  h = 6;
                  break;
                }
              }
            }
          } while (0);
        if ((h | 0) == 6) {
          o = b[880 + (j * 28 | 0) + (d2 << 2) >> 2] | 0;
          n = dd(o | 0, 0, 45) | 0;
          a2 = n | a2;
          c2 = G() | 0 | c2 & -1040385;
          d2 = b[4304 + (j * 28 | 0) + (d2 << 2) >> 2] | 0;
          if ((o & 127 | 0) == 127) {
            o = dd(b[880 + (j * 28 | 0) + 20 >> 2] | 0, 0, 45) | 0;
            c2 = G() | 0 | c2 & -1040385;
            d2 = b[4304 + (j * 28 | 0) + 20 >> 2] | 0;
            a2 = Nb(o | a2, c2) | 0;
            c2 = G() | 0;
            b[e2 >> 2] = (b[e2 >> 2] | 0) + 1;
          }
        }
        h = cd(a2 | 0, c2 | 0, 45) | 0;
        G() | 0;
        h = h & 127;
        b:
          do {
            if (!(la(h) | 0)) {
              if ((d2 | 0) > 0) {
                f = 0;
                do {
                  a2 = Nb(a2, c2) | 0;
                  c2 = G() | 0;
                  f = f + 1 | 0;
                } while ((f | 0) != (d2 | 0));
              }
            } else {
              c:
                do {
                  if ((Lb(a2, c2) | 0) == 1) {
                    if ((j | 0) != (h | 0)) {
                      if (ra(h, b[7728 + (j * 28 | 0) >> 2] | 0) | 0) {
                        a2 = Pb(a2, c2) | 0;
                        g2 = 1;
                        c2 = G() | 0;
                        break;
                      } else {
                        a2 = Nb(a2, c2) | 0;
                        g2 = 1;
                        c2 = G() | 0;
                        break;
                      }
                    }
                    switch (g2 | 0) {
                      case 5: {
                        a2 = Pb(a2, c2) | 0;
                        c2 = G() | 0;
                        b[e2 >> 2] = (b[e2 >> 2] | 0) + 5;
                        g2 = 0;
                        break c;
                      }
                      case 3: {
                        a2 = Nb(a2, c2) | 0;
                        c2 = G() | 0;
                        b[e2 >> 2] = (b[e2 >> 2] | 0) + 1;
                        g2 = 0;
                        break c;
                      }
                      default: {
                        n = 0;
                        o = 0;
                        F(n | 0);
                        return o | 0;
                      }
                    }
                  } else {
                    g2 = 0;
                  }
                } while (0);
              if ((d2 | 0) > 0) {
                f = 0;
                do {
                  a2 = Mb(a2, c2) | 0;
                  c2 = G() | 0;
                  f = f + 1 | 0;
                } while ((f | 0) != (d2 | 0));
              }
              if ((j | 0) != (h | 0)) {
                if (!(ma(h) | 0)) {
                  if ((g2 | 0) != 0 | (Lb(a2, c2) | 0) != 5) {
                    break;
                  }
                  b[e2 >> 2] = (b[e2 >> 2] | 0) + 1;
                  break;
                }
                switch (i2 & 127) {
                  case 8:
                  case 118:
                    break b;
                  default:
                }
                if ((Lb(a2, c2) | 0) != 3) {
                  b[e2 >> 2] = (b[e2 >> 2] | 0) + 1;
                }
              }
            }
          } while (0);
        b[e2 >> 2] = ((b[e2 >> 2] | 0) + d2 | 0) % 6 | 0;
        n = c2;
        o = a2;
        F(n | 0);
        return o | 0;
      }
      function ea(a2, c2, d2, e2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        var f = 0, g2 = 0, h = 0, i2 = 0, j = 0, k = 0, l = 0, m = 0;
        m = S;
        S = S + 16 | 0;
        l = m;
        if (!d2) {
          l = e2;
          b[l >> 2] = a2;
          b[l + 4 >> 2] = c2;
          l = 0;
          S = m;
          return l | 0;
        }
        b[l >> 2] = 0;
        a:
          do {
            if (!(Fb(a2, c2) | 0)) {
              g2 = (d2 | 0) > 0;
              if (g2) {
                f = 0;
                k = a2;
                do {
                  k = da(k, c2, 4, l) | 0;
                  c2 = G() | 0;
                  if ((k | 0) == 0 & (c2 | 0) == 0) {
                    a2 = 2;
                    break a;
                  }
                  f = f + 1 | 0;
                  if (Fb(k, c2) | 0) {
                    a2 = 1;
                    break a;
                  }
                } while ((f | 0) < (d2 | 0));
                j = e2;
                b[j >> 2] = k;
                b[j + 4 >> 2] = c2;
                j = d2 + -1 | 0;
                if (g2) {
                  g2 = 0;
                  h = 1;
                  f = k;
                  a2 = c2;
                  do {
                    f = da(f, a2, 2, l) | 0;
                    a2 = G() | 0;
                    if ((f | 0) == 0 & (a2 | 0) == 0) {
                      a2 = 2;
                      break a;
                    }
                    i2 = e2 + (h << 3) | 0;
                    b[i2 >> 2] = f;
                    b[i2 + 4 >> 2] = a2;
                    h = h + 1 | 0;
                    if (Fb(f, a2) | 0) {
                      a2 = 1;
                      break a;
                    }
                    g2 = g2 + 1 | 0;
                  } while ((g2 | 0) < (d2 | 0));
                  i2 = 0;
                  g2 = h;
                  do {
                    f = da(f, a2, 3, l) | 0;
                    a2 = G() | 0;
                    if ((f | 0) == 0 & (a2 | 0) == 0) {
                      a2 = 2;
                      break a;
                    }
                    h = e2 + (g2 << 3) | 0;
                    b[h >> 2] = f;
                    b[h + 4 >> 2] = a2;
                    g2 = g2 + 1 | 0;
                    if (Fb(f, a2) | 0) {
                      a2 = 1;
                      break a;
                    }
                    i2 = i2 + 1 | 0;
                  } while ((i2 | 0) < (d2 | 0));
                  h = 0;
                  do {
                    f = da(f, a2, 1, l) | 0;
                    a2 = G() | 0;
                    if ((f | 0) == 0 & (a2 | 0) == 0) {
                      a2 = 2;
                      break a;
                    }
                    i2 = e2 + (g2 << 3) | 0;
                    b[i2 >> 2] = f;
                    b[i2 + 4 >> 2] = a2;
                    g2 = g2 + 1 | 0;
                    if (Fb(f, a2) | 0) {
                      a2 = 1;
                      break a;
                    }
                    h = h + 1 | 0;
                  } while ((h | 0) < (d2 | 0));
                  h = 0;
                  do {
                    f = da(f, a2, 5, l) | 0;
                    a2 = G() | 0;
                    if ((f | 0) == 0 & (a2 | 0) == 0) {
                      a2 = 2;
                      break a;
                    }
                    i2 = e2 + (g2 << 3) | 0;
                    b[i2 >> 2] = f;
                    b[i2 + 4 >> 2] = a2;
                    g2 = g2 + 1 | 0;
                    if (Fb(f, a2) | 0) {
                      a2 = 1;
                      break a;
                    }
                    h = h + 1 | 0;
                  } while ((h | 0) < (d2 | 0));
                  h = 0;
                  do {
                    f = da(f, a2, 4, l) | 0;
                    a2 = G() | 0;
                    if ((f | 0) == 0 & (a2 | 0) == 0) {
                      a2 = 2;
                      break a;
                    }
                    i2 = e2 + (g2 << 3) | 0;
                    b[i2 >> 2] = f;
                    b[i2 + 4 >> 2] = a2;
                    g2 = g2 + 1 | 0;
                    if (Fb(f, a2) | 0) {
                      a2 = 1;
                      break a;
                    }
                    h = h + 1 | 0;
                  } while ((h | 0) < (d2 | 0));
                  h = 0;
                  while (1) {
                    f = da(f, a2, 6, l) | 0;
                    a2 = G() | 0;
                    if ((f | 0) == 0 & (a2 | 0) == 0) {
                      a2 = 2;
                      break a;
                    }
                    if ((h | 0) != (j | 0)) {
                      i2 = e2 + (g2 << 3) | 0;
                      b[i2 >> 2] = f;
                      b[i2 + 4 >> 2] = a2;
                      if (!(Fb(f, a2) | 0)) {
                        g2 = g2 + 1 | 0;
                      } else {
                        a2 = 1;
                        break a;
                      }
                    }
                    h = h + 1 | 0;
                    if ((h | 0) >= (d2 | 0)) {
                      h = k;
                      g2 = c2;
                      break;
                    }
                  }
                } else {
                  h = k;
                  f = k;
                  g2 = c2;
                  a2 = c2;
                }
              } else {
                h = e2;
                b[h >> 2] = a2;
                b[h + 4 >> 2] = c2;
                h = a2;
                f = a2;
                g2 = c2;
                a2 = c2;
              }
              a2 = ((h | 0) != (f | 0) | (g2 | 0) != (a2 | 0)) & 1;
            } else {
              a2 = 1;
            }
          } while (0);
        l = a2;
        S = m;
        return l | 0;
      }
      function fa(a2, c2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        var d2 = 0, e2 = 0, f = 0, g2 = 0, h = 0, i2 = 0;
        g2 = S;
        S = S + 48 | 0;
        f = g2 + 8 | 0;
        e2 = g2;
        i2 = a2;
        h = b[i2 + 4 >> 2] | 0;
        d2 = e2;
        b[d2 >> 2] = b[i2 >> 2];
        b[d2 + 4 >> 2] = h;
        vc(e2, f);
        f = ya(f, c2) | 0;
        c2 = b[e2 >> 2] | 0;
        e2 = b[a2 + 8 >> 2] | 0;
        if ((e2 | 0) <= 0) {
          i2 = c2;
          h = (f | 0) < (i2 | 0);
          i2 = h ? i2 : f;
          i2 = i2 + 12 | 0;
          S = g2;
          return i2 | 0;
        }
        d2 = b[a2 + 12 >> 2] | 0;
        a2 = 0;
        do {
          c2 = (b[d2 + (a2 << 3) >> 2] | 0) + c2 | 0;
          a2 = a2 + 1 | 0;
        } while ((a2 | 0) < (e2 | 0));
        i2 = (f | 0) < (c2 | 0);
        i2 = i2 ? c2 : f;
        i2 = i2 + 12 | 0;
        S = g2;
        return i2 | 0;
      }
      function ga(a2, c2, d2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        var e2 = 0, f = 0, g2 = 0, h = 0, i2 = 0, j = 0;
        i2 = S;
        S = S + 48 | 0;
        e2 = i2 + 8 | 0;
        f = i2;
        if (!(ha(a2, c2, d2) | 0)) {
          S = i2;
          return;
        }
        j = a2;
        g2 = b[j + 4 >> 2] | 0;
        h = f;
        b[h >> 2] = b[j >> 2];
        b[h + 4 >> 2] = g2;
        vc(f, e2);
        h = ya(e2, c2) | 0;
        c2 = b[f >> 2] | 0;
        g2 = b[a2 + 8 >> 2] | 0;
        if ((g2 | 0) > 0) {
          f = b[a2 + 12 >> 2] | 0;
          e2 = 0;
          do {
            c2 = (b[f + (e2 << 3) >> 2] | 0) + c2 | 0;
            e2 = e2 + 1 | 0;
          } while ((e2 | 0) != (g2 | 0));
        }
        c2 = (h | 0) < (c2 | 0) ? c2 : h;
        if ((c2 | 0) <= -12) {
          S = i2;
          return;
        }
        j = c2 + 11 | 0;
        hd(d2 | 0, 0, (((j | 0) > 0 ? j : 0) << 3) + 8 | 0) | 0;
        S = i2;
        return;
      }
      function ha(a2, c2, d2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        var e2 = 0, f = 0, g2 = 0, h = 0, i2 = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t2 = 0, u2 = 0, v2 = 0, w2 = 0, x3 = 0, y3 = 0, z2 = 0, A2 = 0, B2 = 0, C2 = 0, D2 = 0, E = 0, F2 = 0, I2 = 0, J2 = 0;
        J2 = S;
        S = S + 112 | 0;
        D2 = J2 + 80 | 0;
        j = J2 + 72 | 0;
        E = J2;
        F2 = J2 + 56 | 0;
        k = a2 + 8 | 0;
        I2 = Wc((b[k >> 2] << 5) + 32 | 0) | 0;
        if (!I2) {
          H(22848, 22448, 800, 22456);
        }
        wc(a2, I2);
        g2 = a2;
        e2 = b[g2 + 4 >> 2] | 0;
        i2 = j;
        b[i2 >> 2] = b[g2 >> 2];
        b[i2 + 4 >> 2] = e2;
        vc(j, D2);
        i2 = ya(D2, c2) | 0;
        e2 = b[j >> 2] | 0;
        g2 = b[k >> 2] | 0;
        if ((g2 | 0) > 0) {
          h = b[a2 + 12 >> 2] | 0;
          f = 0;
          do {
            e2 = (b[h + (f << 3) >> 2] | 0) + e2 | 0;
            f = f + 1 | 0;
          } while ((f | 0) != (g2 | 0));
        }
        i2 = (i2 | 0) < (e2 | 0) ? e2 : i2;
        C2 = i2 + 12 | 0;
        f = Yc(C2, 8) | 0;
        l = Yc(C2, 8) | 0;
        b[D2 >> 2] = 0;
        A2 = a2;
        B2 = b[A2 + 4 >> 2] | 0;
        e2 = j;
        b[e2 >> 2] = b[A2 >> 2];
        b[e2 + 4 >> 2] = B2;
        e2 = ia(j, C2, c2, D2, f, l) | 0;
        if (e2 | 0) {
          Xc(f);
          Xc(l);
          Xc(I2);
          I2 = e2;
          S = J2;
          return I2 | 0;
        }
        a:
          do {
            if ((b[k >> 2] | 0) > 0) {
              g2 = a2 + 12 | 0;
              e2 = 0;
              while (1) {
                h = ia((b[g2 >> 2] | 0) + (e2 << 3) | 0, C2, c2, D2, f, l) | 0;
                e2 = e2 + 1 | 0;
                if (h | 0) {
                  break;
                }
                if ((e2 | 0) >= (b[k >> 2] | 0)) {
                  break a;
                }
              }
              Xc(f);
              Xc(l);
              Xc(I2);
              I2 = h;
              S = J2;
              return I2 | 0;
            }
          } while (0);
        if ((i2 | 0) > -12) {
          hd(l | 0, 0, ((C2 | 0) > 1 ? C2 : 1) << 3 | 0) | 0;
        }
        b:
          do {
            if ((b[D2 >> 2] | 0) > 0) {
              B2 = ((C2 | 0) < 0) << 31 >> 31;
              v2 = f;
              w2 = l;
              x3 = f;
              y3 = f;
              z2 = l;
              A2 = f;
              e2 = f;
              r2 = f;
              s2 = l;
              t2 = l;
              u2 = l;
              f = l;
              c:
                while (1) {
                  q2 = b[D2 >> 2] | 0;
                  o = 0;
                  p2 = 0;
                  g2 = 0;
                  while (1) {
                    h = E;
                    i2 = h + 56 | 0;
                    do {
                      b[h >> 2] = 0;
                      h = h + 4 | 0;
                    } while ((h | 0) < (i2 | 0));
                    c2 = v2 + (o << 3) | 0;
                    j = b[c2 >> 2] | 0;
                    c2 = b[c2 + 4 >> 2] | 0;
                    if (ba(j, c2, 1, E, 0) | 0) {
                      h = E;
                      i2 = h + 56 | 0;
                      do {
                        b[h >> 2] = 0;
                        h = h + 4 | 0;
                      } while ((h | 0) < (i2 | 0));
                      h = Yc(7, 4) | 0;
                      if (h | 0) {
                        ca(j, c2, 1, E, h, 7, 0);
                        Xc(h);
                      }
                    }
                    n = 0;
                    do {
                      m = E + (n << 3) | 0;
                      l = b[m >> 2] | 0;
                      m = b[m + 4 >> 2] | 0;
                      d:
                        do {
                          if (!((l | 0) == 0 & (m | 0) == 0)) {
                            j = bd(l | 0, m | 0, C2 | 0, B2 | 0) | 0;
                            G() | 0;
                            h = d2 + (j << 3) | 0;
                            i2 = h;
                            c2 = b[i2 >> 2] | 0;
                            i2 = b[i2 + 4 >> 2] | 0;
                            if (!((c2 | 0) == 0 & (i2 | 0) == 0)) {
                              k = 0;
                              while (1) {
                                if ((k | 0) > (C2 | 0)) {
                                  break c;
                                }
                                if ((c2 | 0) == (l | 0) & (i2 | 0) == (m | 0)) {
                                  break d;
                                }
                                j = (j + 1 | 0) % (C2 | 0) | 0;
                                h = d2 + (j << 3) | 0;
                                i2 = h;
                                c2 = b[i2 >> 2] | 0;
                                i2 = b[i2 + 4 >> 2] | 0;
                                if ((c2 | 0) == 0 & (i2 | 0) == 0) {
                                  break;
                                } else {
                                  k = k + 1 | 0;
                                }
                              }
                            }
                            if (!((l | 0) == 0 & (m | 0) == 0)) {
                              Vb(l, m, F2);
                              if (xc(a2, I2, F2) | 0) {
                                k = h;
                                b[k >> 2] = l;
                                b[k + 4 >> 2] = m;
                                k = w2 + (g2 << 3) | 0;
                                b[k >> 2] = l;
                                b[k + 4 >> 2] = m;
                                g2 = g2 + 1 | 0;
                              }
                            }
                          }
                        } while (0);
                      n = n + 1 | 0;
                    } while (n >>> 0 < 7);
                    p2 = p2 + 1 | 0;
                    if ((p2 | 0) >= (q2 | 0)) {
                      break;
                    } else {
                      o = o + 1 | 0;
                    }
                  }
                  if ((q2 | 0) > 0) {
                    hd(x3 | 0, 0, q2 << 3 | 0) | 0;
                  }
                  b[D2 >> 2] = g2;
                  if ((g2 | 0) > 0) {
                    l = f;
                    m = u2;
                    n = A2;
                    o = t2;
                    p2 = s2;
                    q2 = w2;
                    f = r2;
                    u2 = e2;
                    t2 = y3;
                    s2 = x3;
                    r2 = l;
                    e2 = m;
                    A2 = z2;
                    z2 = n;
                    y3 = o;
                    x3 = p2;
                    w2 = v2;
                    v2 = q2;
                  } else {
                    break b;
                  }
                }
              Xc(y3);
              Xc(z2);
              Xc(I2);
              I2 = -1;
              S = J2;
              return I2 | 0;
            } else {
              e2 = l;
            }
          } while (0);
        Xc(I2);
        Xc(f);
        Xc(e2);
        I2 = 0;
        S = J2;
        return I2 | 0;
      }
      function ia(a2, c2, d2, f, g2, h) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        f = f | 0;
        g2 = g2 | 0;
        h = h | 0;
        var i2 = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t2 = 0, u2 = 0, v2 = 0, w2 = 0, x3 = 0, y3 = 0, z2 = 0, A2 = 0, B2 = 0, C2 = 0, D2 = 0, E = 0;
        C2 = S;
        S = S + 48 | 0;
        y3 = C2 + 32 | 0;
        z2 = C2 + 16 | 0;
        A2 = C2;
        i2 = b[a2 >> 2] | 0;
        if ((i2 | 0) <= 0) {
          B2 = 0;
          S = C2;
          return B2 | 0;
        }
        t2 = a2 + 4 | 0;
        u2 = y3 + 8 | 0;
        v2 = z2 + 8 | 0;
        w2 = A2 + 8 | 0;
        x3 = ((c2 | 0) < 0) << 31 >> 31;
        s2 = 0;
        a:
          while (1) {
            j = b[t2 >> 2] | 0;
            q2 = j + (s2 << 4) | 0;
            b[y3 >> 2] = b[q2 >> 2];
            b[y3 + 4 >> 2] = b[q2 + 4 >> 2];
            b[y3 + 8 >> 2] = b[q2 + 8 >> 2];
            b[y3 + 12 >> 2] = b[q2 + 12 >> 2];
            if ((s2 | 0) == (i2 + -1 | 0)) {
              b[z2 >> 2] = b[j >> 2];
              b[z2 + 4 >> 2] = b[j + 4 >> 2];
              b[z2 + 8 >> 2] = b[j + 8 >> 2];
              b[z2 + 12 >> 2] = b[j + 12 >> 2];
            } else {
              q2 = j + (s2 + 1 << 4) | 0;
              b[z2 >> 2] = b[q2 >> 2];
              b[z2 + 4 >> 2] = b[q2 + 4 >> 2];
              b[z2 + 8 >> 2] = b[q2 + 8 >> 2];
              b[z2 + 12 >> 2] = b[q2 + 12 >> 2];
            }
            q2 = za(y3, z2, d2) | 0;
            b:
              do {
                if ((q2 | 0) > 0) {
                  r2 = +(q2 | 0);
                  p2 = 0;
                  c:
                    while (1) {
                      E = +(q2 - p2 | 0);
                      D2 = +(p2 | 0);
                      e[A2 >> 3] = +e[y3 >> 3] * E / r2 + +e[z2 >> 3] * D2 / r2;
                      e[w2 >> 3] = +e[u2 >> 3] * E / r2 + +e[v2 >> 3] * D2 / r2;
                      n = Sb(A2, d2) | 0;
                      o = G() | 0;
                      j = bd(n | 0, o | 0, c2 | 0, x3 | 0) | 0;
                      G() | 0;
                      i2 = h + (j << 3) | 0;
                      k = i2;
                      l = b[k >> 2] | 0;
                      k = b[k + 4 >> 2] | 0;
                      d:
                        do {
                          if ((l | 0) == 0 & (k | 0) == 0) {
                            B2 = 14;
                          } else {
                            m = 0;
                            while (1) {
                              if ((m | 0) > (c2 | 0)) {
                                i2 = 1;
                                break d;
                              }
                              if ((l | 0) == (n | 0) & (k | 0) == (o | 0)) {
                                i2 = 7;
                                break d;
                              }
                              j = (j + 1 | 0) % (c2 | 0) | 0;
                              i2 = h + (j << 3) | 0;
                              k = i2;
                              l = b[k >> 2] | 0;
                              k = b[k + 4 >> 2] | 0;
                              if ((l | 0) == 0 & (k | 0) == 0) {
                                B2 = 14;
                                break;
                              } else {
                                m = m + 1 | 0;
                              }
                            }
                          }
                        } while (0);
                      if ((B2 | 0) == 14) {
                        B2 = 0;
                        if ((n | 0) == 0 & (o | 0) == 0) {
                          i2 = 7;
                        } else {
                          b[i2 >> 2] = n;
                          b[i2 + 4 >> 2] = o;
                          i2 = b[f >> 2] | 0;
                          m = g2 + (i2 << 3) | 0;
                          b[m >> 2] = n;
                          b[m + 4 >> 2] = o;
                          b[f >> 2] = i2 + 1;
                          i2 = 0;
                        }
                      }
                      switch (i2 & 7) {
                        case 7:
                        case 0:
                          break;
                        default:
                          break c;
                      }
                      p2 = p2 + 1 | 0;
                      if ((q2 | 0) <= (p2 | 0)) {
                        B2 = 8;
                        break b;
                      }
                    }
                  if (i2 | 0) {
                    i2 = -1;
                    B2 = 20;
                    break a;
                  }
                } else {
                  B2 = 8;
                }
              } while (0);
            if ((B2 | 0) == 8) {
              B2 = 0;
            }
            s2 = s2 + 1 | 0;
            i2 = b[a2 >> 2] | 0;
            if ((s2 | 0) >= (i2 | 0)) {
              i2 = 0;
              B2 = 20;
              break;
            }
          }
        if ((B2 | 0) == 20) {
          S = C2;
          return i2 | 0;
        }
        return 0;
      }
      function ja(a2, c2, d2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        var e2 = 0, f = 0, g2 = 0, h = 0, i2 = 0, j = 0, k = 0;
        k = S;
        S = S + 176 | 0;
        j = k;
        if ((c2 | 0) < 1) {
          Mc(d2, 0, 0);
          S = k;
          return;
        }
        h = a2;
        h = cd(b[h >> 2] | 0, b[h + 4 >> 2] | 0, 52) | 0;
        G() | 0;
        Mc(d2, (c2 | 0) > 6 ? c2 : 6, h & 15);
        h = 0;
        do {
          e2 = a2 + (h << 3) | 0;
          Wb(b[e2 >> 2] | 0, b[e2 + 4 >> 2] | 0, j);
          e2 = b[j >> 2] | 0;
          if ((e2 | 0) > 0) {
            i2 = 0;
            do {
              g2 = j + 8 + (i2 << 4) | 0;
              i2 = i2 + 1 | 0;
              e2 = j + 8 + (((i2 | 0) % (e2 | 0) | 0) << 4) | 0;
              f = Rc(d2, e2, g2) | 0;
              if (!f) {
                Qc(d2, g2, e2) | 0;
              } else {
                Pc(d2, f) | 0;
              }
              e2 = b[j >> 2] | 0;
            } while ((i2 | 0) < (e2 | 0));
          }
          h = h + 1 | 0;
        } while ((h | 0) != (c2 | 0));
        S = k;
        return;
      }
      function ka(a2, c2, d2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        var e2 = 0, f = 0, g2 = 0, h = 0;
        g2 = S;
        S = S + 32 | 0;
        e2 = g2;
        f = g2 + 16 | 0;
        ja(a2, c2, f);
        b[d2 >> 2] = 0;
        b[d2 + 4 >> 2] = 0;
        b[d2 + 8 >> 2] = 0;
        a2 = Oc(f) | 0;
        if (!a2) {
          kc(d2) | 0;
          Nc(f);
          S = g2;
          return;
        }
        do {
          c2 = hc(d2) | 0;
          do {
            ic(c2, a2) | 0;
            h = a2 + 16 | 0;
            b[e2 >> 2] = b[h >> 2];
            b[e2 + 4 >> 2] = b[h + 4 >> 2];
            b[e2 + 8 >> 2] = b[h + 8 >> 2];
            b[e2 + 12 >> 2] = b[h + 12 >> 2];
            Pc(f, a2) | 0;
            a2 = Sc(f, e2) | 0;
          } while ((a2 | 0) != 0);
          a2 = Oc(f) | 0;
        } while ((a2 | 0) != 0);
        kc(d2) | 0;
        Nc(f);
        S = g2;
        return;
      }
      function la(a2) {
        a2 = a2 | 0;
        return b[7728 + (a2 * 28 | 0) + 16 >> 2] | 0;
      }
      function ma(a2) {
        a2 = a2 | 0;
        return (a2 | 0) == 4 | (a2 | 0) == 117 | 0;
      }
      function na(a2) {
        a2 = a2 | 0;
        return b[11152 + ((b[a2 >> 2] | 0) * 216 | 0) + ((b[a2 + 4 >> 2] | 0) * 72 | 0) + ((b[a2 + 8 >> 2] | 0) * 24 | 0) + (b[a2 + 12 >> 2] << 3) >> 2] | 0;
      }
      function oa(a2) {
        a2 = a2 | 0;
        return b[11152 + ((b[a2 >> 2] | 0) * 216 | 0) + ((b[a2 + 4 >> 2] | 0) * 72 | 0) + ((b[a2 + 8 >> 2] | 0) * 24 | 0) + (b[a2 + 12 >> 2] << 3) + 4 >> 2] | 0;
      }
      function pa(a2, c2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        a2 = 7728 + (a2 * 28 | 0) | 0;
        b[c2 >> 2] = b[a2 >> 2];
        b[c2 + 4 >> 2] = b[a2 + 4 >> 2];
        b[c2 + 8 >> 2] = b[a2 + 8 >> 2];
        b[c2 + 12 >> 2] = b[a2 + 12 >> 2];
        return;
      }
      function qa(a2, c2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        var d2 = 0, e2 = 0;
        if (c2 >>> 0 > 20) {
          c2 = -1;
          return c2 | 0;
        }
        do {
          if ((b[11152 + (c2 * 216 | 0) >> 2] | 0) != (a2 | 0)) {
            if ((b[11152 + (c2 * 216 | 0) + 8 >> 2] | 0) != (a2 | 0)) {
              if ((b[11152 + (c2 * 216 | 0) + 16 >> 2] | 0) != (a2 | 0)) {
                if ((b[11152 + (c2 * 216 | 0) + 24 >> 2] | 0) != (a2 | 0)) {
                  if ((b[11152 + (c2 * 216 | 0) + 32 >> 2] | 0) != (a2 | 0)) {
                    if ((b[11152 + (c2 * 216 | 0) + 40 >> 2] | 0) != (a2 | 0)) {
                      if ((b[11152 + (c2 * 216 | 0) + 48 >> 2] | 0) != (a2 | 0)) {
                        if ((b[11152 + (c2 * 216 | 0) + 56 >> 2] | 0) != (a2 | 0)) {
                          if ((b[11152 + (c2 * 216 | 0) + 64 >> 2] | 0) != (a2 | 0)) {
                            if ((b[11152 + (c2 * 216 | 0) + 72 >> 2] | 0) != (a2 | 0)) {
                              if ((b[11152 + (c2 * 216 | 0) + 80 >> 2] | 0) != (a2 | 0)) {
                                if ((b[11152 + (c2 * 216 | 0) + 88 >> 2] | 0) != (a2 | 0)) {
                                  if ((b[11152 + (c2 * 216 | 0) + 96 >> 2] | 0) != (a2 | 0)) {
                                    if ((b[11152 + (c2 * 216 | 0) + 104 >> 2] | 0) != (a2 | 0)) {
                                      if ((b[11152 + (c2 * 216 | 0) + 112 >> 2] | 0) != (a2 | 0)) {
                                        if ((b[11152 + (c2 * 216 | 0) + 120 >> 2] | 0) != (a2 | 0)) {
                                          if ((b[11152 + (c2 * 216 | 0) + 128 >> 2] | 0) != (a2 | 0)) {
                                            if ((b[11152 + (c2 * 216 | 0) + 136 >> 2] | 0) == (a2 | 0)) {
                                              a2 = 2;
                                              d2 = 1;
                                              e2 = 2;
                                            } else {
                                              if ((b[11152 + (c2 * 216 | 0) + 144 >> 2] | 0) == (a2 | 0)) {
                                                a2 = 0;
                                                d2 = 2;
                                                e2 = 0;
                                                break;
                                              }
                                              if ((b[11152 + (c2 * 216 | 0) + 152 >> 2] | 0) == (a2 | 0)) {
                                                a2 = 0;
                                                d2 = 2;
                                                e2 = 1;
                                                break;
                                              }
                                              if ((b[11152 + (c2 * 216 | 0) + 160 >> 2] | 0) == (a2 | 0)) {
                                                a2 = 0;
                                                d2 = 2;
                                                e2 = 2;
                                                break;
                                              }
                                              if ((b[11152 + (c2 * 216 | 0) + 168 >> 2] | 0) == (a2 | 0)) {
                                                a2 = 1;
                                                d2 = 2;
                                                e2 = 0;
                                                break;
                                              }
                                              if ((b[11152 + (c2 * 216 | 0) + 176 >> 2] | 0) == (a2 | 0)) {
                                                a2 = 1;
                                                d2 = 2;
                                                e2 = 1;
                                                break;
                                              }
                                              if ((b[11152 + (c2 * 216 | 0) + 184 >> 2] | 0) == (a2 | 0)) {
                                                a2 = 1;
                                                d2 = 2;
                                                e2 = 2;
                                                break;
                                              }
                                              if ((b[11152 + (c2 * 216 | 0) + 192 >> 2] | 0) == (a2 | 0)) {
                                                a2 = 2;
                                                d2 = 2;
                                                e2 = 0;
                                                break;
                                              }
                                              if ((b[11152 + (c2 * 216 | 0) + 200 >> 2] | 0) == (a2 | 0)) {
                                                a2 = 2;
                                                d2 = 2;
                                                e2 = 1;
                                                break;
                                              }
                                              if ((b[11152 + (c2 * 216 | 0) + 208 >> 2] | 0) == (a2 | 0)) {
                                                a2 = 2;
                                                d2 = 2;
                                                e2 = 2;
                                                break;
                                              } else {
                                                a2 = -1;
                                              }
                                              return a2 | 0;
                                            }
                                          } else {
                                            a2 = 2;
                                            d2 = 1;
                                            e2 = 1;
                                          }
                                        } else {
                                          a2 = 2;
                                          d2 = 1;
                                          e2 = 0;
                                        }
                                      } else {
                                        a2 = 1;
                                        d2 = 1;
                                        e2 = 2;
                                      }
                                    } else {
                                      a2 = 1;
                                      d2 = 1;
                                      e2 = 1;
                                    }
                                  } else {
                                    a2 = 1;
                                    d2 = 1;
                                    e2 = 0;
                                  }
                                } else {
                                  a2 = 0;
                                  d2 = 1;
                                  e2 = 2;
                                }
                              } else {
                                a2 = 0;
                                d2 = 1;
                                e2 = 1;
                              }
                            } else {
                              a2 = 0;
                              d2 = 1;
                              e2 = 0;
                            }
                          } else {
                            a2 = 2;
                            d2 = 0;
                            e2 = 2;
                          }
                        } else {
                          a2 = 2;
                          d2 = 0;
                          e2 = 1;
                        }
                      } else {
                        a2 = 2;
                        d2 = 0;
                        e2 = 0;
                      }
                    } else {
                      a2 = 1;
                      d2 = 0;
                      e2 = 2;
                    }
                  } else {
                    a2 = 1;
                    d2 = 0;
                    e2 = 1;
                  }
                } else {
                  a2 = 1;
                  d2 = 0;
                  e2 = 0;
                }
              } else {
                a2 = 0;
                d2 = 0;
                e2 = 2;
              }
            } else {
              a2 = 0;
              d2 = 0;
              e2 = 1;
            }
          } else {
            a2 = 0;
            d2 = 0;
            e2 = 0;
          }
        } while (0);
        c2 = b[11152 + (c2 * 216 | 0) + (d2 * 72 | 0) + (a2 * 24 | 0) + (e2 << 3) + 4 >> 2] | 0;
        return c2 | 0;
      }
      function ra(a2, c2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        if ((b[7728 + (a2 * 28 | 0) + 20 >> 2] | 0) == (c2 | 0)) {
          c2 = 1;
          return c2 | 0;
        }
        c2 = (b[7728 + (a2 * 28 | 0) + 24 >> 2] | 0) == (c2 | 0);
        return c2 | 0;
      }
      function sa(a2, c2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        return b[880 + (a2 * 28 | 0) + (c2 << 2) >> 2] | 0;
      }
      function ta(a2, c2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        if ((b[880 + (a2 * 28 | 0) >> 2] | 0) == (c2 | 0)) {
          c2 = 0;
          return c2 | 0;
        }
        if ((b[880 + (a2 * 28 | 0) + 4 >> 2] | 0) == (c2 | 0)) {
          c2 = 1;
          return c2 | 0;
        }
        if ((b[880 + (a2 * 28 | 0) + 8 >> 2] | 0) == (c2 | 0)) {
          c2 = 2;
          return c2 | 0;
        }
        if ((b[880 + (a2 * 28 | 0) + 12 >> 2] | 0) == (c2 | 0)) {
          c2 = 3;
          return c2 | 0;
        }
        if ((b[880 + (a2 * 28 | 0) + 16 >> 2] | 0) == (c2 | 0)) {
          c2 = 4;
          return c2 | 0;
        }
        if ((b[880 + (a2 * 28 | 0) + 20 >> 2] | 0) == (c2 | 0)) {
          c2 = 5;
          return c2 | 0;
        } else {
          return ((b[880 + (a2 * 28 | 0) + 24 >> 2] | 0) == (c2 | 0) ? 6 : 7) | 0;
        }
        return 0;
      }
      function ua() {
        return 122;
      }
      function va(a2) {
        a2 = a2 | 0;
        var c2 = 0, d2 = 0, e2 = 0;
        c2 = 0;
        do {
          dd(c2 | 0, 0, 45) | 0;
          e2 = G() | 0 | 134225919;
          d2 = a2 + (c2 << 3) | 0;
          b[d2 >> 2] = -1;
          b[d2 + 4 >> 2] = e2;
          c2 = c2 + 1 | 0;
        } while ((c2 | 0) != 122);
        return;
      }
      function wa(a2) {
        a2 = a2 | 0;
        return +e[a2 + 16 >> 3] < +e[a2 + 24 >> 3] | 0;
      }
      function xa(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        var c2 = 0, d2 = 0, f = 0;
        c2 = +e[b2 >> 3];
        if (!(c2 >= +e[a2 + 8 >> 3])) {
          b2 = 0;
          return b2 | 0;
        }
        if (!(c2 <= +e[a2 >> 3])) {
          b2 = 0;
          return b2 | 0;
        }
        d2 = +e[a2 + 16 >> 3];
        c2 = +e[a2 + 24 >> 3];
        f = +e[b2 + 8 >> 3];
        b2 = f >= c2;
        a2 = f <= d2 & 1;
        if (d2 < c2) {
          if (b2) {
            a2 = 1;
          }
        } else if (!b2) {
          a2 = 0;
        }
        b2 = (a2 | 0) != 0;
        return b2 | 0;
      }
      function ya(a2, c2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        var d2 = 0, f = 0, g2 = 0, h = 0, i2 = 0, j = 0, k = 0, l = 0;
        i2 = S;
        S = S + 288 | 0;
        d2 = i2 + 264 | 0;
        f = i2 + 96 | 0;
        g2 = i2;
        h = g2;
        j = h + 96 | 0;
        do {
          b[h >> 2] = 0;
          h = h + 4 | 0;
        } while ((h | 0) < (j | 0));
        _b(c2, g2);
        h = g2;
        j = b[h >> 2] | 0;
        h = b[h + 4 >> 2] | 0;
        Vb(j, h, d2);
        Wb(j, h, f);
        k = +jb(d2, f + 8 | 0);
        e[d2 >> 3] = +e[a2 >> 3];
        h = d2 + 8 | 0;
        e[h >> 3] = +e[a2 + 16 >> 3];
        e[f >> 3] = +e[a2 + 8 >> 3];
        j = f + 8 | 0;
        e[j >> 3] = +e[a2 + 24 >> 3];
        l = +jb(d2, f);
        j = ~~+A(+(l * l / +ed(+ +q(+((+e[h >> 3] - +e[j >> 3]) / (+e[d2 >> 3] - +e[f >> 3]))), 3) / (k * (k * 2.59807621135) * 0.8)));
        S = i2;
        return ((j | 0) == 0 ? 1 : j) | 0;
      }
      function za(a2, c2, d2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        var e2 = 0, f = 0, g2 = 0, h = 0, i2 = 0, j = 0, k = 0;
        i2 = S;
        S = S + 288 | 0;
        e2 = i2 + 264 | 0;
        f = i2 + 96 | 0;
        g2 = i2;
        h = g2;
        j = h + 96 | 0;
        do {
          b[h >> 2] = 0;
          h = h + 4 | 0;
        } while ((h | 0) < (j | 0));
        _b(d2, g2);
        j = g2;
        h = b[j >> 2] | 0;
        j = b[j + 4 >> 2] | 0;
        Vb(h, j, e2);
        Wb(h, j, f);
        k = +jb(e2, f + 8 | 0);
        j = ~~+A(+(+jb(a2, c2) / (k * 2)));
        S = i2;
        return ((j | 0) == 0 ? 1 : j) | 0;
      }
      function Aa(a2, c2, d2, e2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        b[a2 >> 2] = c2;
        b[a2 + 4 >> 2] = d2;
        b[a2 + 8 >> 2] = e2;
        return;
      }
      function Ba(a2, c2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        var d2 = 0, f = 0, g2 = 0, h = 0, i2 = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0;
        n = c2 + 8 | 0;
        b[n >> 2] = 0;
        k = +e[a2 >> 3];
        i2 = +q(+k);
        l = +e[a2 + 8 >> 3];
        j = +q(+l) / 0.8660254037844386;
        i2 = i2 + j * 0.5;
        d2 = ~~i2;
        a2 = ~~j;
        i2 = i2 - +(d2 | 0);
        j = j - +(a2 | 0);
        do {
          if (i2 < 0.5) {
            if (i2 < 0.3333333333333333) {
              b[c2 >> 2] = d2;
              if (j < (i2 + 1) * 0.5) {
                b[c2 + 4 >> 2] = a2;
                break;
              } else {
                a2 = a2 + 1 | 0;
                b[c2 + 4 >> 2] = a2;
                break;
              }
            } else {
              o = 1 - i2;
              a2 = (!(j < o) & 1) + a2 | 0;
              b[c2 + 4 >> 2] = a2;
              if (o <= j & j < i2 * 2) {
                d2 = d2 + 1 | 0;
                b[c2 >> 2] = d2;
                break;
              } else {
                b[c2 >> 2] = d2;
                break;
              }
            }
          } else {
            if (!(i2 < 0.6666666666666666)) {
              d2 = d2 + 1 | 0;
              b[c2 >> 2] = d2;
              if (j < i2 * 0.5) {
                b[c2 + 4 >> 2] = a2;
                break;
              } else {
                a2 = a2 + 1 | 0;
                b[c2 + 4 >> 2] = a2;
                break;
              }
            }
            if (j < 1 - i2) {
              b[c2 + 4 >> 2] = a2;
              if (i2 * 2 + -1 < j) {
                b[c2 >> 2] = d2;
                break;
              }
            } else {
              a2 = a2 + 1 | 0;
              b[c2 + 4 >> 2] = a2;
            }
            d2 = d2 + 1 | 0;
            b[c2 >> 2] = d2;
          }
        } while (0);
        do {
          if (k < 0) {
            if (!(a2 & 1)) {
              m = (a2 | 0) / 2 | 0;
              m = _c(d2 | 0, ((d2 | 0) < 0) << 31 >> 31 | 0, m | 0, ((m | 0) < 0) << 31 >> 31 | 0) | 0;
              d2 = ~~(+(d2 | 0) - (+(m >>> 0) + 4294967296 * +(G() | 0)) * 2);
              b[c2 >> 2] = d2;
              break;
            } else {
              m = (a2 + 1 | 0) / 2 | 0;
              m = _c(d2 | 0, ((d2 | 0) < 0) << 31 >> 31 | 0, m | 0, ((m | 0) < 0) << 31 >> 31 | 0) | 0;
              d2 = ~~(+(d2 | 0) - ((+(m >>> 0) + 4294967296 * +(G() | 0)) * 2 + 1));
              b[c2 >> 2] = d2;
              break;
            }
          }
        } while (0);
        m = c2 + 4 | 0;
        if (l < 0) {
          d2 = d2 - ((a2 << 1 | 1 | 0) / 2 | 0) | 0;
          b[c2 >> 2] = d2;
          a2 = 0 - a2 | 0;
          b[m >> 2] = a2;
        }
        f = a2 - d2 | 0;
        if ((d2 | 0) < 0) {
          g2 = 0 - d2 | 0;
          b[m >> 2] = f;
          b[n >> 2] = g2;
          b[c2 >> 2] = 0;
          a2 = f;
          d2 = 0;
        } else {
          g2 = 0;
        }
        if ((a2 | 0) < 0) {
          d2 = d2 - a2 | 0;
          b[c2 >> 2] = d2;
          g2 = g2 - a2 | 0;
          b[n >> 2] = g2;
          b[m >> 2] = 0;
          a2 = 0;
        }
        h = d2 - g2 | 0;
        f = a2 - g2 | 0;
        if ((g2 | 0) < 0) {
          b[c2 >> 2] = h;
          b[m >> 2] = f;
          b[n >> 2] = 0;
          a2 = f;
          d2 = h;
          g2 = 0;
        }
        f = (a2 | 0) < (d2 | 0) ? a2 : d2;
        f = (g2 | 0) < (f | 0) ? g2 : f;
        if ((f | 0) <= 0) {
          return;
        }
        b[c2 >> 2] = d2 - f;
        b[m >> 2] = a2 - f;
        b[n >> 2] = g2 - f;
        return;
      }
      function Ca(a2) {
        a2 = a2 | 0;
        var c2 = 0, d2 = 0, e2 = 0, f = 0, g2 = 0, h = 0;
        c2 = b[a2 >> 2] | 0;
        h = a2 + 4 | 0;
        d2 = b[h >> 2] | 0;
        if ((c2 | 0) < 0) {
          d2 = d2 - c2 | 0;
          b[h >> 2] = d2;
          g2 = a2 + 8 | 0;
          b[g2 >> 2] = (b[g2 >> 2] | 0) - c2;
          b[a2 >> 2] = 0;
          c2 = 0;
        }
        if ((d2 | 0) < 0) {
          c2 = c2 - d2 | 0;
          b[a2 >> 2] = c2;
          g2 = a2 + 8 | 0;
          f = (b[g2 >> 2] | 0) - d2 | 0;
          b[g2 >> 2] = f;
          b[h >> 2] = 0;
          d2 = 0;
        } else {
          f = a2 + 8 | 0;
          g2 = f;
          f = b[f >> 2] | 0;
        }
        if ((f | 0) < 0) {
          c2 = c2 - f | 0;
          b[a2 >> 2] = c2;
          d2 = d2 - f | 0;
          b[h >> 2] = d2;
          b[g2 >> 2] = 0;
          f = 0;
        }
        e2 = (d2 | 0) < (c2 | 0) ? d2 : c2;
        e2 = (f | 0) < (e2 | 0) ? f : e2;
        if ((e2 | 0) <= 0) {
          return;
        }
        b[a2 >> 2] = c2 - e2;
        b[h >> 2] = d2 - e2;
        b[g2 >> 2] = f - e2;
        return;
      }
      function Da(a2, c2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        var d2 = 0, f = 0;
        f = b[a2 + 8 >> 2] | 0;
        d2 = +((b[a2 + 4 >> 2] | 0) - f | 0);
        e[c2 >> 3] = +((b[a2 >> 2] | 0) - f | 0) - d2 * 0.5;
        e[c2 + 8 >> 3] = d2 * 0.8660254037844386;
        return;
      }
      function Ea(a2, c2, d2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        b[d2 >> 2] = (b[c2 >> 2] | 0) + (b[a2 >> 2] | 0);
        b[d2 + 4 >> 2] = (b[c2 + 4 >> 2] | 0) + (b[a2 + 4 >> 2] | 0);
        b[d2 + 8 >> 2] = (b[c2 + 8 >> 2] | 0) + (b[a2 + 8 >> 2] | 0);
        return;
      }
      function Fa(a2, c2, d2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        b[d2 >> 2] = (b[a2 >> 2] | 0) - (b[c2 >> 2] | 0);
        b[d2 + 4 >> 2] = (b[a2 + 4 >> 2] | 0) - (b[c2 + 4 >> 2] | 0);
        b[d2 + 8 >> 2] = (b[a2 + 8 >> 2] | 0) - (b[c2 + 8 >> 2] | 0);
        return;
      }
      function Ga(a2, c2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        var d2 = 0, e2 = 0;
        d2 = B(b[a2 >> 2] | 0, c2) | 0;
        b[a2 >> 2] = d2;
        d2 = a2 + 4 | 0;
        e2 = B(b[d2 >> 2] | 0, c2) | 0;
        b[d2 >> 2] = e2;
        a2 = a2 + 8 | 0;
        c2 = B(b[a2 >> 2] | 0, c2) | 0;
        b[a2 >> 2] = c2;
        return;
      }
      function Ha(a2) {
        a2 = a2 | 0;
        var c2 = 0, d2 = 0, e2 = 0, f = 0, g2 = 0, h = 0, i2 = 0;
        h = b[a2 >> 2] | 0;
        i2 = (h | 0) < 0;
        e2 = (b[a2 + 4 >> 2] | 0) - (i2 ? h : 0) | 0;
        g2 = (e2 | 0) < 0;
        f = (g2 ? 0 - e2 | 0 : 0) + ((b[a2 + 8 >> 2] | 0) - (i2 ? h : 0)) | 0;
        d2 = (f | 0) < 0;
        a2 = d2 ? 0 : f;
        c2 = (g2 ? 0 : e2) - (d2 ? f : 0) | 0;
        f = (i2 ? 0 : h) - (g2 ? e2 : 0) - (d2 ? f : 0) | 0;
        d2 = (c2 | 0) < (f | 0) ? c2 : f;
        d2 = (a2 | 0) < (d2 | 0) ? a2 : d2;
        e2 = (d2 | 0) > 0;
        a2 = a2 - (e2 ? d2 : 0) | 0;
        c2 = c2 - (e2 ? d2 : 0) | 0;
        a:
          do {
            switch (f - (e2 ? d2 : 0) | 0) {
              case 0:
                switch (c2 | 0) {
                  case 0: {
                    i2 = (a2 | 0) == 0 ? 0 : (a2 | 0) == 1 ? 1 : 7;
                    return i2 | 0;
                  }
                  case 1: {
                    i2 = (a2 | 0) == 0 ? 2 : (a2 | 0) == 1 ? 3 : 7;
                    return i2 | 0;
                  }
                  default:
                    break a;
                }
              case 1:
                switch (c2 | 0) {
                  case 0: {
                    i2 = (a2 | 0) == 0 ? 4 : (a2 | 0) == 1 ? 5 : 7;
                    return i2 | 0;
                  }
                  case 1: {
                    if (!a2) {
                      a2 = 6;
                    } else {
                      break a;
                    }
                    return a2 | 0;
                  }
                  default:
                    break a;
                }
              default:
            }
          } while (0);
        i2 = 7;
        return i2 | 0;
      }
      function Ia(a2) {
        a2 = a2 | 0;
        var c2 = 0, d2 = 0, e2 = 0, f = 0, g2 = 0, h = 0, i2 = 0;
        h = a2 + 8 | 0;
        d2 = b[h >> 2] | 0;
        c2 = (b[a2 >> 2] | 0) - d2 | 0;
        i2 = a2 + 4 | 0;
        d2 = (b[i2 >> 2] | 0) - d2 | 0;
        e2 = Vc(+((c2 * 3 | 0) - d2 | 0) / 7) | 0;
        b[a2 >> 2] = e2;
        c2 = Vc(+((d2 << 1) + c2 | 0) / 7) | 0;
        b[i2 >> 2] = c2;
        b[h >> 2] = 0;
        d2 = c2 - e2 | 0;
        if ((e2 | 0) < 0) {
          g2 = 0 - e2 | 0;
          b[i2 >> 2] = d2;
          b[h >> 2] = g2;
          b[a2 >> 2] = 0;
          c2 = d2;
          e2 = 0;
          d2 = g2;
        } else {
          d2 = 0;
        }
        if ((c2 | 0) < 0) {
          e2 = e2 - c2 | 0;
          b[a2 >> 2] = e2;
          d2 = d2 - c2 | 0;
          b[h >> 2] = d2;
          b[i2 >> 2] = 0;
          c2 = 0;
        }
        g2 = e2 - d2 | 0;
        f = c2 - d2 | 0;
        if ((d2 | 0) < 0) {
          b[a2 >> 2] = g2;
          b[i2 >> 2] = f;
          b[h >> 2] = 0;
          c2 = f;
          f = g2;
          d2 = 0;
        } else {
          f = e2;
        }
        e2 = (c2 | 0) < (f | 0) ? c2 : f;
        e2 = (d2 | 0) < (e2 | 0) ? d2 : e2;
        if ((e2 | 0) <= 0) {
          return;
        }
        b[a2 >> 2] = f - e2;
        b[i2 >> 2] = c2 - e2;
        b[h >> 2] = d2 - e2;
        return;
      }
      function Ja(a2) {
        a2 = a2 | 0;
        var c2 = 0, d2 = 0, e2 = 0, f = 0, g2 = 0, h = 0, i2 = 0;
        h = a2 + 8 | 0;
        d2 = b[h >> 2] | 0;
        c2 = (b[a2 >> 2] | 0) - d2 | 0;
        i2 = a2 + 4 | 0;
        d2 = (b[i2 >> 2] | 0) - d2 | 0;
        e2 = Vc(+((c2 << 1) + d2 | 0) / 7) | 0;
        b[a2 >> 2] = e2;
        c2 = Vc(+((d2 * 3 | 0) - c2 | 0) / 7) | 0;
        b[i2 >> 2] = c2;
        b[h >> 2] = 0;
        d2 = c2 - e2 | 0;
        if ((e2 | 0) < 0) {
          g2 = 0 - e2 | 0;
          b[i2 >> 2] = d2;
          b[h >> 2] = g2;
          b[a2 >> 2] = 0;
          c2 = d2;
          e2 = 0;
          d2 = g2;
        } else {
          d2 = 0;
        }
        if ((c2 | 0) < 0) {
          e2 = e2 - c2 | 0;
          b[a2 >> 2] = e2;
          d2 = d2 - c2 | 0;
          b[h >> 2] = d2;
          b[i2 >> 2] = 0;
          c2 = 0;
        }
        g2 = e2 - d2 | 0;
        f = c2 - d2 | 0;
        if ((d2 | 0) < 0) {
          b[a2 >> 2] = g2;
          b[i2 >> 2] = f;
          b[h >> 2] = 0;
          c2 = f;
          f = g2;
          d2 = 0;
        } else {
          f = e2;
        }
        e2 = (c2 | 0) < (f | 0) ? c2 : f;
        e2 = (d2 | 0) < (e2 | 0) ? d2 : e2;
        if ((e2 | 0) <= 0) {
          return;
        }
        b[a2 >> 2] = f - e2;
        b[i2 >> 2] = c2 - e2;
        b[h >> 2] = d2 - e2;
        return;
      }
      function Ka(a2) {
        a2 = a2 | 0;
        var c2 = 0, d2 = 0, e2 = 0, f = 0, g2 = 0, h = 0, i2 = 0;
        c2 = b[a2 >> 2] | 0;
        h = a2 + 4 | 0;
        d2 = b[h >> 2] | 0;
        i2 = a2 + 8 | 0;
        e2 = b[i2 >> 2] | 0;
        f = d2 + (c2 * 3 | 0) | 0;
        b[a2 >> 2] = f;
        d2 = e2 + (d2 * 3 | 0) | 0;
        b[h >> 2] = d2;
        c2 = (e2 * 3 | 0) + c2 | 0;
        b[i2 >> 2] = c2;
        e2 = d2 - f | 0;
        if ((f | 0) < 0) {
          c2 = c2 - f | 0;
          b[h >> 2] = e2;
          b[i2 >> 2] = c2;
          b[a2 >> 2] = 0;
          d2 = e2;
          e2 = 0;
        } else {
          e2 = f;
        }
        if ((d2 | 0) < 0) {
          e2 = e2 - d2 | 0;
          b[a2 >> 2] = e2;
          c2 = c2 - d2 | 0;
          b[i2 >> 2] = c2;
          b[h >> 2] = 0;
          d2 = 0;
        }
        g2 = e2 - c2 | 0;
        f = d2 - c2 | 0;
        if ((c2 | 0) < 0) {
          b[a2 >> 2] = g2;
          b[h >> 2] = f;
          b[i2 >> 2] = 0;
          e2 = g2;
          c2 = 0;
        } else {
          f = d2;
        }
        d2 = (f | 0) < (e2 | 0) ? f : e2;
        d2 = (c2 | 0) < (d2 | 0) ? c2 : d2;
        if ((d2 | 0) <= 0) {
          return;
        }
        b[a2 >> 2] = e2 - d2;
        b[h >> 2] = f - d2;
        b[i2 >> 2] = c2 - d2;
        return;
      }
      function La(a2) {
        a2 = a2 | 0;
        var c2 = 0, d2 = 0, e2 = 0, f = 0, g2 = 0, h = 0, i2 = 0;
        f = b[a2 >> 2] | 0;
        h = a2 + 4 | 0;
        c2 = b[h >> 2] | 0;
        i2 = a2 + 8 | 0;
        d2 = b[i2 >> 2] | 0;
        e2 = (c2 * 3 | 0) + f | 0;
        f = d2 + (f * 3 | 0) | 0;
        b[a2 >> 2] = f;
        b[h >> 2] = e2;
        c2 = (d2 * 3 | 0) + c2 | 0;
        b[i2 >> 2] = c2;
        d2 = e2 - f | 0;
        if ((f | 0) < 0) {
          c2 = c2 - f | 0;
          b[h >> 2] = d2;
          b[i2 >> 2] = c2;
          b[a2 >> 2] = 0;
          f = 0;
        } else {
          d2 = e2;
        }
        if ((d2 | 0) < 0) {
          f = f - d2 | 0;
          b[a2 >> 2] = f;
          c2 = c2 - d2 | 0;
          b[i2 >> 2] = c2;
          b[h >> 2] = 0;
          d2 = 0;
        }
        g2 = f - c2 | 0;
        e2 = d2 - c2 | 0;
        if ((c2 | 0) < 0) {
          b[a2 >> 2] = g2;
          b[h >> 2] = e2;
          b[i2 >> 2] = 0;
          f = g2;
          c2 = 0;
        } else {
          e2 = d2;
        }
        d2 = (e2 | 0) < (f | 0) ? e2 : f;
        d2 = (c2 | 0) < (d2 | 0) ? c2 : d2;
        if ((d2 | 0) <= 0) {
          return;
        }
        b[a2 >> 2] = f - d2;
        b[h >> 2] = e2 - d2;
        b[i2 >> 2] = c2 - d2;
        return;
      }
      function Ma(a2, c2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        var d2 = 0, e2 = 0, f = 0, g2 = 0, h = 0, i2 = 0;
        if ((c2 + -1 | 0) >>> 0 >= 6) {
          return;
        }
        f = (b[15472 + (c2 * 12 | 0) >> 2] | 0) + (b[a2 >> 2] | 0) | 0;
        b[a2 >> 2] = f;
        i2 = a2 + 4 | 0;
        e2 = (b[15472 + (c2 * 12 | 0) + 4 >> 2] | 0) + (b[i2 >> 2] | 0) | 0;
        b[i2 >> 2] = e2;
        h = a2 + 8 | 0;
        c2 = (b[15472 + (c2 * 12 | 0) + 8 >> 2] | 0) + (b[h >> 2] | 0) | 0;
        b[h >> 2] = c2;
        d2 = e2 - f | 0;
        if ((f | 0) < 0) {
          c2 = c2 - f | 0;
          b[i2 >> 2] = d2;
          b[h >> 2] = c2;
          b[a2 >> 2] = 0;
          e2 = 0;
        } else {
          d2 = e2;
          e2 = f;
        }
        if ((d2 | 0) < 0) {
          e2 = e2 - d2 | 0;
          b[a2 >> 2] = e2;
          c2 = c2 - d2 | 0;
          b[h >> 2] = c2;
          b[i2 >> 2] = 0;
          d2 = 0;
        }
        g2 = e2 - c2 | 0;
        f = d2 - c2 | 0;
        if ((c2 | 0) < 0) {
          b[a2 >> 2] = g2;
          b[i2 >> 2] = f;
          b[h >> 2] = 0;
          e2 = g2;
          c2 = 0;
        } else {
          f = d2;
        }
        d2 = (f | 0) < (e2 | 0) ? f : e2;
        d2 = (c2 | 0) < (d2 | 0) ? c2 : d2;
        if ((d2 | 0) <= 0) {
          return;
        }
        b[a2 >> 2] = e2 - d2;
        b[i2 >> 2] = f - d2;
        b[h >> 2] = c2 - d2;
        return;
      }
      function Na(a2) {
        a2 = a2 | 0;
        var c2 = 0, d2 = 0, e2 = 0, f = 0, g2 = 0, h = 0, i2 = 0;
        f = b[a2 >> 2] | 0;
        h = a2 + 4 | 0;
        c2 = b[h >> 2] | 0;
        i2 = a2 + 8 | 0;
        d2 = b[i2 >> 2] | 0;
        e2 = c2 + f | 0;
        f = d2 + f | 0;
        b[a2 >> 2] = f;
        b[h >> 2] = e2;
        c2 = d2 + c2 | 0;
        b[i2 >> 2] = c2;
        d2 = e2 - f | 0;
        if ((f | 0) < 0) {
          c2 = c2 - f | 0;
          b[h >> 2] = d2;
          b[i2 >> 2] = c2;
          b[a2 >> 2] = 0;
          e2 = 0;
        } else {
          d2 = e2;
          e2 = f;
        }
        if ((d2 | 0) < 0) {
          e2 = e2 - d2 | 0;
          b[a2 >> 2] = e2;
          c2 = c2 - d2 | 0;
          b[i2 >> 2] = c2;
          b[h >> 2] = 0;
          d2 = 0;
        }
        g2 = e2 - c2 | 0;
        f = d2 - c2 | 0;
        if ((c2 | 0) < 0) {
          b[a2 >> 2] = g2;
          b[h >> 2] = f;
          b[i2 >> 2] = 0;
          e2 = g2;
          c2 = 0;
        } else {
          f = d2;
        }
        d2 = (f | 0) < (e2 | 0) ? f : e2;
        d2 = (c2 | 0) < (d2 | 0) ? c2 : d2;
        if ((d2 | 0) <= 0) {
          return;
        }
        b[a2 >> 2] = e2 - d2;
        b[h >> 2] = f - d2;
        b[i2 >> 2] = c2 - d2;
        return;
      }
      function Oa(a2) {
        a2 = a2 | 0;
        var c2 = 0, d2 = 0, e2 = 0, f = 0, g2 = 0, h = 0, i2 = 0;
        c2 = b[a2 >> 2] | 0;
        h = a2 + 4 | 0;
        e2 = b[h >> 2] | 0;
        i2 = a2 + 8 | 0;
        d2 = b[i2 >> 2] | 0;
        f = e2 + c2 | 0;
        b[a2 >> 2] = f;
        e2 = d2 + e2 | 0;
        b[h >> 2] = e2;
        c2 = d2 + c2 | 0;
        b[i2 >> 2] = c2;
        d2 = e2 - f | 0;
        if ((f | 0) < 0) {
          c2 = c2 - f | 0;
          b[h >> 2] = d2;
          b[i2 >> 2] = c2;
          b[a2 >> 2] = 0;
          e2 = 0;
        } else {
          d2 = e2;
          e2 = f;
        }
        if ((d2 | 0) < 0) {
          e2 = e2 - d2 | 0;
          b[a2 >> 2] = e2;
          c2 = c2 - d2 | 0;
          b[i2 >> 2] = c2;
          b[h >> 2] = 0;
          d2 = 0;
        }
        g2 = e2 - c2 | 0;
        f = d2 - c2 | 0;
        if ((c2 | 0) < 0) {
          b[a2 >> 2] = g2;
          b[h >> 2] = f;
          b[i2 >> 2] = 0;
          e2 = g2;
          c2 = 0;
        } else {
          f = d2;
        }
        d2 = (f | 0) < (e2 | 0) ? f : e2;
        d2 = (c2 | 0) < (d2 | 0) ? c2 : d2;
        if ((d2 | 0) <= 0) {
          return;
        }
        b[a2 >> 2] = e2 - d2;
        b[h >> 2] = f - d2;
        b[i2 >> 2] = c2 - d2;
        return;
      }
      function Pa(a2) {
        a2 = a2 | 0;
        switch (a2 | 0) {
          case 1: {
            a2 = 5;
            break;
          }
          case 5: {
            a2 = 4;
            break;
          }
          case 4: {
            a2 = 6;
            break;
          }
          case 6: {
            a2 = 2;
            break;
          }
          case 2: {
            a2 = 3;
            break;
          }
          case 3: {
            a2 = 1;
            break;
          }
          default:
        }
        return a2 | 0;
      }
      function Qa(a2) {
        a2 = a2 | 0;
        switch (a2 | 0) {
          case 1: {
            a2 = 3;
            break;
          }
          case 3: {
            a2 = 2;
            break;
          }
          case 2: {
            a2 = 6;
            break;
          }
          case 6: {
            a2 = 4;
            break;
          }
          case 4: {
            a2 = 5;
            break;
          }
          case 5: {
            a2 = 1;
            break;
          }
          default:
        }
        return a2 | 0;
      }
      function Ra(a2) {
        a2 = a2 | 0;
        var c2 = 0, d2 = 0, e2 = 0, f = 0, g2 = 0, h = 0, i2 = 0;
        c2 = b[a2 >> 2] | 0;
        h = a2 + 4 | 0;
        d2 = b[h >> 2] | 0;
        i2 = a2 + 8 | 0;
        e2 = b[i2 >> 2] | 0;
        f = d2 + (c2 << 1) | 0;
        b[a2 >> 2] = f;
        d2 = e2 + (d2 << 1) | 0;
        b[h >> 2] = d2;
        c2 = (e2 << 1) + c2 | 0;
        b[i2 >> 2] = c2;
        e2 = d2 - f | 0;
        if ((f | 0) < 0) {
          c2 = c2 - f | 0;
          b[h >> 2] = e2;
          b[i2 >> 2] = c2;
          b[a2 >> 2] = 0;
          d2 = e2;
          e2 = 0;
        } else {
          e2 = f;
        }
        if ((d2 | 0) < 0) {
          e2 = e2 - d2 | 0;
          b[a2 >> 2] = e2;
          c2 = c2 - d2 | 0;
          b[i2 >> 2] = c2;
          b[h >> 2] = 0;
          d2 = 0;
        }
        g2 = e2 - c2 | 0;
        f = d2 - c2 | 0;
        if ((c2 | 0) < 0) {
          b[a2 >> 2] = g2;
          b[h >> 2] = f;
          b[i2 >> 2] = 0;
          e2 = g2;
          c2 = 0;
        } else {
          f = d2;
        }
        d2 = (f | 0) < (e2 | 0) ? f : e2;
        d2 = (c2 | 0) < (d2 | 0) ? c2 : d2;
        if ((d2 | 0) <= 0) {
          return;
        }
        b[a2 >> 2] = e2 - d2;
        b[h >> 2] = f - d2;
        b[i2 >> 2] = c2 - d2;
        return;
      }
      function Sa(a2) {
        a2 = a2 | 0;
        var c2 = 0, d2 = 0, e2 = 0, f = 0, g2 = 0, h = 0, i2 = 0;
        f = b[a2 >> 2] | 0;
        h = a2 + 4 | 0;
        c2 = b[h >> 2] | 0;
        i2 = a2 + 8 | 0;
        d2 = b[i2 >> 2] | 0;
        e2 = (c2 << 1) + f | 0;
        f = d2 + (f << 1) | 0;
        b[a2 >> 2] = f;
        b[h >> 2] = e2;
        c2 = (d2 << 1) + c2 | 0;
        b[i2 >> 2] = c2;
        d2 = e2 - f | 0;
        if ((f | 0) < 0) {
          c2 = c2 - f | 0;
          b[h >> 2] = d2;
          b[i2 >> 2] = c2;
          b[a2 >> 2] = 0;
          f = 0;
        } else {
          d2 = e2;
        }
        if ((d2 | 0) < 0) {
          f = f - d2 | 0;
          b[a2 >> 2] = f;
          c2 = c2 - d2 | 0;
          b[i2 >> 2] = c2;
          b[h >> 2] = 0;
          d2 = 0;
        }
        g2 = f - c2 | 0;
        e2 = d2 - c2 | 0;
        if ((c2 | 0) < 0) {
          b[a2 >> 2] = g2;
          b[h >> 2] = e2;
          b[i2 >> 2] = 0;
          f = g2;
          c2 = 0;
        } else {
          e2 = d2;
        }
        d2 = (e2 | 0) < (f | 0) ? e2 : f;
        d2 = (c2 | 0) < (d2 | 0) ? c2 : d2;
        if ((d2 | 0) <= 0) {
          return;
        }
        b[a2 >> 2] = f - d2;
        b[h >> 2] = e2 - d2;
        b[i2 >> 2] = c2 - d2;
        return;
      }
      function Ta(a2, c2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        var d2 = 0, e2 = 0, f = 0, g2 = 0, h = 0, i2 = 0;
        h = (b[a2 >> 2] | 0) - (b[c2 >> 2] | 0) | 0;
        i2 = (h | 0) < 0;
        e2 = (b[a2 + 4 >> 2] | 0) - (b[c2 + 4 >> 2] | 0) - (i2 ? h : 0) | 0;
        g2 = (e2 | 0) < 0;
        f = (i2 ? 0 - h | 0 : 0) + (b[a2 + 8 >> 2] | 0) - (b[c2 + 8 >> 2] | 0) + (g2 ? 0 - e2 | 0 : 0) | 0;
        a2 = (f | 0) < 0;
        c2 = a2 ? 0 : f;
        d2 = (g2 ? 0 : e2) - (a2 ? f : 0) | 0;
        f = (i2 ? 0 : h) - (g2 ? e2 : 0) - (a2 ? f : 0) | 0;
        a2 = (d2 | 0) < (f | 0) ? d2 : f;
        a2 = (c2 | 0) < (a2 | 0) ? c2 : a2;
        e2 = (a2 | 0) > 0;
        c2 = c2 - (e2 ? a2 : 0) | 0;
        d2 = d2 - (e2 ? a2 : 0) | 0;
        a2 = f - (e2 ? a2 : 0) | 0;
        a2 = (a2 | 0) > -1 ? a2 : 0 - a2 | 0;
        d2 = (d2 | 0) > -1 ? d2 : 0 - d2 | 0;
        c2 = (c2 | 0) > -1 ? c2 : 0 - c2 | 0;
        c2 = (d2 | 0) > (c2 | 0) ? d2 : c2;
        return ((a2 | 0) > (c2 | 0) ? a2 : c2) | 0;
      }
      function Ua(a2, c2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        var d2 = 0;
        d2 = b[a2 + 8 >> 2] | 0;
        b[c2 >> 2] = (b[a2 >> 2] | 0) - d2;
        b[c2 + 4 >> 2] = (b[a2 + 4 >> 2] | 0) - d2;
        return;
      }
      function Va(a2, c2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        var d2 = 0, e2 = 0, f = 0, g2 = 0, h = 0, i2 = 0;
        e2 = b[a2 >> 2] | 0;
        b[c2 >> 2] = e2;
        a2 = b[a2 + 4 >> 2] | 0;
        h = c2 + 4 | 0;
        b[h >> 2] = a2;
        i2 = c2 + 8 | 0;
        b[i2 >> 2] = 0;
        d2 = a2 - e2 | 0;
        if ((e2 | 0) < 0) {
          a2 = 0 - e2 | 0;
          b[h >> 2] = d2;
          b[i2 >> 2] = a2;
          b[c2 >> 2] = 0;
          e2 = 0;
        } else {
          d2 = a2;
          a2 = 0;
        }
        if ((d2 | 0) < 0) {
          e2 = e2 - d2 | 0;
          b[c2 >> 2] = e2;
          a2 = a2 - d2 | 0;
          b[i2 >> 2] = a2;
          b[h >> 2] = 0;
          d2 = 0;
        }
        g2 = e2 - a2 | 0;
        f = d2 - a2 | 0;
        if ((a2 | 0) < 0) {
          b[c2 >> 2] = g2;
          b[h >> 2] = f;
          b[i2 >> 2] = 0;
          d2 = f;
          f = g2;
          a2 = 0;
        } else {
          f = e2;
        }
        e2 = (d2 | 0) < (f | 0) ? d2 : f;
        e2 = (a2 | 0) < (e2 | 0) ? a2 : e2;
        if ((e2 | 0) <= 0) {
          return;
        }
        b[c2 >> 2] = f - e2;
        b[h >> 2] = d2 - e2;
        b[i2 >> 2] = a2 - e2;
        return;
      }
      function Wa(a2) {
        a2 = a2 | 0;
        var c2 = 0, d2 = 0, e2 = 0, f = 0;
        c2 = a2 + 8 | 0;
        f = b[c2 >> 2] | 0;
        d2 = f - (b[a2 >> 2] | 0) | 0;
        b[a2 >> 2] = d2;
        e2 = a2 + 4 | 0;
        a2 = (b[e2 >> 2] | 0) - f | 0;
        b[e2 >> 2] = a2;
        b[c2 >> 2] = 0 - (a2 + d2);
        return;
      }
      function Xa(a2) {
        a2 = a2 | 0;
        var c2 = 0, d2 = 0, e2 = 0, f = 0, g2 = 0, h = 0, i2 = 0;
        d2 = b[a2 >> 2] | 0;
        c2 = 0 - d2 | 0;
        b[a2 >> 2] = c2;
        h = a2 + 8 | 0;
        b[h >> 2] = 0;
        i2 = a2 + 4 | 0;
        e2 = b[i2 >> 2] | 0;
        f = e2 + d2 | 0;
        if ((d2 | 0) > 0) {
          b[i2 >> 2] = f;
          b[h >> 2] = d2;
          b[a2 >> 2] = 0;
          c2 = 0;
          e2 = f;
        } else {
          d2 = 0;
        }
        if ((e2 | 0) < 0) {
          g2 = c2 - e2 | 0;
          b[a2 >> 2] = g2;
          d2 = d2 - e2 | 0;
          b[h >> 2] = d2;
          b[i2 >> 2] = 0;
          f = g2 - d2 | 0;
          c2 = 0 - d2 | 0;
          if ((d2 | 0) < 0) {
            b[a2 >> 2] = f;
            b[i2 >> 2] = c2;
            b[h >> 2] = 0;
            e2 = c2;
            d2 = 0;
          } else {
            e2 = 0;
            f = g2;
          }
        } else {
          f = c2;
        }
        c2 = (e2 | 0) < (f | 0) ? e2 : f;
        c2 = (d2 | 0) < (c2 | 0) ? d2 : c2;
        if ((c2 | 0) <= 0) {
          return;
        }
        b[a2 >> 2] = f - c2;
        b[i2 >> 2] = e2 - c2;
        b[h >> 2] = d2 - c2;
        return;
      }
      function Ya(a2, b2, c2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        c2 = c2 | 0;
        var d2 = 0, e2 = 0;
        d2 = S;
        S = S + 16 | 0;
        e2 = d2;
        Za(a2, b2, c2, e2);
        Ba(e2, c2 + 4 | 0);
        S = d2;
        return;
      }
      function Za(a2, c2, d2, f) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        f = f | 0;
        var g2 = 0, h = 0, i2 = 0, j = 0, k = 0;
        k = S;
        S = S + 32 | 0;
        h = k;
        Jc(a2, h);
        b[d2 >> 2] = 0;
        g2 = +Ic(15888, h);
        i2 = +Ic(15912, h);
        if (i2 < g2) {
          b[d2 >> 2] = 1;
          g2 = i2;
        }
        i2 = +Ic(15936, h);
        if (i2 < g2) {
          b[d2 >> 2] = 2;
          g2 = i2;
        }
        i2 = +Ic(15960, h);
        if (i2 < g2) {
          b[d2 >> 2] = 3;
          g2 = i2;
        }
        i2 = +Ic(15984, h);
        if (i2 < g2) {
          b[d2 >> 2] = 4;
          g2 = i2;
        }
        i2 = +Ic(16008, h);
        if (i2 < g2) {
          b[d2 >> 2] = 5;
          g2 = i2;
        }
        i2 = +Ic(16032, h);
        if (i2 < g2) {
          b[d2 >> 2] = 6;
          g2 = i2;
        }
        i2 = +Ic(16056, h);
        if (i2 < g2) {
          b[d2 >> 2] = 7;
          g2 = i2;
        }
        i2 = +Ic(16080, h);
        if (i2 < g2) {
          b[d2 >> 2] = 8;
          g2 = i2;
        }
        i2 = +Ic(16104, h);
        if (i2 < g2) {
          b[d2 >> 2] = 9;
          g2 = i2;
        }
        i2 = +Ic(16128, h);
        if (i2 < g2) {
          b[d2 >> 2] = 10;
          g2 = i2;
        }
        i2 = +Ic(16152, h);
        if (i2 < g2) {
          b[d2 >> 2] = 11;
          g2 = i2;
        }
        i2 = +Ic(16176, h);
        if (i2 < g2) {
          b[d2 >> 2] = 12;
          g2 = i2;
        }
        i2 = +Ic(16200, h);
        if (i2 < g2) {
          b[d2 >> 2] = 13;
          g2 = i2;
        }
        i2 = +Ic(16224, h);
        if (i2 < g2) {
          b[d2 >> 2] = 14;
          g2 = i2;
        }
        i2 = +Ic(16248, h);
        if (i2 < g2) {
          b[d2 >> 2] = 15;
          g2 = i2;
        }
        i2 = +Ic(16272, h);
        if (i2 < g2) {
          b[d2 >> 2] = 16;
          g2 = i2;
        }
        i2 = +Ic(16296, h);
        if (i2 < g2) {
          b[d2 >> 2] = 17;
          g2 = i2;
        }
        i2 = +Ic(16320, h);
        if (i2 < g2) {
          b[d2 >> 2] = 18;
          g2 = i2;
        }
        i2 = +Ic(16344, h);
        if (i2 < g2) {
          b[d2 >> 2] = 19;
          g2 = i2;
        }
        i2 = +w(+(1 - g2 * 0.5));
        if (i2 < 1e-16) {
          b[f >> 2] = 0;
          b[f + 4 >> 2] = 0;
          b[f + 8 >> 2] = 0;
          b[f + 12 >> 2] = 0;
          S = k;
          return;
        }
        d2 = b[d2 >> 2] | 0;
        g2 = +e[16368 + (d2 * 24 | 0) >> 3];
        g2 = +gb(g2 - +gb(+lb(15568 + (d2 << 4) | 0, a2)));
        if (!(Rb(c2) | 0)) {
          j = g2;
        } else {
          j = +gb(g2 + -0.3334731722518321);
        }
        g2 = +v(+i2) / 0.381966011250105;
        if ((c2 | 0) > 0) {
          h = 0;
          do {
            g2 = g2 * 2.6457513110645907;
            h = h + 1 | 0;
          } while ((h | 0) != (c2 | 0));
        }
        i2 = +t(+j) * g2;
        e[f >> 3] = i2;
        j = +u(+j) * g2;
        e[f + 8 >> 3] = j;
        S = k;
        return;
      }
      function _a(a2, c2, d2, f, g2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        f = f | 0;
        g2 = g2 | 0;
        var h = 0, i2 = 0;
        h = +Fc(a2);
        if (h < 1e-16) {
          c2 = 15568 + (c2 << 4) | 0;
          b[g2 >> 2] = b[c2 >> 2];
          b[g2 + 4 >> 2] = b[c2 + 4 >> 2];
          b[g2 + 8 >> 2] = b[c2 + 8 >> 2];
          b[g2 + 12 >> 2] = b[c2 + 12 >> 2];
          return;
        }
        i2 = +z(+ +e[a2 + 8 >> 3], + +e[a2 >> 3]);
        if ((d2 | 0) > 0) {
          a2 = 0;
          do {
            h = h / 2.6457513110645907;
            a2 = a2 + 1 | 0;
          } while ((a2 | 0) != (d2 | 0));
        }
        if (!f) {
          h = +y2(+(h * 0.381966011250105));
          if (Rb(d2) | 0) {
            i2 = +gb(i2 + 0.3334731722518321);
          }
        } else {
          h = h / 3;
          d2 = (Rb(d2) | 0) == 0;
          h = +y2(+((d2 ? h : h / 2.6457513110645907) * 0.381966011250105));
        }
        mb(15568 + (c2 << 4) | 0, +gb(+e[16368 + (c2 * 24 | 0) >> 3] - i2), h, g2);
        return;
      }
      function $a(a2, c2, d2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        var e2 = 0, f = 0;
        e2 = S;
        S = S + 16 | 0;
        f = e2;
        Da(a2 + 4 | 0, f);
        _a(f, b[a2 >> 2] | 0, c2, 0, d2);
        S = e2;
        return;
      }
      function ab(a2, c2, d2, f, g2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        f = f | 0;
        g2 = g2 | 0;
        var h = 0, i2 = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t2 = 0, u2 = 0, v2 = 0, w2 = 0, x3 = 0, y3 = 0, z2 = 0, A2 = 0, B2 = 0, C2 = 0, D2 = 0, E = 0, F2 = 0, G2 = 0, I2 = 0, J2 = 0;
        G2 = S;
        S = S + 272 | 0;
        h = G2 + 256 | 0;
        u2 = G2 + 240 | 0;
        D2 = G2;
        E = G2 + 224 | 0;
        F2 = G2 + 208 | 0;
        v2 = G2 + 176 | 0;
        w2 = G2 + 160 | 0;
        x3 = G2 + 192 | 0;
        y3 = G2 + 144 | 0;
        z2 = G2 + 128 | 0;
        A2 = G2 + 112 | 0;
        B2 = G2 + 96 | 0;
        C2 = G2 + 80 | 0;
        b[h >> 2] = c2;
        b[u2 >> 2] = b[a2 >> 2];
        b[u2 + 4 >> 2] = b[a2 + 4 >> 2];
        b[u2 + 8 >> 2] = b[a2 + 8 >> 2];
        b[u2 + 12 >> 2] = b[a2 + 12 >> 2];
        bb(u2, h, D2);
        b[g2 >> 2] = 0;
        u2 = f + d2 + ((f | 0) == 5 & 1) | 0;
        if ((u2 | 0) <= (d2 | 0)) {
          S = G2;
          return;
        }
        k = b[h >> 2] | 0;
        l = E + 4 | 0;
        m = v2 + 4 | 0;
        n = d2 + 5 | 0;
        o = 16848 + (k << 2) | 0;
        p2 = 16928 + (k << 2) | 0;
        q2 = z2 + 8 | 0;
        r2 = A2 + 8 | 0;
        s2 = B2 + 8 | 0;
        t2 = F2 + 4 | 0;
        j = d2;
        a:
          while (1) {
            i2 = D2 + (((j | 0) % 5 | 0) << 4) | 0;
            b[F2 >> 2] = b[i2 >> 2];
            b[F2 + 4 >> 2] = b[i2 + 4 >> 2];
            b[F2 + 8 >> 2] = b[i2 + 8 >> 2];
            b[F2 + 12 >> 2] = b[i2 + 12 >> 2];
            do {
            } while ((cb(F2, k, 0, 1) | 0) == 2);
            if ((j | 0) > (d2 | 0) & (Rb(c2) | 0) != 0) {
              b[v2 >> 2] = b[F2 >> 2];
              b[v2 + 4 >> 2] = b[F2 + 4 >> 2];
              b[v2 + 8 >> 2] = b[F2 + 8 >> 2];
              b[v2 + 12 >> 2] = b[F2 + 12 >> 2];
              Da(l, w2);
              f = b[v2 >> 2] | 0;
              h = b[17008 + (f * 80 | 0) + (b[E >> 2] << 2) >> 2] | 0;
              b[v2 >> 2] = b[18608 + (f * 80 | 0) + (h * 20 | 0) >> 2];
              i2 = b[18608 + (f * 80 | 0) + (h * 20 | 0) + 16 >> 2] | 0;
              if ((i2 | 0) > 0) {
                a2 = 0;
                do {
                  Na(m);
                  a2 = a2 + 1 | 0;
                } while ((a2 | 0) < (i2 | 0));
              }
              i2 = 18608 + (f * 80 | 0) + (h * 20 | 0) + 4 | 0;
              b[x3 >> 2] = b[i2 >> 2];
              b[x3 + 4 >> 2] = b[i2 + 4 >> 2];
              b[x3 + 8 >> 2] = b[i2 + 8 >> 2];
              Ga(x3, (b[o >> 2] | 0) * 3 | 0);
              Ea(m, x3, m);
              Ca(m);
              Da(m, y3);
              I2 = +(b[p2 >> 2] | 0);
              e[z2 >> 3] = I2 * 3;
              e[q2 >> 3] = 0;
              J2 = I2 * -1.5;
              e[A2 >> 3] = J2;
              e[r2 >> 3] = I2 * 2.598076211353316;
              e[B2 >> 3] = J2;
              e[s2 >> 3] = I2 * -2.598076211353316;
              switch (b[17008 + ((b[v2 >> 2] | 0) * 80 | 0) + (b[F2 >> 2] << 2) >> 2] | 0) {
                case 1: {
                  a2 = A2;
                  f = z2;
                  break;
                }
                case 3: {
                  a2 = B2;
                  f = A2;
                  break;
                }
                case 2: {
                  a2 = z2;
                  f = B2;
                  break;
                }
                default: {
                  a2 = 12;
                  break a;
                }
              }
              Gc(w2, y3, f, a2, C2);
              _a(C2, b[v2 >> 2] | 0, k, 1, g2 + 8 + (b[g2 >> 2] << 4) | 0);
              b[g2 >> 2] = (b[g2 >> 2] | 0) + 1;
            }
            if ((j | 0) < (n | 0)) {
              Da(t2, v2);
              _a(v2, b[F2 >> 2] | 0, k, 1, g2 + 8 + (b[g2 >> 2] << 4) | 0);
              b[g2 >> 2] = (b[g2 >> 2] | 0) + 1;
            }
            b[E >> 2] = b[F2 >> 2];
            b[E + 4 >> 2] = b[F2 + 4 >> 2];
            b[E + 8 >> 2] = b[F2 + 8 >> 2];
            b[E + 12 >> 2] = b[F2 + 12 >> 2];
            j = j + 1 | 0;
            if ((j | 0) >= (u2 | 0)) {
              a2 = 3;
              break;
            }
          }
        if ((a2 | 0) == 3) {
          S = G2;
          return;
        } else if ((a2 | 0) == 12) {
          H(22474, 22521, 581, 22531);
        }
      }
      function bb(a2, c2, d2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        var e2 = 0, f = 0, g2 = 0, h = 0, i2 = 0, j = 0;
        j = S;
        S = S + 128 | 0;
        e2 = j + 64 | 0;
        f = j;
        g2 = e2;
        h = 20208;
        i2 = g2 + 60 | 0;
        do {
          b[g2 >> 2] = b[h >> 2];
          g2 = g2 + 4 | 0;
          h = h + 4 | 0;
        } while ((g2 | 0) < (i2 | 0));
        g2 = f;
        h = 20272;
        i2 = g2 + 60 | 0;
        do {
          b[g2 >> 2] = b[h >> 2];
          g2 = g2 + 4 | 0;
          h = h + 4 | 0;
        } while ((g2 | 0) < (i2 | 0));
        i2 = (Rb(b[c2 >> 2] | 0) | 0) == 0;
        e2 = i2 ? e2 : f;
        f = a2 + 4 | 0;
        Ra(f);
        Sa(f);
        if (Rb(b[c2 >> 2] | 0) | 0) {
          La(f);
          b[c2 >> 2] = (b[c2 >> 2] | 0) + 1;
        }
        b[d2 >> 2] = b[a2 >> 2];
        c2 = d2 + 4 | 0;
        Ea(f, e2, c2);
        Ca(c2);
        b[d2 + 16 >> 2] = b[a2 >> 2];
        c2 = d2 + 20 | 0;
        Ea(f, e2 + 12 | 0, c2);
        Ca(c2);
        b[d2 + 32 >> 2] = b[a2 >> 2];
        c2 = d2 + 36 | 0;
        Ea(f, e2 + 24 | 0, c2);
        Ca(c2);
        b[d2 + 48 >> 2] = b[a2 >> 2];
        c2 = d2 + 52 | 0;
        Ea(f, e2 + 36 | 0, c2);
        Ca(c2);
        b[d2 + 64 >> 2] = b[a2 >> 2];
        d2 = d2 + 68 | 0;
        Ea(f, e2 + 48 | 0, d2);
        Ca(d2);
        S = j;
        return;
      }
      function cb(a2, c2, d2, e2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        var f = 0, g2 = 0, h = 0, i2 = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0;
        p2 = S;
        S = S + 32 | 0;
        n = p2 + 12 | 0;
        i2 = p2;
        o = a2 + 4 | 0;
        m = b[16928 + (c2 << 2) >> 2] | 0;
        l = (e2 | 0) != 0;
        m = l ? m * 3 | 0 : m;
        f = b[o >> 2] | 0;
        k = a2 + 8 | 0;
        h = b[k >> 2] | 0;
        if (l) {
          g2 = a2 + 12 | 0;
          e2 = b[g2 >> 2] | 0;
          f = h + f + e2 | 0;
          if ((f | 0) == (m | 0)) {
            o = 1;
            S = p2;
            return o | 0;
          } else {
            j = g2;
          }
        } else {
          j = a2 + 12 | 0;
          e2 = b[j >> 2] | 0;
          f = h + f + e2 | 0;
        }
        if ((f | 0) <= (m | 0)) {
          o = 0;
          S = p2;
          return o | 0;
        }
        do {
          if ((e2 | 0) > 0) {
            e2 = b[a2 >> 2] | 0;
            if ((h | 0) > 0) {
              g2 = 18608 + (e2 * 80 | 0) + 60 | 0;
              e2 = a2;
              break;
            }
            e2 = 18608 + (e2 * 80 | 0) + 40 | 0;
            if (!d2) {
              g2 = e2;
              e2 = a2;
            } else {
              Aa(n, m, 0, 0);
              Fa(o, n, i2);
              Oa(i2);
              Ea(i2, n, o);
              g2 = e2;
              e2 = a2;
            }
          } else {
            g2 = 18608 + ((b[a2 >> 2] | 0) * 80 | 0) + 20 | 0;
            e2 = a2;
          }
        } while (0);
        b[e2 >> 2] = b[g2 >> 2];
        f = g2 + 16 | 0;
        if ((b[f >> 2] | 0) > 0) {
          e2 = 0;
          do {
            Na(o);
            e2 = e2 + 1 | 0;
          } while ((e2 | 0) < (b[f >> 2] | 0));
        }
        a2 = g2 + 4 | 0;
        b[n >> 2] = b[a2 >> 2];
        b[n + 4 >> 2] = b[a2 + 4 >> 2];
        b[n + 8 >> 2] = b[a2 + 8 >> 2];
        c2 = b[16848 + (c2 << 2) >> 2] | 0;
        Ga(n, l ? c2 * 3 | 0 : c2);
        Ea(o, n, o);
        Ca(o);
        if (l) {
          e2 = ((b[k >> 2] | 0) + (b[o >> 2] | 0) + (b[j >> 2] | 0) | 0) == (m | 0) ? 1 : 2;
        } else {
          e2 = 2;
        }
        o = e2;
        S = p2;
        return o | 0;
      }
      function db(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        var c2 = 0;
        do {
          c2 = cb(a2, b2, 0, 1) | 0;
        } while ((c2 | 0) == 2);
        return c2 | 0;
      }
      function eb(a2, c2, d2, f, g2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        f = f | 0;
        g2 = g2 | 0;
        var h = 0, i2 = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t2 = 0, u2 = 0, v2 = 0, w2 = 0, x3 = 0, y3 = 0, z2 = 0, A2 = 0, B2 = 0, C2 = 0, D2 = 0;
        B2 = S;
        S = S + 240 | 0;
        h = B2 + 224 | 0;
        x3 = B2 + 208 | 0;
        y3 = B2;
        z2 = B2 + 192 | 0;
        A2 = B2 + 176 | 0;
        s2 = B2 + 160 | 0;
        t2 = B2 + 144 | 0;
        u2 = B2 + 128 | 0;
        v2 = B2 + 112 | 0;
        w2 = B2 + 96 | 0;
        b[h >> 2] = c2;
        b[x3 >> 2] = b[a2 >> 2];
        b[x3 + 4 >> 2] = b[a2 + 4 >> 2];
        b[x3 + 8 >> 2] = b[a2 + 8 >> 2];
        b[x3 + 12 >> 2] = b[a2 + 12 >> 2];
        fb(x3, h, y3);
        b[g2 >> 2] = 0;
        r2 = f + d2 + ((f | 0) == 6 & 1) | 0;
        if ((r2 | 0) <= (d2 | 0)) {
          S = B2;
          return;
        }
        k = b[h >> 2] | 0;
        l = d2 + 6 | 0;
        m = 16928 + (k << 2) | 0;
        n = t2 + 8 | 0;
        o = u2 + 8 | 0;
        p2 = v2 + 8 | 0;
        q2 = z2 + 4 | 0;
        i2 = 0;
        j = d2;
        f = -1;
        a:
          while (1) {
            h = (j | 0) % 6 | 0;
            a2 = y3 + (h << 4) | 0;
            b[z2 >> 2] = b[a2 >> 2];
            b[z2 + 4 >> 2] = b[a2 + 4 >> 2];
            b[z2 + 8 >> 2] = b[a2 + 8 >> 2];
            b[z2 + 12 >> 2] = b[a2 + 12 >> 2];
            a2 = i2;
            i2 = cb(z2, k, 0, 1) | 0;
            if ((j | 0) > (d2 | 0) & (Rb(c2) | 0) != 0 ? (a2 | 0) != 1 ? (b[z2 >> 2] | 0) != (f | 0) : 0 : 0) {
              Da(y3 + (((h + 5 | 0) % 6 | 0) << 4) + 4 | 0, A2);
              Da(y3 + (h << 4) + 4 | 0, s2);
              C2 = +(b[m >> 2] | 0);
              e[t2 >> 3] = C2 * 3;
              e[n >> 3] = 0;
              D2 = C2 * -1.5;
              e[u2 >> 3] = D2;
              e[o >> 3] = C2 * 2.598076211353316;
              e[v2 >> 3] = D2;
              e[p2 >> 3] = C2 * -2.598076211353316;
              h = b[x3 >> 2] | 0;
              switch (b[17008 + (h * 80 | 0) + (((f | 0) == (h | 0) ? b[z2 >> 2] | 0 : f) << 2) >> 2] | 0) {
                case 1: {
                  a2 = u2;
                  f = t2;
                  break;
                }
                case 3: {
                  a2 = v2;
                  f = u2;
                  break;
                }
                case 2: {
                  a2 = t2;
                  f = v2;
                  break;
                }
                default: {
                  a2 = 8;
                  break a;
                }
              }
              Gc(A2, s2, f, a2, w2);
              if (!(Hc(A2, w2) | 0) ? !(Hc(s2, w2) | 0) : 0) {
                _a(w2, b[x3 >> 2] | 0, k, 1, g2 + 8 + (b[g2 >> 2] << 4) | 0);
                b[g2 >> 2] = (b[g2 >> 2] | 0) + 1;
              }
            }
            if ((j | 0) < (l | 0)) {
              Da(q2, A2);
              _a(A2, b[z2 >> 2] | 0, k, 1, g2 + 8 + (b[g2 >> 2] << 4) | 0);
              b[g2 >> 2] = (b[g2 >> 2] | 0) + 1;
            }
            j = j + 1 | 0;
            if ((j | 0) >= (r2 | 0)) {
              a2 = 3;
              break;
            } else {
              f = b[z2 >> 2] | 0;
            }
          }
        if ((a2 | 0) == 3) {
          S = B2;
          return;
        } else if ((a2 | 0) == 8) {
          H(22557, 22521, 746, 22602);
        }
      }
      function fb(a2, c2, d2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        var e2 = 0, f = 0, g2 = 0, h = 0, i2 = 0, j = 0;
        j = S;
        S = S + 160 | 0;
        e2 = j + 80 | 0;
        f = j;
        g2 = e2;
        h = 20336;
        i2 = g2 + 72 | 0;
        do {
          b[g2 >> 2] = b[h >> 2];
          g2 = g2 + 4 | 0;
          h = h + 4 | 0;
        } while ((g2 | 0) < (i2 | 0));
        g2 = f;
        h = 20416;
        i2 = g2 + 72 | 0;
        do {
          b[g2 >> 2] = b[h >> 2];
          g2 = g2 + 4 | 0;
          h = h + 4 | 0;
        } while ((g2 | 0) < (i2 | 0));
        i2 = (Rb(b[c2 >> 2] | 0) | 0) == 0;
        e2 = i2 ? e2 : f;
        f = a2 + 4 | 0;
        Ra(f);
        Sa(f);
        if (Rb(b[c2 >> 2] | 0) | 0) {
          La(f);
          b[c2 >> 2] = (b[c2 >> 2] | 0) + 1;
        }
        b[d2 >> 2] = b[a2 >> 2];
        c2 = d2 + 4 | 0;
        Ea(f, e2, c2);
        Ca(c2);
        b[d2 + 16 >> 2] = b[a2 >> 2];
        c2 = d2 + 20 | 0;
        Ea(f, e2 + 12 | 0, c2);
        Ca(c2);
        b[d2 + 32 >> 2] = b[a2 >> 2];
        c2 = d2 + 36 | 0;
        Ea(f, e2 + 24 | 0, c2);
        Ca(c2);
        b[d2 + 48 >> 2] = b[a2 >> 2];
        c2 = d2 + 52 | 0;
        Ea(f, e2 + 36 | 0, c2);
        Ca(c2);
        b[d2 + 64 >> 2] = b[a2 >> 2];
        c2 = d2 + 68 | 0;
        Ea(f, e2 + 48 | 0, c2);
        Ca(c2);
        b[d2 + 80 >> 2] = b[a2 >> 2];
        d2 = d2 + 84 | 0;
        Ea(f, e2 + 60 | 0, d2);
        Ca(d2);
        S = j;
        return;
      }
      function gb(a2) {
        a2 = +a2;
        var b2 = 0;
        b2 = a2 < 0 ? a2 + 6.283185307179586 : a2;
        return +(!(a2 >= 6.283185307179586) ? b2 : b2 + -6.283185307179586);
      }
      function hb(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        if (!(+q(+(+e[a2 >> 3] - +e[b2 >> 3])) < 17453292519943298e-27)) {
          b2 = 0;
          return b2 | 0;
        }
        b2 = +q(+(+e[a2 + 8 >> 3] - +e[b2 + 8 >> 3])) < 17453292519943298e-27;
        return b2 | 0;
      }
      function ib(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        var c2 = 0, d2 = 0, f = 0, g2 = 0;
        f = +e[b2 >> 3];
        d2 = +e[a2 >> 3];
        g2 = +u(+((f - d2) * 0.5));
        c2 = +u(+((+e[b2 + 8 >> 3] - +e[a2 + 8 >> 3]) * 0.5));
        c2 = g2 * g2 + c2 * (+t(+f) * +t(+d2) * c2);
        return +(+z(+ +r(+c2), + +r(+(1 - c2))) * 2);
      }
      function jb(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        var c2 = 0, d2 = 0, f = 0, g2 = 0;
        f = +e[b2 >> 3];
        d2 = +e[a2 >> 3];
        g2 = +u(+((f - d2) * 0.5));
        c2 = +u(+((+e[b2 + 8 >> 3] - +e[a2 + 8 >> 3]) * 0.5));
        c2 = g2 * g2 + c2 * (+t(+f) * +t(+d2) * c2);
        return +(+z(+ +r(+c2), + +r(+(1 - c2))) * 2 * 6371.007180918475);
      }
      function kb(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        var c2 = 0, d2 = 0, f = 0, g2 = 0;
        f = +e[b2 >> 3];
        d2 = +e[a2 >> 3];
        g2 = +u(+((f - d2) * 0.5));
        c2 = +u(+((+e[b2 + 8 >> 3] - +e[a2 + 8 >> 3]) * 0.5));
        c2 = g2 * g2 + c2 * (+t(+f) * +t(+d2) * c2);
        return +(+z(+ +r(+c2), + +r(+(1 - c2))) * 2 * 6371.007180918475 * 1e3);
      }
      function lb(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        var c2 = 0, d2 = 0, f = 0, g2 = 0, h = 0;
        g2 = +e[b2 >> 3];
        d2 = +t(+g2);
        f = +e[b2 + 8 >> 3] - +e[a2 + 8 >> 3];
        h = d2 * +u(+f);
        c2 = +e[a2 >> 3];
        return + +z(+h, +(+u(+g2) * +t(+c2) - +t(+f) * (d2 * +u(+c2))));
      }
      function mb(a2, c2, d2, f) {
        a2 = a2 | 0;
        c2 = +c2;
        d2 = +d2;
        f = f | 0;
        var g2 = 0, h = 0, i2 = 0, j = 0;
        if (d2 < 1e-16) {
          b[f >> 2] = b[a2 >> 2];
          b[f + 4 >> 2] = b[a2 + 4 >> 2];
          b[f + 8 >> 2] = b[a2 + 8 >> 2];
          b[f + 12 >> 2] = b[a2 + 12 >> 2];
          return;
        }
        h = c2 < 0 ? c2 + 6.283185307179586 : c2;
        h = !(c2 >= 6.283185307179586) ? h : h + -6.283185307179586;
        do {
          if (h < 1e-16) {
            c2 = +e[a2 >> 3] + d2;
            e[f >> 3] = c2;
            g2 = f;
          } else {
            g2 = +q(+(h + -3.141592653589793)) < 1e-16;
            c2 = +e[a2 >> 3];
            if (g2) {
              c2 = c2 - d2;
              e[f >> 3] = c2;
              g2 = f;
              break;
            }
            i2 = +t(+d2);
            d2 = +u(+d2);
            c2 = i2 * +u(+c2) + +t(+h) * (d2 * +t(+c2));
            c2 = c2 > 1 ? 1 : c2;
            c2 = +x2(+(c2 < -1 ? -1 : c2));
            e[f >> 3] = c2;
            if (+q(+(c2 + -1.5707963267948966)) < 1e-16) {
              e[f >> 3] = 1.5707963267948966;
              e[f + 8 >> 3] = 0;
              return;
            }
            if (+q(+(c2 + 1.5707963267948966)) < 1e-16) {
              e[f >> 3] = -1.5707963267948966;
              e[f + 8 >> 3] = 0;
              return;
            }
            j = +t(+c2);
            h = d2 * +u(+h) / j;
            d2 = +e[a2 >> 3];
            c2 = (i2 - +u(+c2) * +u(+d2)) / +t(+d2) / j;
            i2 = h > 1 ? 1 : h;
            c2 = c2 > 1 ? 1 : c2;
            c2 = +e[a2 + 8 >> 3] + +z(+(i2 < -1 ? -1 : i2), +(c2 < -1 ? -1 : c2));
            if (c2 > 3.141592653589793) {
              do {
                c2 = c2 + -6.283185307179586;
              } while (c2 > 3.141592653589793);
            }
            if (c2 < -3.141592653589793) {
              do {
                c2 = c2 + 6.283185307179586;
              } while (c2 < -3.141592653589793);
            }
            e[f + 8 >> 3] = c2;
            return;
          }
        } while (0);
        if (+q(+(c2 + -1.5707963267948966)) < 1e-16) {
          e[g2 >> 3] = 1.5707963267948966;
          e[f + 8 >> 3] = 0;
          return;
        }
        if (+q(+(c2 + 1.5707963267948966)) < 1e-16) {
          e[g2 >> 3] = -1.5707963267948966;
          e[f + 8 >> 3] = 0;
          return;
        }
        c2 = +e[a2 + 8 >> 3];
        if (c2 > 3.141592653589793) {
          do {
            c2 = c2 + -6.283185307179586;
          } while (c2 > 3.141592653589793);
        }
        if (c2 < -3.141592653589793) {
          do {
            c2 = c2 + 6.283185307179586;
          } while (c2 < -3.141592653589793);
        }
        e[f + 8 >> 3] = c2;
        return;
      }
      function nb(a2) {
        a2 = a2 | 0;
        return + +e[20496 + (a2 << 3) >> 3];
      }
      function ob(a2) {
        a2 = a2 | 0;
        return + +e[20624 + (a2 << 3) >> 3];
      }
      function pb(a2) {
        a2 = a2 | 0;
        return + +e[20752 + (a2 << 3) >> 3];
      }
      function qb(a2) {
        a2 = a2 | 0;
        return + +e[20880 + (a2 << 3) >> 3];
      }
      function rb(a2) {
        a2 = a2 | 0;
        var c2 = 0;
        c2 = 21008 + (a2 << 3) | 0;
        a2 = b[c2 >> 2] | 0;
        F(b[c2 + 4 >> 2] | 0);
        return a2 | 0;
      }
      function sb(a2, b2, c2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        c2 = c2 | 0;
        var d2 = 0, f = 0, g2 = 0, h = 0, i2 = 0, j = 0, k = 0, l = 0, m = 0, n = 0;
        n = +e[b2 >> 3];
        l = +e[a2 >> 3];
        j = +u(+((n - l) * 0.5));
        g2 = +e[b2 + 8 >> 3];
        k = +e[a2 + 8 >> 3];
        h = +u(+((g2 - k) * 0.5));
        i2 = +t(+l);
        m = +t(+n);
        h = j * j + h * (m * i2 * h);
        h = +z(+ +r(+h), + +r(+(1 - h))) * 2;
        j = +e[c2 >> 3];
        n = +u(+((j - n) * 0.5));
        d2 = +e[c2 + 8 >> 3];
        g2 = +u(+((d2 - g2) * 0.5));
        f = +t(+j);
        g2 = n * n + g2 * (m * f * g2);
        g2 = +z(+ +r(+g2), + +r(+(1 - g2))) * 2;
        j = +u(+((l - j) * 0.5));
        d2 = +u(+((k - d2) * 0.5));
        d2 = j * j + d2 * (i2 * f * d2);
        d2 = +z(+ +r(+d2), + +r(+(1 - d2))) * 2;
        f = (h + g2 + d2) * 0.5;
        return +(+y2(+ +r(+(+v(+(f * 0.5)) * +v(+((f - h) * 0.5)) * +v(+((f - g2) * 0.5)) * +v(+((f - d2) * 0.5))))) * 4);
      }
      function tb(a2, c2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        var d2 = 0, e2 = 0, f = 0, g2 = 0, h = 0;
        g2 = S;
        S = S + 192 | 0;
        e2 = g2 + 168 | 0;
        f = g2;
        Vb(a2, c2, e2);
        Wb(a2, c2, f);
        c2 = b[f >> 2] | 0;
        if ((c2 | 0) <= 0) {
          d2 = 0;
          S = g2;
          return +d2;
        }
        d2 = +sb(f + 8 | 0, f + 8 + (((c2 | 0) != 1 & 1) << 4) | 0, e2) + 0;
        if ((c2 | 0) == 1) {
          S = g2;
          return +d2;
        }
        a2 = 1;
        do {
          h = a2;
          a2 = a2 + 1 | 0;
          d2 = d2 + +sb(f + 8 + (h << 4) | 0, f + 8 + (((a2 | 0) % (c2 | 0) | 0) << 4) | 0, e2);
        } while ((a2 | 0) < (c2 | 0));
        S = g2;
        return +d2;
      }
      function ub(a2, c2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        var d2 = 0, e2 = 0, f = 0, g2 = 0, h = 0;
        g2 = S;
        S = S + 192 | 0;
        e2 = g2 + 168 | 0;
        f = g2;
        Vb(a2, c2, e2);
        Wb(a2, c2, f);
        c2 = b[f >> 2] | 0;
        if ((c2 | 0) > 0) {
          d2 = +sb(f + 8 | 0, f + 8 + (((c2 | 0) != 1 & 1) << 4) | 0, e2) + 0;
          if ((c2 | 0) != 1) {
            a2 = 1;
            do {
              h = a2;
              a2 = a2 + 1 | 0;
              d2 = d2 + +sb(f + 8 + (h << 4) | 0, f + 8 + (((a2 | 0) % (c2 | 0) | 0) << 4) | 0, e2);
            } while ((a2 | 0) < (c2 | 0));
          }
        } else {
          d2 = 0;
        }
        S = g2;
        return +(d2 * 6371.007180918475 * 6371.007180918475);
      }
      function vb(a2, c2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        var d2 = 0, e2 = 0, f = 0, g2 = 0, h = 0;
        g2 = S;
        S = S + 192 | 0;
        e2 = g2 + 168 | 0;
        f = g2;
        Vb(a2, c2, e2);
        Wb(a2, c2, f);
        c2 = b[f >> 2] | 0;
        if ((c2 | 0) > 0) {
          d2 = +sb(f + 8 | 0, f + 8 + (((c2 | 0) != 1 & 1) << 4) | 0, e2) + 0;
          if ((c2 | 0) != 1) {
            a2 = 1;
            do {
              h = a2;
              a2 = a2 + 1 | 0;
              d2 = d2 + +sb(f + 8 + (h << 4) | 0, f + 8 + (((a2 | 0) % (c2 | 0) | 0) << 4) | 0, e2);
            } while ((a2 | 0) < (c2 | 0));
          }
        } else {
          d2 = 0;
        }
        S = g2;
        return +(d2 * 6371.007180918475 * 6371.007180918475 * 1e3 * 1e3);
      }
      function wb(a2, c2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        var d2 = 0, f = 0, g2 = 0, h = 0, i2 = 0, j = 0, k = 0, l = 0;
        i2 = S;
        S = S + 176 | 0;
        h = i2;
        gc(a2, c2, h);
        a2 = b[h >> 2] | 0;
        if ((a2 | 0) <= 1) {
          g2 = 0;
          S = i2;
          return +g2;
        }
        c2 = a2 + -1 | 0;
        a2 = 0;
        d2 = 0;
        f = +e[h + 8 >> 3];
        g2 = +e[h + 16 >> 3];
        do {
          a2 = a2 + 1 | 0;
          k = f;
          f = +e[h + 8 + (a2 << 4) >> 3];
          l = +u(+((f - k) * 0.5));
          j = g2;
          g2 = +e[h + 8 + (a2 << 4) + 8 >> 3];
          j = +u(+((g2 - j) * 0.5));
          j = l * l + j * (+t(+f) * +t(+k) * j);
          d2 = d2 + +z(+ +r(+j), + +r(+(1 - j))) * 2;
        } while ((a2 | 0) < (c2 | 0));
        S = i2;
        return +d2;
      }
      function xb(a2, c2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        var d2 = 0, f = 0, g2 = 0, h = 0, i2 = 0, j = 0, k = 0, l = 0;
        i2 = S;
        S = S + 176 | 0;
        h = i2;
        gc(a2, c2, h);
        a2 = b[h >> 2] | 0;
        if ((a2 | 0) <= 1) {
          g2 = 0;
          S = i2;
          return +g2;
        }
        c2 = a2 + -1 | 0;
        a2 = 0;
        d2 = 0;
        f = +e[h + 8 >> 3];
        g2 = +e[h + 16 >> 3];
        do {
          a2 = a2 + 1 | 0;
          k = f;
          f = +e[h + 8 + (a2 << 4) >> 3];
          l = +u(+((f - k) * 0.5));
          j = g2;
          g2 = +e[h + 8 + (a2 << 4) + 8 >> 3];
          j = +u(+((g2 - j) * 0.5));
          j = l * l + j * (+t(+k) * +t(+f) * j);
          d2 = d2 + +z(+ +r(+j), + +r(+(1 - j))) * 2;
        } while ((a2 | 0) != (c2 | 0));
        l = d2 * 6371.007180918475;
        S = i2;
        return +l;
      }
      function yb(a2, c2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        var d2 = 0, f = 0, g2 = 0, h = 0, i2 = 0, j = 0, k = 0, l = 0;
        i2 = S;
        S = S + 176 | 0;
        h = i2;
        gc(a2, c2, h);
        a2 = b[h >> 2] | 0;
        if ((a2 | 0) <= 1) {
          g2 = 0;
          S = i2;
          return +g2;
        }
        c2 = a2 + -1 | 0;
        a2 = 0;
        d2 = 0;
        f = +e[h + 8 >> 3];
        g2 = +e[h + 16 >> 3];
        do {
          a2 = a2 + 1 | 0;
          k = f;
          f = +e[h + 8 + (a2 << 4) >> 3];
          l = +u(+((f - k) * 0.5));
          j = g2;
          g2 = +e[h + 8 + (a2 << 4) + 8 >> 3];
          j = +u(+((g2 - j) * 0.5));
          j = l * l + j * (+t(+k) * +t(+f) * j);
          d2 = d2 + +z(+ +r(+j), + +r(+(1 - j))) * 2;
        } while ((a2 | 0) != (c2 | 0));
        l = d2 * 6371.007180918475 * 1e3;
        S = i2;
        return +l;
      }
      function zb(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        b2 = cd(a2 | 0, b2 | 0, 52) | 0;
        G() | 0;
        return b2 & 15 | 0;
      }
      function Ab(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        b2 = cd(a2 | 0, b2 | 0, 45) | 0;
        G() | 0;
        return b2 & 127 | 0;
      }
      function Bb(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        var c2 = 0, d2 = 0, e2 = 0, f = 0, g2 = 0, h = 0;
        if (!(true & (b2 & -16777216 | 0) == 134217728)) {
          b2 = 0;
          return b2 | 0;
        }
        g2 = cd(a2 | 0, b2 | 0, 45) | 0;
        G() | 0;
        g2 = g2 & 127;
        if (g2 >>> 0 > 121) {
          b2 = 0;
          return b2 | 0;
        }
        c2 = cd(a2 | 0, b2 | 0, 52) | 0;
        G() | 0;
        c2 = c2 & 15;
        do {
          if (c2 | 0) {
            e2 = 1;
            d2 = 0;
            while (1) {
              f = cd(a2 | 0, b2 | 0, (15 - e2 | 0) * 3 | 0) | 0;
              G() | 0;
              f = f & 7;
              if ((f | 0) != 0 & (d2 ^ 1)) {
                if ((f | 0) == 1 & (la(g2) | 0) != 0) {
                  h = 0;
                  d2 = 13;
                  break;
                } else {
                  d2 = 1;
                }
              }
              if ((f | 0) == 7) {
                h = 0;
                d2 = 13;
                break;
              }
              if (e2 >>> 0 < c2 >>> 0) {
                e2 = e2 + 1 | 0;
              } else {
                d2 = 9;
                break;
              }
            }
            if ((d2 | 0) == 9) {
              if ((c2 | 0) == 15) {
                h = 1;
              } else {
                break;
              }
              return h | 0;
            } else if ((d2 | 0) == 13) {
              return h | 0;
            }
          }
        } while (0);
        while (1) {
          h = cd(a2 | 0, b2 | 0, (14 - c2 | 0) * 3 | 0) | 0;
          G() | 0;
          if (!((h & 7 | 0) == 7 & true)) {
            h = 0;
            d2 = 13;
            break;
          }
          if (c2 >>> 0 < 14) {
            c2 = c2 + 1 | 0;
          } else {
            h = 1;
            d2 = 13;
            break;
          }
        }
        if ((d2 | 0) == 13) {
          return h | 0;
        }
        return 0;
      }
      function Cb(a2, b2, c2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        c2 = c2 | 0;
        var d2 = 0, e2 = 0;
        d2 = cd(a2 | 0, b2 | 0, 52) | 0;
        G() | 0;
        d2 = d2 & 15;
        if ((d2 | 0) >= (c2 | 0)) {
          if ((d2 | 0) != (c2 | 0)) {
            if (c2 >>> 0 <= 15) {
              e2 = dd(c2 | 0, 0, 52) | 0;
              a2 = e2 | a2;
              b2 = G() | 0 | b2 & -15728641;
              if ((d2 | 0) > (c2 | 0)) {
                do {
                  e2 = dd(7, 0, (14 - c2 | 0) * 3 | 0) | 0;
                  c2 = c2 + 1 | 0;
                  a2 = e2 | a2;
                  b2 = G() | 0 | b2;
                } while ((c2 | 0) < (d2 | 0));
              }
            } else {
              b2 = 0;
              a2 = 0;
            }
          }
        } else {
          b2 = 0;
          a2 = 0;
        }
        F(b2 | 0);
        return a2 | 0;
      }
      function Db(a2, b2, c2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        c2 = c2 | 0;
        a2 = cd(a2 | 0, b2 | 0, 52) | 0;
        G() | 0;
        a2 = a2 & 15;
        if (!((c2 | 0) < 16 & (a2 | 0) <= (c2 | 0))) {
          c2 = 0;
          return c2 | 0;
        }
        c2 = tc(7, c2 - a2 | 0) | 0;
        return c2 | 0;
      }
      function Eb(a2, c2, d2, e2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        var f = 0, g2 = 0, h = 0, i2 = 0, j = 0, k = 0, l = 0;
        h = cd(a2 | 0, c2 | 0, 52) | 0;
        G() | 0;
        h = h & 15;
        if (!((d2 | 0) < 16 & (h | 0) <= (d2 | 0))) {
          return;
        }
        if ((h | 0) == (d2 | 0)) {
          d2 = e2;
          b[d2 >> 2] = a2;
          b[d2 + 4 >> 2] = c2;
          return;
        }
        j = tc(7, d2 - h | 0) | 0;
        k = (j | 0) / 7 | 0;
        i2 = cd(a2 | 0, c2 | 0, 45) | 0;
        G() | 0;
        if (!(la(i2 & 127) | 0)) {
          g2 = 0;
        } else {
          a:
            do {
              if (!h) {
                f = 0;
              } else {
                g2 = 1;
                while (1) {
                  f = cd(a2 | 0, c2 | 0, (15 - g2 | 0) * 3 | 0) | 0;
                  G() | 0;
                  f = f & 7;
                  if (f | 0) {
                    break a;
                  }
                  if (g2 >>> 0 < h >>> 0) {
                    g2 = g2 + 1 | 0;
                  } else {
                    f = 0;
                    break;
                  }
                }
              }
            } while (0);
          g2 = (f | 0) == 0;
        }
        l = dd(h + 1 | 0, 0, 52) | 0;
        f = G() | 0 | c2 & -15728641;
        i2 = (14 - h | 0) * 3 | 0;
        c2 = dd(7, 0, i2 | 0) | 0;
        c2 = (l | a2) & ~c2;
        h = f & ~(G() | 0);
        Eb(c2, h, d2, e2);
        f = e2 + (k << 3) | 0;
        if (!g2) {
          l = dd(1, 0, i2 | 0) | 0;
          Eb(l | c2, G() | 0 | h, d2, f);
          l = f + (k << 3) | 0;
          j = dd(2, 0, i2 | 0) | 0;
          Eb(j | c2, G() | 0 | h, d2, l);
          l = l + (k << 3) | 0;
          j = dd(3, 0, i2 | 0) | 0;
          Eb(j | c2, G() | 0 | h, d2, l);
          l = l + (k << 3) | 0;
          j = dd(4, 0, i2 | 0) | 0;
          Eb(j | c2, G() | 0 | h, d2, l);
          l = l + (k << 3) | 0;
          j = dd(5, 0, i2 | 0) | 0;
          Eb(j | c2, G() | 0 | h, d2, l);
          j = dd(6, 0, i2 | 0) | 0;
          Eb(j | c2, G() | 0 | h, d2, l + (k << 3) | 0);
          return;
        }
        g2 = f + (k << 3) | 0;
        if ((j | 0) > 6) {
          j = f + 8 | 0;
          l = (g2 >>> 0 > j >>> 0 ? g2 : j) + -1 + (0 - f) | 0;
          hd(f | 0, 0, l + 8 & -8 | 0) | 0;
          f = j + (l >>> 3 << 3) | 0;
        }
        l = dd(2, 0, i2 | 0) | 0;
        Eb(l | c2, G() | 0 | h, d2, f);
        l = f + (k << 3) | 0;
        j = dd(3, 0, i2 | 0) | 0;
        Eb(j | c2, G() | 0 | h, d2, l);
        l = l + (k << 3) | 0;
        j = dd(4, 0, i2 | 0) | 0;
        Eb(j | c2, G() | 0 | h, d2, l);
        l = l + (k << 3) | 0;
        j = dd(5, 0, i2 | 0) | 0;
        Eb(j | c2, G() | 0 | h, d2, l);
        j = dd(6, 0, i2 | 0) | 0;
        Eb(j | c2, G() | 0 | h, d2, l + (k << 3) | 0);
        return;
      }
      function Fb(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        var c2 = 0, d2 = 0, e2 = 0;
        e2 = cd(a2 | 0, b2 | 0, 45) | 0;
        G() | 0;
        if (!(la(e2 & 127) | 0)) {
          e2 = 0;
          return e2 | 0;
        }
        e2 = cd(a2 | 0, b2 | 0, 52) | 0;
        G() | 0;
        e2 = e2 & 15;
        a:
          do {
            if (!e2) {
              c2 = 0;
            } else {
              d2 = 1;
              while (1) {
                c2 = cd(a2 | 0, b2 | 0, (15 - d2 | 0) * 3 | 0) | 0;
                G() | 0;
                c2 = c2 & 7;
                if (c2 | 0) {
                  break a;
                }
                if (d2 >>> 0 < e2 >>> 0) {
                  d2 = d2 + 1 | 0;
                } else {
                  c2 = 0;
                  break;
                }
              }
            }
          } while (0);
        e2 = (c2 | 0) == 0 & 1;
        return e2 | 0;
      }
      function Gb(a2, b2, c2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        c2 = c2 | 0;
        var d2 = 0, e2 = 0;
        d2 = cd(a2 | 0, b2 | 0, 52) | 0;
        G() | 0;
        d2 = d2 & 15;
        if ((c2 | 0) < 16 & (d2 | 0) <= (c2 | 0)) {
          if ((d2 | 0) != (c2 | 0)) {
            e2 = dd(c2 | 0, 0, 52) | 0;
            a2 = e2 | a2;
            b2 = G() | 0 | b2 & -15728641;
            if ((d2 | 0) < (c2 | 0)) {
              do {
                e2 = dd(7, 0, (14 - d2 | 0) * 3 | 0) | 0;
                d2 = d2 + 1 | 0;
                a2 = a2 & ~e2;
                b2 = b2 & ~(G() | 0);
              } while ((d2 | 0) < (c2 | 0));
            }
          }
        } else {
          b2 = 0;
          a2 = 0;
        }
        F(b2 | 0);
        return a2 | 0;
      }
      function Hb(a2, c2, d2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        var e2 = 0, f = 0, g2 = 0, h = 0, i2 = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t2 = 0, u2 = 0, v2 = 0, w2 = 0, x3 = 0, y3 = 0, z2 = 0;
        if (!d2) {
          y3 = 0;
          return y3 | 0;
        }
        f = a2;
        e2 = b[f >> 2] | 0;
        f = b[f + 4 >> 2] | 0;
        if (true & (f & 15728640 | 0) == 0) {
          if ((d2 | 0) <= 0) {
            y3 = 0;
            return y3 | 0;
          }
          y3 = c2;
          b[y3 >> 2] = e2;
          b[y3 + 4 >> 2] = f;
          if ((d2 | 0) == 1) {
            y3 = 0;
            return y3 | 0;
          }
          e2 = 1;
          do {
            w2 = a2 + (e2 << 3) | 0;
            x3 = b[w2 + 4 >> 2] | 0;
            y3 = c2 + (e2 << 3) | 0;
            b[y3 >> 2] = b[w2 >> 2];
            b[y3 + 4 >> 2] = x3;
            e2 = e2 + 1 | 0;
          } while ((e2 | 0) != (d2 | 0));
          e2 = 0;
          return e2 | 0;
        }
        w2 = d2 << 3;
        x3 = Wc(w2) | 0;
        if (!x3) {
          y3 = -3;
          return y3 | 0;
        }
        gd(x3 | 0, a2 | 0, w2 | 0) | 0;
        v2 = Yc(d2, 8) | 0;
        if (!v2) {
          Xc(x3);
          y3 = -3;
          return y3 | 0;
        }
        e2 = d2;
        a:
          while (1) {
            h = x3;
            l = b[h >> 2] | 0;
            h = b[h + 4 >> 2] | 0;
            t2 = cd(l | 0, h | 0, 52) | 0;
            G() | 0;
            t2 = t2 & 15;
            u2 = t2 + -1 | 0;
            s2 = (e2 | 0) > 0;
            b:
              do {
                if (s2) {
                  r2 = ((e2 | 0) < 0) << 31 >> 31;
                  p2 = dd(u2 | 0, 0, 52) | 0;
                  q2 = G() | 0;
                  if (u2 >>> 0 > 15) {
                    f = 0;
                    a2 = l;
                    d2 = h;
                    while (1) {
                      if (!((a2 | 0) == 0 & (d2 | 0) == 0)) {
                        g2 = cd(a2 | 0, d2 | 0, 52) | 0;
                        G() | 0;
                        g2 = g2 & 15;
                        i2 = (g2 | 0) < (u2 | 0);
                        g2 = (g2 | 0) == (u2 | 0);
                        k = i2 ? 0 : g2 ? a2 : 0;
                        a2 = i2 ? 0 : g2 ? d2 : 0;
                        d2 = bd(k | 0, a2 | 0, e2 | 0, r2 | 0) | 0;
                        G() | 0;
                        g2 = v2 + (d2 << 3) | 0;
                        i2 = g2;
                        j = b[i2 >> 2] | 0;
                        i2 = b[i2 + 4 >> 2] | 0;
                        if ((j | 0) == 0 & (i2 | 0) == 0) {
                          d2 = k;
                        } else {
                          p2 = 0;
                          o = d2;
                          n = i2;
                          d2 = k;
                          while (1) {
                            if ((p2 | 0) > (e2 | 0)) {
                              y3 = 41;
                              break a;
                            }
                            if ((j | 0) == (d2 | 0) & (n & -117440513 | 0) == (a2 | 0)) {
                              k = cd(j | 0, n | 0, 56) | 0;
                              G() | 0;
                              k = k & 7;
                              m = k + 1 | 0;
                              q2 = cd(j | 0, n | 0, 45) | 0;
                              G() | 0;
                              c:
                                do {
                                  if (!(la(q2 & 127) | 0)) {
                                    i2 = 7;
                                  } else {
                                    j = cd(j | 0, n | 0, 52) | 0;
                                    G() | 0;
                                    j = j & 15;
                                    if (!j) {
                                      i2 = 6;
                                      break;
                                    }
                                    i2 = 1;
                                    while (1) {
                                      q2 = dd(7, 0, (15 - i2 | 0) * 3 | 0) | 0;
                                      if (!((q2 & d2 | 0) == 0 & ((G() | 0) & a2 | 0) == 0)) {
                                        i2 = 7;
                                        break c;
                                      }
                                      if (i2 >>> 0 < j >>> 0) {
                                        i2 = i2 + 1 | 0;
                                      } else {
                                        i2 = 6;
                                        break;
                                      }
                                    }
                                  }
                                } while (0);
                              if ((k + 2 | 0) >>> 0 > i2 >>> 0) {
                                y3 = 51;
                                break a;
                              }
                              q2 = dd(m | 0, 0, 56) | 0;
                              a2 = G() | 0 | a2 & -117440513;
                              i2 = g2;
                              b[i2 >> 2] = 0;
                              b[i2 + 4 >> 2] = 0;
                              i2 = o;
                              d2 = q2 | d2;
                            } else {
                              i2 = (o + 1 | 0) % (e2 | 0) | 0;
                            }
                            g2 = v2 + (i2 << 3) | 0;
                            n = g2;
                            j = b[n >> 2] | 0;
                            n = b[n + 4 >> 2] | 0;
                            if ((j | 0) == 0 & (n | 0) == 0) {
                              break;
                            } else {
                              p2 = p2 + 1 | 0;
                              o = i2;
                            }
                          }
                        }
                        q2 = g2;
                        b[q2 >> 2] = d2;
                        b[q2 + 4 >> 2] = a2;
                      }
                      f = f + 1 | 0;
                      if ((f | 0) >= (e2 | 0)) {
                        break b;
                      }
                      d2 = x3 + (f << 3) | 0;
                      a2 = b[d2 >> 2] | 0;
                      d2 = b[d2 + 4 >> 2] | 0;
                    }
                  }
                  f = 0;
                  a2 = l;
                  d2 = h;
                  while (1) {
                    if (!((a2 | 0) == 0 & (d2 | 0) == 0)) {
                      i2 = cd(a2 | 0, d2 | 0, 52) | 0;
                      G() | 0;
                      i2 = i2 & 15;
                      if ((i2 | 0) >= (u2 | 0)) {
                        if ((i2 | 0) != (u2 | 0)) {
                          a2 = a2 | p2;
                          d2 = d2 & -15728641 | q2;
                          if (i2 >>> 0 >= t2 >>> 0) {
                            g2 = u2;
                            do {
                              o = dd(7, 0, (14 - g2 | 0) * 3 | 0) | 0;
                              g2 = g2 + 1 | 0;
                              a2 = o | a2;
                              d2 = G() | 0 | d2;
                            } while (g2 >>> 0 < i2 >>> 0);
                          }
                        }
                      } else {
                        a2 = 0;
                        d2 = 0;
                      }
                      i2 = bd(a2 | 0, d2 | 0, e2 | 0, r2 | 0) | 0;
                      G() | 0;
                      g2 = v2 + (i2 << 3) | 0;
                      j = g2;
                      k = b[j >> 2] | 0;
                      j = b[j + 4 >> 2] | 0;
                      if (!((k | 0) == 0 & (j | 0) == 0)) {
                        o = 0;
                        while (1) {
                          if ((o | 0) > (e2 | 0)) {
                            y3 = 41;
                            break a;
                          }
                          if ((k | 0) == (a2 | 0) & (j & -117440513 | 0) == (d2 | 0)) {
                            m = cd(k | 0, j | 0, 56) | 0;
                            G() | 0;
                            m = m & 7;
                            n = m + 1 | 0;
                            z2 = cd(k | 0, j | 0, 45) | 0;
                            G() | 0;
                            d:
                              do {
                                if (!(la(z2 & 127) | 0)) {
                                  j = 7;
                                } else {
                                  k = cd(k | 0, j | 0, 52) | 0;
                                  G() | 0;
                                  k = k & 15;
                                  if (!k) {
                                    j = 6;
                                    break;
                                  }
                                  j = 1;
                                  while (1) {
                                    z2 = dd(7, 0, (15 - j | 0) * 3 | 0) | 0;
                                    if (!((z2 & a2 | 0) == 0 & ((G() | 0) & d2 | 0) == 0)) {
                                      j = 7;
                                      break d;
                                    }
                                    if (j >>> 0 < k >>> 0) {
                                      j = j + 1 | 0;
                                    } else {
                                      j = 6;
                                      break;
                                    }
                                  }
                                }
                              } while (0);
                            if ((m + 2 | 0) >>> 0 > j >>> 0) {
                              y3 = 51;
                              break a;
                            }
                            z2 = dd(n | 0, 0, 56) | 0;
                            d2 = G() | 0 | d2 & -117440513;
                            n = g2;
                            b[n >> 2] = 0;
                            b[n + 4 >> 2] = 0;
                            a2 = z2 | a2;
                          } else {
                            i2 = (i2 + 1 | 0) % (e2 | 0) | 0;
                          }
                          g2 = v2 + (i2 << 3) | 0;
                          j = g2;
                          k = b[j >> 2] | 0;
                          j = b[j + 4 >> 2] | 0;
                          if ((k | 0) == 0 & (j | 0) == 0) {
                            break;
                          } else {
                            o = o + 1 | 0;
                          }
                        }
                      }
                      z2 = g2;
                      b[z2 >> 2] = a2;
                      b[z2 + 4 >> 2] = d2;
                    }
                    f = f + 1 | 0;
                    if ((f | 0) >= (e2 | 0)) {
                      break b;
                    }
                    d2 = x3 + (f << 3) | 0;
                    a2 = b[d2 >> 2] | 0;
                    d2 = b[d2 + 4 >> 2] | 0;
                  }
                }
              } while (0);
            if ((e2 + 5 | 0) >>> 0 < 11) {
              y3 = 99;
              break;
            }
            q2 = Yc((e2 | 0) / 6 | 0, 8) | 0;
            if (!q2) {
              y3 = 58;
              break;
            }
            e:
              do {
                if (s2) {
                  o = 0;
                  n = 0;
                  do {
                    i2 = v2 + (o << 3) | 0;
                    a2 = i2;
                    f = b[a2 >> 2] | 0;
                    a2 = b[a2 + 4 >> 2] | 0;
                    if (!((f | 0) == 0 & (a2 | 0) == 0)) {
                      j = cd(f | 0, a2 | 0, 56) | 0;
                      G() | 0;
                      j = j & 7;
                      d2 = j + 1 | 0;
                      k = a2 & -117440513;
                      z2 = cd(f | 0, a2 | 0, 45) | 0;
                      G() | 0;
                      f:
                        do {
                          if (la(z2 & 127) | 0) {
                            m = cd(f | 0, a2 | 0, 52) | 0;
                            G() | 0;
                            m = m & 15;
                            if (m | 0) {
                              g2 = 1;
                              while (1) {
                                z2 = dd(7, 0, (15 - g2 | 0) * 3 | 0) | 0;
                                if (!((f & z2 | 0) == 0 & (k & (G() | 0) | 0) == 0)) {
                                  break f;
                                }
                                if (g2 >>> 0 < m >>> 0) {
                                  g2 = g2 + 1 | 0;
                                } else {
                                  break;
                                }
                              }
                            }
                            a2 = dd(d2 | 0, 0, 56) | 0;
                            f = a2 | f;
                            a2 = G() | 0 | k;
                            d2 = i2;
                            b[d2 >> 2] = f;
                            b[d2 + 4 >> 2] = a2;
                            d2 = j + 2 | 0;
                          }
                        } while (0);
                      if ((d2 | 0) == 7) {
                        z2 = q2 + (n << 3) | 0;
                        b[z2 >> 2] = f;
                        b[z2 + 4 >> 2] = a2 & -117440513;
                        n = n + 1 | 0;
                      }
                    }
                    o = o + 1 | 0;
                  } while ((o | 0) != (e2 | 0));
                  if (s2) {
                    p2 = ((e2 | 0) < 0) << 31 >> 31;
                    m = dd(u2 | 0, 0, 52) | 0;
                    o = G() | 0;
                    if (u2 >>> 0 > 15) {
                      a2 = 0;
                      f = 0;
                      while (1) {
                        do {
                          if (!((l | 0) == 0 & (h | 0) == 0)) {
                            j = cd(l | 0, h | 0, 52) | 0;
                            G() | 0;
                            j = j & 15;
                            g2 = (j | 0) < (u2 | 0);
                            j = (j | 0) == (u2 | 0);
                            i2 = g2 ? 0 : j ? l : 0;
                            j = g2 ? 0 : j ? h : 0;
                            g2 = bd(i2 | 0, j | 0, e2 | 0, p2 | 0) | 0;
                            G() | 0;
                            d2 = 0;
                            while (1) {
                              if ((d2 | 0) > (e2 | 0)) {
                                y3 = 98;
                                break a;
                              }
                              z2 = v2 + (g2 << 3) | 0;
                              k = b[z2 + 4 >> 2] | 0;
                              if ((k & -117440513 | 0) == (j | 0) ? (b[z2 >> 2] | 0) == (i2 | 0) : 0) {
                                y3 = 70;
                                break;
                              }
                              g2 = (g2 + 1 | 0) % (e2 | 0) | 0;
                              z2 = v2 + (g2 << 3) | 0;
                              if ((b[z2 >> 2] | 0) == (i2 | 0) ? (b[z2 + 4 >> 2] | 0) == (j | 0) : 0) {
                                break;
                              } else {
                                d2 = d2 + 1 | 0;
                              }
                            }
                            if ((y3 | 0) == 70 ? (y3 = 0, true & (k & 117440512 | 0) == 100663296) : 0) {
                              break;
                            }
                            z2 = c2 + (f << 3) | 0;
                            b[z2 >> 2] = l;
                            b[z2 + 4 >> 2] = h;
                            f = f + 1 | 0;
                          }
                        } while (0);
                        a2 = a2 + 1 | 0;
                        if ((a2 | 0) >= (e2 | 0)) {
                          e2 = n;
                          break e;
                        }
                        h = x3 + (a2 << 3) | 0;
                        l = b[h >> 2] | 0;
                        h = b[h + 4 >> 2] | 0;
                      }
                    }
                    a2 = 0;
                    f = 0;
                    while (1) {
                      do {
                        if (!((l | 0) == 0 & (h | 0) == 0)) {
                          j = cd(l | 0, h | 0, 52) | 0;
                          G() | 0;
                          j = j & 15;
                          if ((j | 0) >= (u2 | 0)) {
                            if ((j | 0) != (u2 | 0)) {
                              d2 = l | m;
                              g2 = h & -15728641 | o;
                              if (j >>> 0 < t2 >>> 0) {
                                j = g2;
                              } else {
                                i2 = u2;
                                do {
                                  z2 = dd(7, 0, (14 - i2 | 0) * 3 | 0) | 0;
                                  i2 = i2 + 1 | 0;
                                  d2 = z2 | d2;
                                  g2 = G() | 0 | g2;
                                } while (i2 >>> 0 < j >>> 0);
                                j = g2;
                              }
                            } else {
                              d2 = l;
                              j = h;
                            }
                          } else {
                            d2 = 0;
                            j = 0;
                          }
                          i2 = bd(d2 | 0, j | 0, e2 | 0, p2 | 0) | 0;
                          G() | 0;
                          g2 = 0;
                          while (1) {
                            if ((g2 | 0) > (e2 | 0)) {
                              y3 = 98;
                              break a;
                            }
                            z2 = v2 + (i2 << 3) | 0;
                            k = b[z2 + 4 >> 2] | 0;
                            if ((k & -117440513 | 0) == (j | 0) ? (b[z2 >> 2] | 0) == (d2 | 0) : 0) {
                              y3 = 93;
                              break;
                            }
                            i2 = (i2 + 1 | 0) % (e2 | 0) | 0;
                            z2 = v2 + (i2 << 3) | 0;
                            if ((b[z2 >> 2] | 0) == (d2 | 0) ? (b[z2 + 4 >> 2] | 0) == (j | 0) : 0) {
                              break;
                            } else {
                              g2 = g2 + 1 | 0;
                            }
                          }
                          if ((y3 | 0) == 93 ? (y3 = 0, true & (k & 117440512 | 0) == 100663296) : 0) {
                            break;
                          }
                          z2 = c2 + (f << 3) | 0;
                          b[z2 >> 2] = l;
                          b[z2 + 4 >> 2] = h;
                          f = f + 1 | 0;
                        }
                      } while (0);
                      a2 = a2 + 1 | 0;
                      if ((a2 | 0) >= (e2 | 0)) {
                        e2 = n;
                        break e;
                      }
                      h = x3 + (a2 << 3) | 0;
                      l = b[h >> 2] | 0;
                      h = b[h + 4 >> 2] | 0;
                    }
                  } else {
                    f = 0;
                    e2 = n;
                  }
                } else {
                  f = 0;
                  e2 = 0;
                }
              } while (0);
            hd(v2 | 0, 0, w2 | 0) | 0;
            gd(x3 | 0, q2 | 0, e2 << 3 | 0) | 0;
            Xc(q2);
            if (!e2) {
              break;
            } else {
              c2 = c2 + (f << 3) | 0;
            }
          }
        if ((y3 | 0) == 41) {
          Xc(x3);
          Xc(v2);
          z2 = -1;
          return z2 | 0;
        } else if ((y3 | 0) == 51) {
          Xc(x3);
          Xc(v2);
          z2 = -2;
          return z2 | 0;
        } else if ((y3 | 0) == 58) {
          Xc(x3);
          Xc(v2);
          z2 = -3;
          return z2 | 0;
        } else if ((y3 | 0) == 98) {
          Xc(q2);
          Xc(x3);
          Xc(v2);
          z2 = -1;
          return z2 | 0;
        } else if ((y3 | 0) == 99) {
          gd(c2 | 0, x3 | 0, e2 << 3 | 0) | 0;
        }
        Xc(x3);
        Xc(v2);
        z2 = 0;
        return z2 | 0;
      }
      function Ib(a2, c2, d2, e2, f) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        f = f | 0;
        var g2 = 0, h = 0, i2 = 0, j = 0, k = 0, l = 0;
        if ((c2 | 0) <= 0) {
          f = 0;
          return f | 0;
        }
        if ((f | 0) >= 16) {
          g2 = 0;
          while (1) {
            l = a2 + (g2 << 3) | 0;
            if (!((b[l >> 2] | 0) == 0 & (b[l + 4 >> 2] | 0) == 0)) {
              g2 = 14;
              break;
            }
            g2 = g2 + 1 | 0;
            if ((g2 | 0) >= (c2 | 0)) {
              h = 0;
              g2 = 16;
              break;
            }
          }
          if ((g2 | 0) == 14) {
            return ((e2 | 0) > 0 ? -2 : -1) | 0;
          } else if ((g2 | 0) == 16) {
            return h | 0;
          }
        }
        g2 = 0;
        l = 0;
        a:
          while (1) {
            k = a2 + (l << 3) | 0;
            i2 = k;
            h = b[i2 >> 2] | 0;
            i2 = b[i2 + 4 >> 2] | 0;
            do {
              if (!((h | 0) == 0 & (i2 | 0) == 0)) {
                if ((g2 | 0) >= (e2 | 0)) {
                  h = -1;
                  g2 = 16;
                  break a;
                }
                j = cd(h | 0, i2 | 0, 52) | 0;
                G() | 0;
                j = j & 15;
                if ((j | 0) > (f | 0)) {
                  h = -2;
                  g2 = 16;
                  break a;
                }
                if ((j | 0) == (f | 0)) {
                  k = d2 + (g2 << 3) | 0;
                  b[k >> 2] = h;
                  b[k + 4 >> 2] = i2;
                  g2 = g2 + 1 | 0;
                  break;
                }
                h = (tc(7, f - j | 0) | 0) + g2 | 0;
                if ((h | 0) > (e2 | 0)) {
                  h = -1;
                  g2 = 16;
                  break a;
                }
                Eb(b[k >> 2] | 0, b[k + 4 >> 2] | 0, f, d2 + (g2 << 3) | 0);
                g2 = h;
              }
            } while (0);
            l = l + 1 | 0;
            if ((l | 0) >= (c2 | 0)) {
              h = 0;
              g2 = 16;
              break;
            }
          }
        if ((g2 | 0) == 16) {
          return h | 0;
        }
        return 0;
      }
      function Jb(a2, c2, d2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        var e2 = 0, f = 0, g2 = 0, h = 0;
        if ((c2 | 0) <= 0) {
          d2 = 0;
          return d2 | 0;
        }
        if ((d2 | 0) >= 16) {
          e2 = 0;
          while (1) {
            h = a2 + (e2 << 3) | 0;
            if (!((b[h >> 2] | 0) == 0 & (b[h + 4 >> 2] | 0) == 0)) {
              e2 = -1;
              f = 13;
              break;
            }
            e2 = e2 + 1 | 0;
            if ((e2 | 0) >= (c2 | 0)) {
              e2 = 0;
              f = 13;
              break;
            }
          }
          if ((f | 0) == 13) {
            return e2 | 0;
          }
        }
        e2 = 0;
        h = 0;
        a:
          while (1) {
            f = a2 + (h << 3) | 0;
            g2 = b[f >> 2] | 0;
            f = b[f + 4 >> 2] | 0;
            do {
              if (!((g2 | 0) == 0 & (f | 0) == 0)) {
                f = cd(g2 | 0, f | 0, 52) | 0;
                G() | 0;
                f = f & 15;
                if ((f | 0) > (d2 | 0)) {
                  e2 = -1;
                  f = 13;
                  break a;
                }
                if ((f | 0) == (d2 | 0)) {
                  e2 = e2 + 1 | 0;
                  break;
                } else {
                  e2 = (tc(7, d2 - f | 0) | 0) + e2 | 0;
                  break;
                }
              }
            } while (0);
            h = h + 1 | 0;
            if ((h | 0) >= (c2 | 0)) {
              f = 13;
              break;
            }
          }
        if ((f | 0) == 13) {
          return e2 | 0;
        }
        return 0;
      }
      function Kb(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        b2 = cd(a2 | 0, b2 | 0, 52) | 0;
        G() | 0;
        return b2 & 1 | 0;
      }
      function Lb(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        var c2 = 0, d2 = 0, e2 = 0;
        e2 = cd(a2 | 0, b2 | 0, 52) | 0;
        G() | 0;
        e2 = e2 & 15;
        if (!e2) {
          e2 = 0;
          return e2 | 0;
        }
        d2 = 1;
        while (1) {
          c2 = cd(a2 | 0, b2 | 0, (15 - d2 | 0) * 3 | 0) | 0;
          G() | 0;
          c2 = c2 & 7;
          if (c2 | 0) {
            d2 = 5;
            break;
          }
          if (d2 >>> 0 < e2 >>> 0) {
            d2 = d2 + 1 | 0;
          } else {
            c2 = 0;
            d2 = 5;
            break;
          }
        }
        if ((d2 | 0) == 5) {
          return c2 | 0;
        }
        return 0;
      }
      function Mb(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        var c2 = 0, d2 = 0, e2 = 0, f = 0, g2 = 0, h = 0, i2 = 0;
        i2 = cd(a2 | 0, b2 | 0, 52) | 0;
        G() | 0;
        i2 = i2 & 15;
        if (!i2) {
          h = b2;
          i2 = a2;
          F(h | 0);
          return i2 | 0;
        }
        h = 1;
        c2 = 0;
        while (1) {
          f = (15 - h | 0) * 3 | 0;
          d2 = dd(7, 0, f | 0) | 0;
          e2 = G() | 0;
          g2 = cd(a2 | 0, b2 | 0, f | 0) | 0;
          G() | 0;
          f = dd(Pa(g2 & 7) | 0, 0, f | 0) | 0;
          g2 = G() | 0;
          a2 = f | a2 & ~d2;
          b2 = g2 | b2 & ~e2;
          a:
            do {
              if (!c2) {
                if (!((f & d2 | 0) == 0 & (g2 & e2 | 0) == 0)) {
                  d2 = cd(a2 | 0, b2 | 0, 52) | 0;
                  G() | 0;
                  d2 = d2 & 15;
                  if (!d2) {
                    c2 = 1;
                  } else {
                    c2 = 1;
                    b:
                      while (1) {
                        g2 = cd(a2 | 0, b2 | 0, (15 - c2 | 0) * 3 | 0) | 0;
                        G() | 0;
                        switch (g2 & 7) {
                          case 1:
                            break b;
                          case 0:
                            break;
                          default: {
                            c2 = 1;
                            break a;
                          }
                        }
                        if (c2 >>> 0 < d2 >>> 0) {
                          c2 = c2 + 1 | 0;
                        } else {
                          c2 = 1;
                          break a;
                        }
                      }
                    c2 = 1;
                    while (1) {
                      g2 = (15 - c2 | 0) * 3 | 0;
                      e2 = cd(a2 | 0, b2 | 0, g2 | 0) | 0;
                      G() | 0;
                      f = dd(7, 0, g2 | 0) | 0;
                      b2 = b2 & ~(G() | 0);
                      g2 = dd(Pa(e2 & 7) | 0, 0, g2 | 0) | 0;
                      a2 = a2 & ~f | g2;
                      b2 = b2 | (G() | 0);
                      if (c2 >>> 0 < d2 >>> 0) {
                        c2 = c2 + 1 | 0;
                      } else {
                        c2 = 1;
                        break;
                      }
                    }
                  }
                } else {
                  c2 = 0;
                }
              }
            } while (0);
          if (h >>> 0 < i2 >>> 0) {
            h = h + 1 | 0;
          } else {
            break;
          }
        }
        F(b2 | 0);
        return a2 | 0;
      }
      function Nb(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        var c2 = 0, d2 = 0, e2 = 0, f = 0, g2 = 0;
        d2 = cd(a2 | 0, b2 | 0, 52) | 0;
        G() | 0;
        d2 = d2 & 15;
        if (!d2) {
          c2 = b2;
          d2 = a2;
          F(c2 | 0);
          return d2 | 0;
        }
        c2 = 1;
        while (1) {
          f = (15 - c2 | 0) * 3 | 0;
          g2 = cd(a2 | 0, b2 | 0, f | 0) | 0;
          G() | 0;
          e2 = dd(7, 0, f | 0) | 0;
          b2 = b2 & ~(G() | 0);
          f = dd(Pa(g2 & 7) | 0, 0, f | 0) | 0;
          a2 = f | a2 & ~e2;
          b2 = G() | 0 | b2;
          if (c2 >>> 0 < d2 >>> 0) {
            c2 = c2 + 1 | 0;
          } else {
            break;
          }
        }
        F(b2 | 0);
        return a2 | 0;
      }
      function Ob(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        var c2 = 0, d2 = 0, e2 = 0, f = 0, g2 = 0, h = 0, i2 = 0;
        i2 = cd(a2 | 0, b2 | 0, 52) | 0;
        G() | 0;
        i2 = i2 & 15;
        if (!i2) {
          h = b2;
          i2 = a2;
          F(h | 0);
          return i2 | 0;
        }
        h = 1;
        c2 = 0;
        while (1) {
          f = (15 - h | 0) * 3 | 0;
          d2 = dd(7, 0, f | 0) | 0;
          e2 = G() | 0;
          g2 = cd(a2 | 0, b2 | 0, f | 0) | 0;
          G() | 0;
          f = dd(Qa(g2 & 7) | 0, 0, f | 0) | 0;
          g2 = G() | 0;
          a2 = f | a2 & ~d2;
          b2 = g2 | b2 & ~e2;
          a:
            do {
              if (!c2) {
                if (!((f & d2 | 0) == 0 & (g2 & e2 | 0) == 0)) {
                  d2 = cd(a2 | 0, b2 | 0, 52) | 0;
                  G() | 0;
                  d2 = d2 & 15;
                  if (!d2) {
                    c2 = 1;
                  } else {
                    c2 = 1;
                    b:
                      while (1) {
                        g2 = cd(a2 | 0, b2 | 0, (15 - c2 | 0) * 3 | 0) | 0;
                        G() | 0;
                        switch (g2 & 7) {
                          case 1:
                            break b;
                          case 0:
                            break;
                          default: {
                            c2 = 1;
                            break a;
                          }
                        }
                        if (c2 >>> 0 < d2 >>> 0) {
                          c2 = c2 + 1 | 0;
                        } else {
                          c2 = 1;
                          break a;
                        }
                      }
                    c2 = 1;
                    while (1) {
                      e2 = (15 - c2 | 0) * 3 | 0;
                      f = dd(7, 0, e2 | 0) | 0;
                      g2 = b2 & ~(G() | 0);
                      b2 = cd(a2 | 0, b2 | 0, e2 | 0) | 0;
                      G() | 0;
                      b2 = dd(Qa(b2 & 7) | 0, 0, e2 | 0) | 0;
                      a2 = a2 & ~f | b2;
                      b2 = g2 | (G() | 0);
                      if (c2 >>> 0 < d2 >>> 0) {
                        c2 = c2 + 1 | 0;
                      } else {
                        c2 = 1;
                        break;
                      }
                    }
                  }
                } else {
                  c2 = 0;
                }
              }
            } while (0);
          if (h >>> 0 < i2 >>> 0) {
            h = h + 1 | 0;
          } else {
            break;
          }
        }
        F(b2 | 0);
        return a2 | 0;
      }
      function Pb(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        var c2 = 0, d2 = 0, e2 = 0, f = 0, g2 = 0;
        d2 = cd(a2 | 0, b2 | 0, 52) | 0;
        G() | 0;
        d2 = d2 & 15;
        if (!d2) {
          c2 = b2;
          d2 = a2;
          F(c2 | 0);
          return d2 | 0;
        }
        c2 = 1;
        while (1) {
          g2 = (15 - c2 | 0) * 3 | 0;
          f = dd(7, 0, g2 | 0) | 0;
          e2 = b2 & ~(G() | 0);
          b2 = cd(a2 | 0, b2 | 0, g2 | 0) | 0;
          G() | 0;
          b2 = dd(Qa(b2 & 7) | 0, 0, g2 | 0) | 0;
          a2 = b2 | a2 & ~f;
          b2 = G() | 0 | e2;
          if (c2 >>> 0 < d2 >>> 0) {
            c2 = c2 + 1 | 0;
          } else {
            break;
          }
        }
        F(b2 | 0);
        return a2 | 0;
      }
      function Qb(a2, c2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        var d2 = 0, e2 = 0, f = 0, g2 = 0, h = 0, i2 = 0, j = 0, k = 0, l = 0;
        j = S;
        S = S + 64 | 0;
        i2 = j + 40 | 0;
        e2 = j + 24 | 0;
        f = j + 12 | 0;
        g2 = j;
        dd(c2 | 0, 0, 52) | 0;
        d2 = G() | 0 | 134225919;
        if (!c2) {
          if ((b[a2 + 4 >> 2] | 0) > 2) {
            h = 0;
            i2 = 0;
            F(h | 0);
            S = j;
            return i2 | 0;
          }
          if ((b[a2 + 8 >> 2] | 0) > 2) {
            h = 0;
            i2 = 0;
            F(h | 0);
            S = j;
            return i2 | 0;
          }
          if ((b[a2 + 12 >> 2] | 0) > 2) {
            h = 0;
            i2 = 0;
            F(h | 0);
            S = j;
            return i2 | 0;
          }
          dd(na(a2) | 0, 0, 45) | 0;
          h = G() | 0 | d2;
          i2 = -1;
          F(h | 0);
          S = j;
          return i2 | 0;
        }
        b[i2 >> 2] = b[a2 >> 2];
        b[i2 + 4 >> 2] = b[a2 + 4 >> 2];
        b[i2 + 8 >> 2] = b[a2 + 8 >> 2];
        b[i2 + 12 >> 2] = b[a2 + 12 >> 2];
        h = i2 + 4 | 0;
        if ((c2 | 0) > 0) {
          a2 = -1;
          while (1) {
            b[e2 >> 2] = b[h >> 2];
            b[e2 + 4 >> 2] = b[h + 4 >> 2];
            b[e2 + 8 >> 2] = b[h + 8 >> 2];
            if (!(c2 & 1)) {
              Ja(h);
              b[f >> 2] = b[h >> 2];
              b[f + 4 >> 2] = b[h + 4 >> 2];
              b[f + 8 >> 2] = b[h + 8 >> 2];
              La(f);
            } else {
              Ia(h);
              b[f >> 2] = b[h >> 2];
              b[f + 4 >> 2] = b[h + 4 >> 2];
              b[f + 8 >> 2] = b[h + 8 >> 2];
              Ka(f);
            }
            Fa(e2, f, g2);
            Ca(g2);
            l = (15 - c2 | 0) * 3 | 0;
            k = dd(7, 0, l | 0) | 0;
            d2 = d2 & ~(G() | 0);
            l = dd(Ha(g2) | 0, 0, l | 0) | 0;
            a2 = l | a2 & ~k;
            d2 = G() | 0 | d2;
            if ((c2 | 0) > 1) {
              c2 = c2 + -1 | 0;
            } else {
              break;
            }
          }
        } else {
          a2 = -1;
        }
        a:
          do {
            if (((b[h >> 2] | 0) <= 2 ? (b[i2 + 8 >> 2] | 0) <= 2 : 0) ? (b[i2 + 12 >> 2] | 0) <= 2 : 0) {
              e2 = na(i2) | 0;
              c2 = dd(e2 | 0, 0, 45) | 0;
              c2 = c2 | a2;
              a2 = G() | 0 | d2 & -1040385;
              g2 = oa(i2) | 0;
              if (!(la(e2) | 0)) {
                if ((g2 | 0) <= 0) {
                  break;
                }
                f = 0;
                while (1) {
                  e2 = cd(c2 | 0, a2 | 0, 52) | 0;
                  G() | 0;
                  e2 = e2 & 15;
                  if (e2) {
                    d2 = 1;
                    while (1) {
                      l = (15 - d2 | 0) * 3 | 0;
                      i2 = cd(c2 | 0, a2 | 0, l | 0) | 0;
                      G() | 0;
                      k = dd(7, 0, l | 0) | 0;
                      a2 = a2 & ~(G() | 0);
                      l = dd(Pa(i2 & 7) | 0, 0, l | 0) | 0;
                      c2 = c2 & ~k | l;
                      a2 = a2 | (G() | 0);
                      if (d2 >>> 0 < e2 >>> 0) {
                        d2 = d2 + 1 | 0;
                      } else {
                        break;
                      }
                    }
                  }
                  f = f + 1 | 0;
                  if ((f | 0) == (g2 | 0)) {
                    break a;
                  }
                }
              }
              f = cd(c2 | 0, a2 | 0, 52) | 0;
              G() | 0;
              f = f & 15;
              b:
                do {
                  if (f) {
                    d2 = 1;
                    c:
                      while (1) {
                        l = cd(c2 | 0, a2 | 0, (15 - d2 | 0) * 3 | 0) | 0;
                        G() | 0;
                        switch (l & 7) {
                          case 1:
                            break c;
                          case 0:
                            break;
                          default:
                            break b;
                        }
                        if (d2 >>> 0 < f >>> 0) {
                          d2 = d2 + 1 | 0;
                        } else {
                          break b;
                        }
                      }
                    if (ra(e2, b[i2 >> 2] | 0) | 0) {
                      d2 = 1;
                      while (1) {
                        i2 = (15 - d2 | 0) * 3 | 0;
                        k = dd(7, 0, i2 | 0) | 0;
                        l = a2 & ~(G() | 0);
                        a2 = cd(c2 | 0, a2 | 0, i2 | 0) | 0;
                        G() | 0;
                        a2 = dd(Qa(a2 & 7) | 0, 0, i2 | 0) | 0;
                        c2 = c2 & ~k | a2;
                        a2 = l | (G() | 0);
                        if (d2 >>> 0 < f >>> 0) {
                          d2 = d2 + 1 | 0;
                        } else {
                          break;
                        }
                      }
                    } else {
                      d2 = 1;
                      while (1) {
                        l = (15 - d2 | 0) * 3 | 0;
                        i2 = cd(c2 | 0, a2 | 0, l | 0) | 0;
                        G() | 0;
                        k = dd(7, 0, l | 0) | 0;
                        a2 = a2 & ~(G() | 0);
                        l = dd(Pa(i2 & 7) | 0, 0, l | 0) | 0;
                        c2 = c2 & ~k | l;
                        a2 = a2 | (G() | 0);
                        if (d2 >>> 0 < f >>> 0) {
                          d2 = d2 + 1 | 0;
                        } else {
                          break;
                        }
                      }
                    }
                  }
                } while (0);
              if ((g2 | 0) > 0) {
                d2 = 0;
                do {
                  c2 = Mb(c2, a2) | 0;
                  a2 = G() | 0;
                  d2 = d2 + 1 | 0;
                } while ((d2 | 0) != (g2 | 0));
              }
            } else {
              c2 = 0;
              a2 = 0;
            }
          } while (0);
        k = a2;
        l = c2;
        F(k | 0);
        S = j;
        return l | 0;
      }
      function Rb(a2) {
        a2 = a2 | 0;
        return (a2 | 0) % 2 | 0 | 0;
      }
      function Sb(a2, c2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        var d2 = 0, e2 = 0;
        e2 = S;
        S = S + 16 | 0;
        d2 = e2;
        if ((c2 >>> 0 <= 15 ? !((b[a2 + 4 >> 2] & 2146435072 | 0) == 2146435072) : 0) ? !((b[a2 + 8 + 4 >> 2] & 2146435072 | 0) == 2146435072) : 0) {
          Ya(a2, c2, d2);
          c2 = Qb(d2, c2) | 0;
          a2 = G() | 0;
        } else {
          a2 = 0;
          c2 = 0;
        }
        F(a2 | 0);
        S = e2;
        return c2 | 0;
      }
      function Tb(a2, c2, d2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        var e2 = 0, f = 0, g2 = 0, h = 0;
        f = d2 + 4 | 0;
        g2 = cd(a2 | 0, c2 | 0, 52) | 0;
        G() | 0;
        g2 = g2 & 15;
        h = cd(a2 | 0, c2 | 0, 45) | 0;
        G() | 0;
        e2 = (g2 | 0) == 0;
        if (!(la(h & 127) | 0)) {
          if (e2) {
            h = 0;
            return h | 0;
          }
          if ((b[f >> 2] | 0) == 0 ? (b[d2 + 8 >> 2] | 0) == 0 : 0) {
            e2 = (b[d2 + 12 >> 2] | 0) != 0 & 1;
          } else {
            e2 = 1;
          }
        } else if (e2) {
          h = 1;
          return h | 0;
        } else {
          e2 = 1;
        }
        d2 = 1;
        while (1) {
          if (!(d2 & 1)) {
            La(f);
          } else {
            Ka(f);
          }
          h = cd(a2 | 0, c2 | 0, (15 - d2 | 0) * 3 | 0) | 0;
          G() | 0;
          Ma(f, h & 7);
          if (d2 >>> 0 < g2 >>> 0) {
            d2 = d2 + 1 | 0;
          } else {
            break;
          }
        }
        return e2 | 0;
      }
      function Ub(a2, c2, d2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        var e2 = 0, f = 0, g2 = 0, h = 0, i2 = 0, j = 0, k = 0, l = 0;
        l = S;
        S = S + 16 | 0;
        j = l;
        k = cd(a2 | 0, c2 | 0, 45) | 0;
        G() | 0;
        k = k & 127;
        a:
          do {
            if ((la(k) | 0) != 0 ? (g2 = cd(a2 | 0, c2 | 0, 52) | 0, G() | 0, g2 = g2 & 15, (g2 | 0) != 0) : 0) {
              e2 = 1;
              b:
                while (1) {
                  i2 = cd(a2 | 0, c2 | 0, (15 - e2 | 0) * 3 | 0) | 0;
                  G() | 0;
                  switch (i2 & 7) {
                    case 5:
                      break b;
                    case 0:
                      break;
                    default: {
                      e2 = c2;
                      break a;
                    }
                  }
                  if (e2 >>> 0 < g2 >>> 0) {
                    e2 = e2 + 1 | 0;
                  } else {
                    e2 = c2;
                    break a;
                  }
                }
              f = 1;
              e2 = c2;
              while (1) {
                c2 = (15 - f | 0) * 3 | 0;
                h = dd(7, 0, c2 | 0) | 0;
                i2 = e2 & ~(G() | 0);
                e2 = cd(a2 | 0, e2 | 0, c2 | 0) | 0;
                G() | 0;
                e2 = dd(Qa(e2 & 7) | 0, 0, c2 | 0) | 0;
                a2 = a2 & ~h | e2;
                e2 = i2 | (G() | 0);
                if (f >>> 0 < g2 >>> 0) {
                  f = f + 1 | 0;
                } else {
                  break;
                }
              }
            } else {
              e2 = c2;
            }
          } while (0);
        i2 = 7728 + (k * 28 | 0) | 0;
        b[d2 >> 2] = b[i2 >> 2];
        b[d2 + 4 >> 2] = b[i2 + 4 >> 2];
        b[d2 + 8 >> 2] = b[i2 + 8 >> 2];
        b[d2 + 12 >> 2] = b[i2 + 12 >> 2];
        if (!(Tb(a2, e2, d2) | 0)) {
          S = l;
          return;
        }
        h = d2 + 4 | 0;
        b[j >> 2] = b[h >> 2];
        b[j + 4 >> 2] = b[h + 4 >> 2];
        b[j + 8 >> 2] = b[h + 8 >> 2];
        g2 = cd(a2 | 0, e2 | 0, 52) | 0;
        G() | 0;
        i2 = g2 & 15;
        if (!(g2 & 1)) {
          g2 = i2;
        } else {
          La(h);
          g2 = i2 + 1 | 0;
        }
        if (!(la(k) | 0)) {
          e2 = 0;
        } else {
          c:
            do {
              if (!i2) {
                e2 = 0;
              } else {
                c2 = 1;
                while (1) {
                  f = cd(a2 | 0, e2 | 0, (15 - c2 | 0) * 3 | 0) | 0;
                  G() | 0;
                  f = f & 7;
                  if (f | 0) {
                    e2 = f;
                    break c;
                  }
                  if (c2 >>> 0 < i2 >>> 0) {
                    c2 = c2 + 1 | 0;
                  } else {
                    e2 = 0;
                    break;
                  }
                }
              }
            } while (0);
          e2 = (e2 | 0) == 4 & 1;
        }
        if (!(cb(d2, g2, e2, 0) | 0)) {
          if ((g2 | 0) != (i2 | 0)) {
            b[h >> 2] = b[j >> 2];
            b[h + 4 >> 2] = b[j + 4 >> 2];
            b[h + 8 >> 2] = b[j + 8 >> 2];
          }
        } else {
          if (la(k) | 0) {
            do {
            } while ((cb(d2, g2, 0, 0) | 0) != 0);
          }
          if ((g2 | 0) != (i2 | 0)) {
            Ja(h);
          }
        }
        S = l;
        return;
      }
      function Vb(a2, b2, c2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        c2 = c2 | 0;
        var d2 = 0, e2 = 0;
        d2 = S;
        S = S + 16 | 0;
        e2 = d2;
        Ub(a2, b2, e2);
        b2 = cd(a2 | 0, b2 | 0, 52) | 0;
        G() | 0;
        $a(e2, b2 & 15, c2);
        S = d2;
        return;
      }
      function Wb(a2, b2, c2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        c2 = c2 | 0;
        var d2 = 0, e2 = 0, f = 0, g2 = 0, h = 0;
        g2 = S;
        S = S + 16 | 0;
        f = g2;
        Ub(a2, b2, f);
        d2 = cd(a2 | 0, b2 | 0, 45) | 0;
        G() | 0;
        d2 = (la(d2 & 127) | 0) == 0;
        e2 = cd(a2 | 0, b2 | 0, 52) | 0;
        G() | 0;
        e2 = e2 & 15;
        a:
          do {
            if (!d2) {
              if (e2 | 0) {
                d2 = 1;
                while (1) {
                  h = dd(7, 0, (15 - d2 | 0) * 3 | 0) | 0;
                  if (!((h & a2 | 0) == 0 & ((G() | 0) & b2 | 0) == 0)) {
                    break a;
                  }
                  if (d2 >>> 0 < e2 >>> 0) {
                    d2 = d2 + 1 | 0;
                  } else {
                    break;
                  }
                }
              }
              ab(f, e2, 0, 5, c2);
              S = g2;
              return;
            }
          } while (0);
        eb(f, e2, 0, 6, c2);
        S = g2;
        return;
      }
      function Xb(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        var c2 = 0, d2 = 0, e2 = 0;
        d2 = cd(a2 | 0, b2 | 0, 45) | 0;
        G() | 0;
        if (!(la(d2 & 127) | 0)) {
          d2 = 2;
          return d2 | 0;
        }
        d2 = cd(a2 | 0, b2 | 0, 52) | 0;
        G() | 0;
        d2 = d2 & 15;
        if (!d2) {
          d2 = 5;
          return d2 | 0;
        }
        c2 = 1;
        while (1) {
          e2 = dd(7, 0, (15 - c2 | 0) * 3 | 0) | 0;
          if (!((e2 & a2 | 0) == 0 & ((G() | 0) & b2 | 0) == 0)) {
            c2 = 2;
            a2 = 6;
            break;
          }
          if (c2 >>> 0 < d2 >>> 0) {
            c2 = c2 + 1 | 0;
          } else {
            c2 = 5;
            a2 = 6;
            break;
          }
        }
        if ((a2 | 0) == 6) {
          return c2 | 0;
        }
        return 0;
      }
      function Yb(a2, c2, d2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        var e2 = 0, f = 0, g2 = 0, h = 0, i2 = 0, j = 0, k = 0, l = 0, m = 0;
        m = S;
        S = S + 128 | 0;
        k = m + 112 | 0;
        g2 = m + 96 | 0;
        l = m;
        f = cd(a2 | 0, c2 | 0, 52) | 0;
        G() | 0;
        i2 = f & 15;
        b[k >> 2] = i2;
        h = cd(a2 | 0, c2 | 0, 45) | 0;
        G() | 0;
        h = h & 127;
        a:
          do {
            if (la(h) | 0) {
              if (i2 | 0) {
                e2 = 1;
                while (1) {
                  j = dd(7, 0, (15 - e2 | 0) * 3 | 0) | 0;
                  if (!((j & a2 | 0) == 0 & ((G() | 0) & c2 | 0) == 0)) {
                    f = 0;
                    break a;
                  }
                  if (e2 >>> 0 < i2 >>> 0) {
                    e2 = e2 + 1 | 0;
                  } else {
                    break;
                  }
                }
              }
              if (!(f & 1)) {
                j = dd(i2 + 1 | 0, 0, 52) | 0;
                l = G() | 0 | c2 & -15728641;
                k = dd(7, 0, (14 - i2 | 0) * 3 | 0) | 0;
                Yb((j | a2) & ~k, l & ~(G() | 0), d2);
                S = m;
                return;
              } else {
                f = 1;
              }
            } else {
              f = 0;
            }
          } while (0);
        Ub(a2, c2, g2);
        if (f) {
          bb(g2, k, l);
          j = 5;
        } else {
          fb(g2, k, l);
          j = 6;
        }
        b:
          do {
            if (la(h) | 0) {
              if (!i2) {
                e2 = 20;
              } else {
                e2 = 1;
                while (1) {
                  h = dd(7, 0, (15 - e2 | 0) * 3 | 0) | 0;
                  if (!((h & a2 | 0) == 0 & ((G() | 0) & c2 | 0) == 0)) {
                    e2 = 8;
                    break b;
                  }
                  if (e2 >>> 0 < i2 >>> 0) {
                    e2 = e2 + 1 | 0;
                  } else {
                    e2 = 20;
                    break;
                  }
                }
              }
            } else {
              e2 = 8;
            }
          } while (0);
        hd(d2 | 0, -1, e2 | 0) | 0;
        if (f) {
          f = 0;
          do {
            g2 = l + (f << 4) | 0;
            db(g2, b[k >> 2] | 0) | 0;
            g2 = b[g2 >> 2] | 0;
            e2 = 0;
            while (1) {
              h = d2 + (e2 << 2) | 0;
              i2 = b[h >> 2] | 0;
              if ((i2 | 0) == -1 | (i2 | 0) == (g2 | 0)) {
                break;
              } else {
                e2 = e2 + 1 | 0;
              }
            }
            b[h >> 2] = g2;
            f = f + 1 | 0;
          } while ((f | 0) != (j | 0));
        } else {
          f = 0;
          do {
            g2 = l + (f << 4) | 0;
            cb(g2, b[k >> 2] | 0, 0, 1) | 0;
            g2 = b[g2 >> 2] | 0;
            e2 = 0;
            while (1) {
              h = d2 + (e2 << 2) | 0;
              i2 = b[h >> 2] | 0;
              if ((i2 | 0) == -1 | (i2 | 0) == (g2 | 0)) {
                break;
              } else {
                e2 = e2 + 1 | 0;
              }
            }
            b[h >> 2] = g2;
            f = f + 1 | 0;
          } while ((f | 0) != (j | 0));
        }
        S = m;
        return;
      }
      function Zb() {
        return 12;
      }
      function _b(a2, c2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        var d2 = 0, e2 = 0, f = 0, g2 = 0, h = 0, i2 = 0, j = 0;
        dd(a2 | 0, 0, 52) | 0;
        i2 = G() | 0 | 134225919;
        if ((a2 | 0) < 1) {
          e2 = 0;
          d2 = 0;
          do {
            if (la(e2) | 0) {
              dd(e2 | 0, 0, 45) | 0;
              h = i2 | (G() | 0);
              a2 = c2 + (d2 << 3) | 0;
              b[a2 >> 2] = -1;
              b[a2 + 4 >> 2] = h;
              d2 = d2 + 1 | 0;
            }
            e2 = e2 + 1 | 0;
          } while ((e2 | 0) != 122);
          return;
        }
        h = 0;
        d2 = 0;
        do {
          if (la(h) | 0) {
            dd(h | 0, 0, 45) | 0;
            e2 = 1;
            f = -1;
            g2 = i2 | (G() | 0);
            while (1) {
              j = dd(7, 0, (15 - e2 | 0) * 3 | 0) | 0;
              f = f & ~j;
              g2 = g2 & ~(G() | 0);
              if ((e2 | 0) == (a2 | 0)) {
                break;
              } else {
                e2 = e2 + 1 | 0;
              }
            }
            j = c2 + (d2 << 3) | 0;
            b[j >> 2] = f;
            b[j + 4 >> 2] = g2;
            d2 = d2 + 1 | 0;
          }
          h = h + 1 | 0;
        } while ((h | 0) != 122);
        return;
      }
      function $b(a2, c2, d2, e2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        var f = 0, g2 = 0, h = 0, i2 = 0, j = 0, k = 0;
        i2 = S;
        S = S + 64 | 0;
        h = i2;
        if ((a2 | 0) == (d2 | 0) & (c2 | 0) == (e2 | 0) | (false | (c2 & 2013265920 | 0) != 134217728 | (false | (e2 & 2013265920 | 0) != 134217728))) {
          h = 0;
          S = i2;
          return h | 0;
        }
        f = cd(a2 | 0, c2 | 0, 52) | 0;
        G() | 0;
        f = f & 15;
        g2 = cd(d2 | 0, e2 | 0, 52) | 0;
        G() | 0;
        if ((f | 0) != (g2 & 15 | 0)) {
          h = 0;
          S = i2;
          return h | 0;
        }
        g2 = f + -1 | 0;
        if (f >>> 0 > 1 ? (k = Cb(a2, c2, g2) | 0, j = G() | 0, g2 = Cb(d2, e2, g2) | 0, (k | 0) == (g2 | 0) & (j | 0) == (G() | 0)) : 0) {
          g2 = (f ^ 15) * 3 | 0;
          f = cd(a2 | 0, c2 | 0, g2 | 0) | 0;
          G() | 0;
          f = f & 7;
          g2 = cd(d2 | 0, e2 | 0, g2 | 0) | 0;
          G() | 0;
          g2 = g2 & 7;
          if ((f | 0) == 0 | (g2 | 0) == 0) {
            k = 1;
            S = i2;
            return k | 0;
          }
          if ((b[21136 + (f << 2) >> 2] | 0) == (g2 | 0)) {
            k = 1;
            S = i2;
            return k | 0;
          }
          if ((b[21168 + (f << 2) >> 2] | 0) == (g2 | 0)) {
            k = 1;
            S = i2;
            return k | 0;
          }
        }
        f = h;
        g2 = f + 56 | 0;
        do {
          b[f >> 2] = 0;
          f = f + 4 | 0;
        } while ((f | 0) < (g2 | 0));
        $(a2, c2, 1, h);
        k = h;
        if (((((!((b[k >> 2] | 0) == (d2 | 0) ? (b[k + 4 >> 2] | 0) == (e2 | 0) : 0) ? (k = h + 8 | 0, !((b[k >> 2] | 0) == (d2 | 0) ? (b[k + 4 >> 2] | 0) == (e2 | 0) : 0)) : 0) ? (k = h + 16 | 0, !((b[k >> 2] | 0) == (d2 | 0) ? (b[k + 4 >> 2] | 0) == (e2 | 0) : 0)) : 0) ? (k = h + 24 | 0, !((b[k >> 2] | 0) == (d2 | 0) ? (b[k + 4 >> 2] | 0) == (e2 | 0) : 0)) : 0) ? (k = h + 32 | 0, !((b[k >> 2] | 0) == (d2 | 0) ? (b[k + 4 >> 2] | 0) == (e2 | 0) : 0)) : 0) ? (k = h + 40 | 0, !((b[k >> 2] | 0) == (d2 | 0) ? (b[k + 4 >> 2] | 0) == (e2 | 0) : 0)) : 0) {
          f = h + 48 | 0;
          f = ((b[f >> 2] | 0) == (d2 | 0) ? (b[f + 4 >> 2] | 0) == (e2 | 0) : 0) & 1;
        } else {
          f = 1;
        }
        k = f;
        S = i2;
        return k | 0;
      }
      function ac(a2, c2, d2, e2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        var f = 0, g2 = 0, h = 0, i2 = 0, j = 0, k = 0, l = 0;
        k = S;
        S = S + 16 | 0;
        h = k;
        if (!($b(a2, c2, d2, e2) | 0)) {
          i2 = 0;
          j = 0;
          F(i2 | 0);
          S = k;
          return j | 0;
        }
        i2 = c2 & -2130706433;
        f = (Fb(a2, c2) | 0) == 0;
        f = f ? 1 : 2;
        while (1) {
          b[h >> 2] = 0;
          l = da(a2, c2, f, h) | 0;
          g2 = f + 1 | 0;
          if ((l | 0) == (d2 | 0) & (G() | 0) == (e2 | 0)) {
            break;
          }
          if (g2 >>> 0 < 7) {
            f = g2;
          } else {
            f = 0;
            a2 = 0;
            j = 6;
            break;
          }
        }
        if ((j | 0) == 6) {
          F(f | 0);
          S = k;
          return a2 | 0;
        }
        l = dd(f | 0, 0, 56) | 0;
        j = i2 | (G() | 0) | 268435456;
        l = a2 | l;
        F(j | 0);
        S = k;
        return l | 0;
      }
      function bc(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        var c2 = 0;
        c2 = true & (b2 & 2013265920 | 0) == 268435456;
        F((c2 ? b2 & -2130706433 | 134217728 : 0) | 0);
        return (c2 ? a2 : 0) | 0;
      }
      function cc(a2, c2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        var d2 = 0, e2 = 0, f = 0;
        e2 = S;
        S = S + 16 | 0;
        d2 = e2;
        if (!(true & (c2 & 2013265920 | 0) == 268435456)) {
          c2 = 0;
          d2 = 0;
          F(c2 | 0);
          S = e2;
          return d2 | 0;
        }
        f = cd(a2 | 0, c2 | 0, 56) | 0;
        G() | 0;
        b[d2 >> 2] = 0;
        d2 = da(a2, c2 & -2130706433 | 134217728, f & 7, d2) | 0;
        c2 = G() | 0;
        F(c2 | 0);
        S = e2;
        return d2 | 0;
      }
      function dc(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        var c2 = 0;
        if (!(true & (b2 & 2013265920 | 0) == 268435456)) {
          c2 = 0;
          return c2 | 0;
        }
        c2 = cd(a2 | 0, b2 | 0, 56) | 0;
        G() | 0;
        switch (c2 & 7) {
          case 0:
          case 7: {
            c2 = 0;
            return c2 | 0;
          }
          default:
        }
        c2 = b2 & -2130706433 | 134217728;
        if (true & (b2 & 117440512 | 0) == 16777216 & (Fb(a2, c2) | 0) != 0) {
          c2 = 0;
          return c2 | 0;
        }
        c2 = Bb(a2, c2) | 0;
        return c2 | 0;
      }
      function ec(a2, c2, d2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        var e2 = 0, f = 0, g2 = 0, h = 0, i2 = 0;
        g2 = S;
        S = S + 16 | 0;
        e2 = g2;
        h = true & (c2 & 2013265920 | 0) == 268435456;
        f = c2 & -2130706433 | 134217728;
        i2 = d2;
        b[i2 >> 2] = h ? a2 : 0;
        b[i2 + 4 >> 2] = h ? f : 0;
        if (h) {
          c2 = cd(a2 | 0, c2 | 0, 56) | 0;
          G() | 0;
          b[e2 >> 2] = 0;
          a2 = da(a2, f, c2 & 7, e2) | 0;
          c2 = G() | 0;
        } else {
          a2 = 0;
          c2 = 0;
        }
        i2 = d2 + 8 | 0;
        b[i2 >> 2] = a2;
        b[i2 + 4 >> 2] = c2;
        S = g2;
        return;
      }
      function fc(a2, c2, d2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        var e2 = 0, f = 0;
        f = (Fb(a2, c2) | 0) == 0;
        c2 = c2 & -2130706433;
        e2 = d2;
        b[e2 >> 2] = f ? a2 : 0;
        b[e2 + 4 >> 2] = f ? c2 | 285212672 : 0;
        e2 = d2 + 8 | 0;
        b[e2 >> 2] = a2;
        b[e2 + 4 >> 2] = c2 | 301989888;
        e2 = d2 + 16 | 0;
        b[e2 >> 2] = a2;
        b[e2 + 4 >> 2] = c2 | 318767104;
        e2 = d2 + 24 | 0;
        b[e2 >> 2] = a2;
        b[e2 + 4 >> 2] = c2 | 335544320;
        e2 = d2 + 32 | 0;
        b[e2 >> 2] = a2;
        b[e2 + 4 >> 2] = c2 | 352321536;
        d2 = d2 + 40 | 0;
        b[d2 >> 2] = a2;
        b[d2 + 4 >> 2] = c2 | 369098752;
        return;
      }
      function gc(a2, c2, d2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        var e2 = 0, f = 0, g2 = 0, h = 0, i2 = 0;
        h = S;
        S = S + 16 | 0;
        g2 = h;
        e2 = cd(a2 | 0, c2 | 0, 56) | 0;
        G() | 0;
        i2 = true & (c2 & 2013265920 | 0) == 268435456;
        f = i2 ? a2 : 0;
        a2 = i2 ? c2 & -2130706433 | 134217728 : 0;
        c2 = Lc(f, a2, e2 & 7) | 0;
        if ((c2 | 0) == -1) {
          b[d2 >> 2] = 0;
          S = h;
          return;
        }
        Ub(f, a2, g2);
        e2 = cd(f | 0, a2 | 0, 52) | 0;
        G() | 0;
        e2 = e2 & 15;
        if (!(Fb(f, a2) | 0)) {
          eb(g2, e2, c2, 2, d2);
        } else {
          ab(g2, e2, c2, 2, d2);
        }
        S = h;
        return;
      }
      function hc(a2) {
        a2 = a2 | 0;
        var c2 = 0, d2 = 0, e2 = 0;
        c2 = Yc(1, 12) | 0;
        if (!c2) {
          H(22691, 22646, 49, 22704);
        }
        d2 = a2 + 4 | 0;
        e2 = b[d2 >> 2] | 0;
        if (e2 | 0) {
          e2 = e2 + 8 | 0;
          b[e2 >> 2] = c2;
          b[d2 >> 2] = c2;
          return c2 | 0;
        }
        if (b[a2 >> 2] | 0) {
          H(22721, 22646, 61, 22744);
        }
        e2 = a2;
        b[e2 >> 2] = c2;
        b[d2 >> 2] = c2;
        return c2 | 0;
      }
      function ic(a2, c2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        var d2 = 0, e2 = 0;
        e2 = Wc(24) | 0;
        if (!e2) {
          H(22758, 22646, 78, 22772);
        }
        b[e2 >> 2] = b[c2 >> 2];
        b[e2 + 4 >> 2] = b[c2 + 4 >> 2];
        b[e2 + 8 >> 2] = b[c2 + 8 >> 2];
        b[e2 + 12 >> 2] = b[c2 + 12 >> 2];
        b[e2 + 16 >> 2] = 0;
        c2 = a2 + 4 | 0;
        d2 = b[c2 >> 2] | 0;
        if (d2 | 0) {
          b[d2 + 16 >> 2] = e2;
          b[c2 >> 2] = e2;
          return e2 | 0;
        }
        if (b[a2 >> 2] | 0) {
          H(22787, 22646, 82, 22772);
        }
        b[a2 >> 2] = e2;
        b[c2 >> 2] = e2;
        return e2 | 0;
      }
      function jc(a2) {
        a2 = a2 | 0;
        var c2 = 0, d2 = 0, e2 = 0, f = 0;
        if (!a2) {
          return;
        }
        e2 = 1;
        while (1) {
          c2 = b[a2 >> 2] | 0;
          if (c2 | 0) {
            do {
              d2 = b[c2 >> 2] | 0;
              if (d2 | 0) {
                do {
                  f = d2;
                  d2 = b[d2 + 16 >> 2] | 0;
                  Xc(f);
                } while ((d2 | 0) != 0);
              }
              f = c2;
              c2 = b[c2 + 8 >> 2] | 0;
              Xc(f);
            } while ((c2 | 0) != 0);
          }
          c2 = a2;
          a2 = b[a2 + 8 >> 2] | 0;
          if (!e2) {
            Xc(c2);
          }
          if (!a2) {
            break;
          } else {
            e2 = 0;
          }
        }
        return;
      }
      function kc(a2) {
        a2 = a2 | 0;
        var c2 = 0, d2 = 0, f = 0, g2 = 0, h = 0, i2 = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, r2 = 0, s2 = 0, t2 = 0, u2 = 0, v2 = 0, w2 = 0, x3 = 0, y3 = 0, z2 = 0, A2 = 0, B2 = 0, C2 = 0, D2 = 0, E = 0, F2 = 0, G2 = 0, I2 = 0, J2 = 0, K2 = 0;
        g2 = a2 + 8 | 0;
        if (b[g2 >> 2] | 0) {
          K2 = 1;
          return K2 | 0;
        }
        f = b[a2 >> 2] | 0;
        if (!f) {
          K2 = 0;
          return K2 | 0;
        }
        c2 = f;
        d2 = 0;
        do {
          d2 = d2 + 1 | 0;
          c2 = b[c2 + 8 >> 2] | 0;
        } while ((c2 | 0) != 0);
        if (d2 >>> 0 < 2) {
          K2 = 0;
          return K2 | 0;
        }
        I2 = Wc(d2 << 2) | 0;
        if (!I2) {
          H(22807, 22646, 317, 22826);
        }
        G2 = Wc(d2 << 5) | 0;
        if (!G2) {
          H(22848, 22646, 321, 22826);
        }
        b[a2 >> 2] = 0;
        z2 = a2 + 4 | 0;
        b[z2 >> 2] = 0;
        b[g2 >> 2] = 0;
        d2 = 0;
        F2 = 0;
        y3 = 0;
        n = 0;
        a:
          while (1) {
            m = b[f >> 2] | 0;
            if (m) {
              h = 0;
              i2 = m;
              do {
                k = +e[i2 + 8 >> 3];
                c2 = i2;
                i2 = b[i2 + 16 >> 2] | 0;
                l = (i2 | 0) == 0;
                g2 = l ? m : i2;
                j = +e[g2 + 8 >> 3];
                if (+q(+(k - j)) > 3.141592653589793) {
                  K2 = 14;
                  break;
                }
                h = h + (j - k) * (+e[c2 >> 3] + +e[g2 >> 3]);
              } while (!l);
              if ((K2 | 0) == 14) {
                K2 = 0;
                h = 0;
                c2 = m;
                do {
                  x3 = +e[c2 + 8 >> 3];
                  E = c2 + 16 | 0;
                  D2 = b[E >> 2] | 0;
                  D2 = (D2 | 0) == 0 ? m : D2;
                  w2 = +e[D2 + 8 >> 3];
                  h = h + (+e[c2 >> 3] + +e[D2 >> 3]) * ((w2 < 0 ? w2 + 6.283185307179586 : w2) - (x3 < 0 ? x3 + 6.283185307179586 : x3));
                  c2 = b[((c2 | 0) == 0 ? f : E) >> 2] | 0;
                } while ((c2 | 0) != 0);
              }
              if (h > 0) {
                b[I2 + (F2 << 2) >> 2] = f;
                F2 = F2 + 1 | 0;
                g2 = y3;
                c2 = n;
              } else {
                K2 = 19;
              }
            } else {
              K2 = 19;
            }
            if ((K2 | 0) == 19) {
              K2 = 0;
              do {
                if (!d2) {
                  if (!n) {
                    if (!(b[a2 >> 2] | 0)) {
                      g2 = z2;
                      i2 = a2;
                      c2 = f;
                      d2 = a2;
                      break;
                    } else {
                      K2 = 27;
                      break a;
                    }
                  } else {
                    g2 = z2;
                    i2 = n + 8 | 0;
                    c2 = f;
                    d2 = a2;
                    break;
                  }
                } else {
                  c2 = d2 + 8 | 0;
                  if (b[c2 >> 2] | 0) {
                    K2 = 21;
                    break a;
                  }
                  d2 = Yc(1, 12) | 0;
                  if (!d2) {
                    K2 = 23;
                    break a;
                  }
                  b[c2 >> 2] = d2;
                  g2 = d2 + 4 | 0;
                  i2 = d2;
                  c2 = n;
                }
              } while (0);
              b[i2 >> 2] = f;
              b[g2 >> 2] = f;
              i2 = G2 + (y3 << 5) | 0;
              l = b[f >> 2] | 0;
              if (l) {
                m = G2 + (y3 << 5) + 8 | 0;
                e[m >> 3] = 17976931348623157e292;
                n = G2 + (y3 << 5) + 24 | 0;
                e[n >> 3] = 17976931348623157e292;
                e[i2 >> 3] = -17976931348623157e292;
                o = G2 + (y3 << 5) + 16 | 0;
                e[o >> 3] = -17976931348623157e292;
                u2 = 17976931348623157e292;
                v2 = -17976931348623157e292;
                g2 = 0;
                p2 = l;
                k = 17976931348623157e292;
                s2 = 17976931348623157e292;
                t2 = -17976931348623157e292;
                j = -17976931348623157e292;
                while (1) {
                  h = +e[p2 >> 3];
                  x3 = +e[p2 + 8 >> 3];
                  p2 = b[p2 + 16 >> 2] | 0;
                  r2 = (p2 | 0) == 0;
                  w2 = +e[(r2 ? l : p2) + 8 >> 3];
                  if (h < k) {
                    e[m >> 3] = h;
                    k = h;
                  }
                  if (x3 < s2) {
                    e[n >> 3] = x3;
                    s2 = x3;
                  }
                  if (h > t2) {
                    e[i2 >> 3] = h;
                  } else {
                    h = t2;
                  }
                  if (x3 > j) {
                    e[o >> 3] = x3;
                    j = x3;
                  }
                  u2 = x3 > 0 & x3 < u2 ? x3 : u2;
                  v2 = x3 < 0 & x3 > v2 ? x3 : v2;
                  g2 = g2 | +q(+(x3 - w2)) > 3.141592653589793;
                  if (r2) {
                    break;
                  } else {
                    t2 = h;
                  }
                }
                if (g2) {
                  e[o >> 3] = v2;
                  e[n >> 3] = u2;
                }
              } else {
                b[i2 >> 2] = 0;
                b[i2 + 4 >> 2] = 0;
                b[i2 + 8 >> 2] = 0;
                b[i2 + 12 >> 2] = 0;
                b[i2 + 16 >> 2] = 0;
                b[i2 + 20 >> 2] = 0;
                b[i2 + 24 >> 2] = 0;
                b[i2 + 28 >> 2] = 0;
              }
              g2 = y3 + 1 | 0;
            }
            E = f + 8 | 0;
            f = b[E >> 2] | 0;
            b[E >> 2] = 0;
            if (!f) {
              K2 = 45;
              break;
            } else {
              y3 = g2;
              n = c2;
            }
          }
        if ((K2 | 0) == 21) {
          H(22624, 22646, 35, 22658);
        } else if ((K2 | 0) == 23) {
          H(22678, 22646, 37, 22658);
        } else if ((K2 | 0) == 27) {
          H(22721, 22646, 61, 22744);
        } else if ((K2 | 0) == 45) {
          b:
            do {
              if ((F2 | 0) > 0) {
                E = (g2 | 0) == 0;
                C2 = g2 << 2;
                D2 = (a2 | 0) == 0;
                B2 = 0;
                c2 = 0;
                while (1) {
                  A2 = b[I2 + (B2 << 2) >> 2] | 0;
                  if (!E) {
                    y3 = Wc(C2) | 0;
                    if (!y3) {
                      K2 = 50;
                      break;
                    }
                    z2 = Wc(C2) | 0;
                    if (!z2) {
                      K2 = 52;
                      break;
                    }
                    c:
                      do {
                        if (!D2) {
                          g2 = 0;
                          d2 = 0;
                          i2 = a2;
                          while (1) {
                            f = G2 + (g2 << 5) | 0;
                            if (lc(b[i2 >> 2] | 0, f, b[A2 >> 2] | 0) | 0) {
                              b[y3 + (d2 << 2) >> 2] = i2;
                              b[z2 + (d2 << 2) >> 2] = f;
                              r2 = d2 + 1 | 0;
                            } else {
                              r2 = d2;
                            }
                            i2 = b[i2 + 8 >> 2] | 0;
                            if (!i2) {
                              break;
                            } else {
                              g2 = g2 + 1 | 0;
                              d2 = r2;
                            }
                          }
                          if ((r2 | 0) > 0) {
                            f = b[y3 >> 2] | 0;
                            if ((r2 | 0) == 1) {
                              d2 = f;
                            } else {
                              o = 0;
                              p2 = -1;
                              d2 = f;
                              n = f;
                              while (1) {
                                l = b[n >> 2] | 0;
                                f = 0;
                                i2 = 0;
                                while (1) {
                                  g2 = b[b[y3 + (i2 << 2) >> 2] >> 2] | 0;
                                  if ((g2 | 0) == (l | 0)) {
                                    m = f;
                                  } else {
                                    m = f + ((lc(g2, b[z2 + (i2 << 2) >> 2] | 0, b[l >> 2] | 0) | 0) & 1) | 0;
                                  }
                                  i2 = i2 + 1 | 0;
                                  if ((i2 | 0) == (r2 | 0)) {
                                    break;
                                  } else {
                                    f = m;
                                  }
                                }
                                g2 = (m | 0) > (p2 | 0);
                                d2 = g2 ? n : d2;
                                f = o + 1 | 0;
                                if ((f | 0) == (r2 | 0)) {
                                  break c;
                                }
                                o = f;
                                p2 = g2 ? m : p2;
                                n = b[y3 + (f << 2) >> 2] | 0;
                              }
                            }
                          } else {
                            d2 = 0;
                          }
                        } else {
                          d2 = 0;
                        }
                      } while (0);
                    Xc(y3);
                    Xc(z2);
                    if (d2) {
                      g2 = d2 + 4 | 0;
                      f = b[g2 >> 2] | 0;
                      if (!f) {
                        if (b[d2 >> 2] | 0) {
                          K2 = 70;
                          break;
                        }
                      } else {
                        d2 = f + 8 | 0;
                      }
                      b[d2 >> 2] = A2;
                      b[g2 >> 2] = A2;
                    } else {
                      K2 = 73;
                    }
                  } else {
                    K2 = 73;
                  }
                  if ((K2 | 0) == 73) {
                    K2 = 0;
                    c2 = b[A2 >> 2] | 0;
                    if (c2 | 0) {
                      do {
                        z2 = c2;
                        c2 = b[c2 + 16 >> 2] | 0;
                        Xc(z2);
                      } while ((c2 | 0) != 0);
                    }
                    Xc(A2);
                    c2 = 2;
                  }
                  B2 = B2 + 1 | 0;
                  if ((B2 | 0) >= (F2 | 0)) {
                    J2 = c2;
                    break b;
                  }
                }
                if ((K2 | 0) == 50) {
                  H(22863, 22646, 249, 22882);
                } else if ((K2 | 0) == 52) {
                  H(22901, 22646, 252, 22882);
                } else if ((K2 | 0) == 70) {
                  H(22721, 22646, 61, 22744);
                }
              } else {
                J2 = 0;
              }
            } while (0);
          Xc(I2);
          Xc(G2);
          K2 = J2;
          return K2 | 0;
        }
        return 0;
      }
      function lc(a2, c2, d2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        var f = 0, g2 = 0, h = 0, i2 = 0, j = 0, k = 0, l = 0, m = 0;
        if (!(xa(c2, d2) | 0)) {
          a2 = 0;
          return a2 | 0;
        }
        c2 = wa(c2) | 0;
        l = +e[d2 >> 3];
        f = +e[d2 + 8 >> 3];
        f = c2 & f < 0 ? f + 6.283185307179586 : f;
        a2 = b[a2 >> 2] | 0;
        if (!a2) {
          a2 = 0;
          return a2 | 0;
        }
        if (c2) {
          c2 = 0;
          d2 = a2;
          a:
            while (1) {
              while (1) {
                i2 = +e[d2 >> 3];
                k = +e[d2 + 8 >> 3];
                d2 = d2 + 16 | 0;
                m = b[d2 >> 2] | 0;
                m = (m | 0) == 0 ? a2 : m;
                h = +e[m >> 3];
                g2 = +e[m + 8 >> 3];
                if (i2 > h) {
                  j = i2;
                  i2 = k;
                } else {
                  j = h;
                  h = i2;
                  i2 = g2;
                  g2 = k;
                }
                if (!(l < h | l > j)) {
                  break;
                }
                d2 = b[d2 >> 2] | 0;
                if (!d2) {
                  d2 = 22;
                  break a;
                }
              }
              k = g2 < 0 ? g2 + 6.283185307179586 : g2;
              i2 = i2 < 0 ? i2 + 6.283185307179586 : i2;
              f = i2 == f | k == f ? f + -2220446049250313e-31 : f;
              k = k + (l - h) / (j - h) * (i2 - k);
              if ((k < 0 ? k + 6.283185307179586 : k) > f) {
                c2 = c2 ^ 1;
              }
              d2 = b[d2 >> 2] | 0;
              if (!d2) {
                d2 = 22;
                break;
              }
            }
          if ((d2 | 0) == 22) {
            return c2 | 0;
          }
        } else {
          c2 = 0;
          d2 = a2;
          b:
            while (1) {
              while (1) {
                i2 = +e[d2 >> 3];
                k = +e[d2 + 8 >> 3];
                d2 = d2 + 16 | 0;
                m = b[d2 >> 2] | 0;
                m = (m | 0) == 0 ? a2 : m;
                h = +e[m >> 3];
                g2 = +e[m + 8 >> 3];
                if (i2 > h) {
                  j = i2;
                  i2 = k;
                } else {
                  j = h;
                  h = i2;
                  i2 = g2;
                  g2 = k;
                }
                if (!(l < h | l > j)) {
                  break;
                }
                d2 = b[d2 >> 2] | 0;
                if (!d2) {
                  d2 = 22;
                  break b;
                }
              }
              f = i2 == f | g2 == f ? f + -2220446049250313e-31 : f;
              if (g2 + (l - h) / (j - h) * (i2 - g2) > f) {
                c2 = c2 ^ 1;
              }
              d2 = b[d2 >> 2] | 0;
              if (!d2) {
                d2 = 22;
                break;
              }
            }
          if ((d2 | 0) == 22) {
            return c2 | 0;
          }
        }
        return 0;
      }
      function mc(c2, d2, e2, f, g2) {
        c2 = c2 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        f = f | 0;
        g2 = g2 | 0;
        var h = 0, i2 = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t2 = 0, u2 = 0;
        u2 = S;
        S = S + 32 | 0;
        t2 = u2 + 16 | 0;
        s2 = u2;
        h = cd(c2 | 0, d2 | 0, 52) | 0;
        G() | 0;
        h = h & 15;
        p2 = cd(e2 | 0, f | 0, 52) | 0;
        G() | 0;
        if ((h | 0) != (p2 & 15 | 0)) {
          t2 = 1;
          S = u2;
          return t2 | 0;
        }
        l = cd(c2 | 0, d2 | 0, 45) | 0;
        G() | 0;
        l = l & 127;
        m = cd(e2 | 0, f | 0, 45) | 0;
        G() | 0;
        m = m & 127;
        p2 = (l | 0) != (m | 0);
        if (p2) {
          j = ta(l, m) | 0;
          if ((j | 0) == 7) {
            t2 = 2;
            S = u2;
            return t2 | 0;
          }
          k = ta(m, l) | 0;
          if ((k | 0) == 7) {
            H(22925, 22949, 151, 22959);
          } else {
            q2 = j;
            i2 = k;
          }
        } else {
          q2 = 0;
          i2 = 0;
        }
        n = la(l) | 0;
        o = la(m) | 0;
        b[t2 >> 2] = 0;
        b[t2 + 4 >> 2] = 0;
        b[t2 + 8 >> 2] = 0;
        b[t2 + 12 >> 2] = 0;
        do {
          if (!q2) {
            Tb(e2, f, t2) | 0;
            if ((n | 0) != 0 & (o | 0) != 0) {
              if ((m | 0) != (l | 0)) {
                H(23077, 22949, 243, 22959);
              }
              i2 = Lb(c2, d2) | 0;
              h = Lb(e2, f) | 0;
              if (!(a[22032 + (i2 * 7 | 0) + h >> 0] | 0)) {
                i2 = b[21200 + (i2 * 28 | 0) + (h << 2) >> 2] | 0;
                if ((i2 | 0) > 0) {
                  j = t2 + 4 | 0;
                  h = 0;
                  do {
                    Oa(j);
                    h = h + 1 | 0;
                  } while ((h | 0) != (i2 | 0));
                  r2 = 50;
                } else {
                  r2 = 50;
                }
              } else {
                h = 5;
              }
            } else {
              r2 = 50;
            }
          } else {
            m = b[4304 + (l * 28 | 0) + (q2 << 2) >> 2] | 0;
            j = (m | 0) > 0;
            if (!o) {
              if (j) {
                l = 0;
                k = e2;
                j = f;
                do {
                  k = Pb(k, j) | 0;
                  j = G() | 0;
                  i2 = Qa(i2) | 0;
                  l = l + 1 | 0;
                } while ((l | 0) != (m | 0));
                m = i2;
                l = k;
                k = j;
              } else {
                m = i2;
                l = e2;
                k = f;
              }
            } else if (j) {
              l = 0;
              k = e2;
              j = f;
              do {
                k = Ob(k, j) | 0;
                j = G() | 0;
                i2 = Qa(i2) | 0;
                if ((i2 | 0) == 1) {
                  i2 = Qa(1) | 0;
                }
                l = l + 1 | 0;
              } while ((l | 0) != (m | 0));
              m = i2;
              l = k;
              k = j;
            } else {
              m = i2;
              l = e2;
              k = f;
            }
            Tb(l, k, t2) | 0;
            if (!p2) {
              H(22972, 22949, 181, 22959);
            }
            j = (n | 0) != 0;
            i2 = (o | 0) != 0;
            if (j & i2) {
              H(22999, 22949, 182, 22959);
            }
            if (!j) {
              if (i2) {
                i2 = Lb(l, k) | 0;
                if (a[22032 + (i2 * 7 | 0) + m >> 0] | 0) {
                  h = 4;
                  break;
                }
                l = 0;
                k = b[21200 + (m * 28 | 0) + (i2 << 2) >> 2] | 0;
                r2 = 26;
              } else {
                i2 = 0;
              }
            } else {
              i2 = Lb(c2, d2) | 0;
              if (a[22032 + (i2 * 7 | 0) + q2 >> 0] | 0) {
                h = 3;
                break;
              }
              k = b[21200 + (i2 * 28 | 0) + (q2 << 2) >> 2] | 0;
              l = k;
              r2 = 26;
            }
            if ((r2 | 0) == 26) {
              if ((k | 0) <= -1) {
                H(23030, 22949, 212, 22959);
              }
              if ((l | 0) <= -1) {
                H(23053, 22949, 213, 22959);
              }
              if ((k | 0) > 0) {
                j = t2 + 4 | 0;
                i2 = 0;
                do {
                  Oa(j);
                  i2 = i2 + 1 | 0;
                } while ((i2 | 0) != (k | 0));
                i2 = l;
              } else {
                i2 = l;
              }
            }
            b[s2 >> 2] = 0;
            b[s2 + 4 >> 2] = 0;
            b[s2 + 8 >> 2] = 0;
            Ma(s2, q2);
            if (h | 0) {
              while (1) {
                if (!(Rb(h) | 0)) {
                  La(s2);
                } else {
                  Ka(s2);
                }
                if ((h | 0) > 1) {
                  h = h + -1 | 0;
                } else {
                  break;
                }
              }
            }
            if ((i2 | 0) > 0) {
              h = 0;
              do {
                Oa(s2);
                h = h + 1 | 0;
              } while ((h | 0) != (i2 | 0));
            }
            r2 = t2 + 4 | 0;
            Ea(r2, s2, r2);
            Ca(r2);
            r2 = 50;
          }
        } while (0);
        if ((r2 | 0) == 50) {
          h = t2 + 4 | 0;
          b[g2 >> 2] = b[h >> 2];
          b[g2 + 4 >> 2] = b[h + 4 >> 2];
          b[g2 + 8 >> 2] = b[h + 8 >> 2];
          h = 0;
        }
        t2 = h;
        S = u2;
        return t2 | 0;
      }
      function nc(a2, c2, d2, e2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        var f = 0, g2 = 0, h = 0, i2 = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t2 = 0;
        p2 = S;
        S = S + 48 | 0;
        h = p2 + 36 | 0;
        i2 = p2 + 24 | 0;
        j = p2 + 12 | 0;
        k = p2;
        g2 = cd(a2 | 0, c2 | 0, 52) | 0;
        G() | 0;
        g2 = g2 & 15;
        n = cd(a2 | 0, c2 | 0, 45) | 0;
        G() | 0;
        n = n & 127;
        l = la(n) | 0;
        dd(g2 | 0, 0, 52) | 0;
        r2 = G() | 0 | 134225919;
        q2 = e2;
        b[q2 >> 2] = -1;
        b[q2 + 4 >> 2] = r2;
        if (!g2) {
          if ((b[d2 >> 2] | 0) > 1) {
            r2 = 1;
            S = p2;
            return r2 | 0;
          }
          if ((b[d2 + 4 >> 2] | 0) > 1) {
            r2 = 1;
            S = p2;
            return r2 | 0;
          }
          if ((b[d2 + 8 >> 2] | 0) > 1) {
            r2 = 1;
            S = p2;
            return r2 | 0;
          }
          f = sa(n, Ha(d2) | 0) | 0;
          if ((f | 0) == 127) {
            r2 = 1;
            S = p2;
            return r2 | 0;
          }
          o = dd(f | 0, 0, 45) | 0;
          q2 = G() | 0;
          n = e2;
          q2 = b[n + 4 >> 2] & -1040385 | q2;
          r2 = e2;
          b[r2 >> 2] = b[n >> 2] | o;
          b[r2 + 4 >> 2] = q2;
          r2 = 0;
          S = p2;
          return r2 | 0;
        }
        b[h >> 2] = b[d2 >> 2];
        b[h + 4 >> 2] = b[d2 + 4 >> 2];
        b[h + 8 >> 2] = b[d2 + 8 >> 2];
        while (1) {
          b[i2 >> 2] = b[h >> 2];
          b[i2 + 4 >> 2] = b[h + 4 >> 2];
          b[i2 + 8 >> 2] = b[h + 8 >> 2];
          if (!(Rb(g2) | 0)) {
            Ja(h);
            b[j >> 2] = b[h >> 2];
            b[j + 4 >> 2] = b[h + 4 >> 2];
            b[j + 8 >> 2] = b[h + 8 >> 2];
            La(j);
          } else {
            Ia(h);
            b[j >> 2] = b[h >> 2];
            b[j + 4 >> 2] = b[h + 4 >> 2];
            b[j + 8 >> 2] = b[h + 8 >> 2];
            Ka(j);
          }
          Fa(i2, j, k);
          Ca(k);
          q2 = e2;
          s2 = b[q2 >> 2] | 0;
          q2 = b[q2 + 4 >> 2] | 0;
          t2 = (15 - g2 | 0) * 3 | 0;
          d2 = dd(7, 0, t2 | 0) | 0;
          q2 = q2 & ~(G() | 0);
          t2 = dd(Ha(k) | 0, 0, t2 | 0) | 0;
          q2 = G() | 0 | q2;
          r2 = e2;
          b[r2 >> 2] = t2 | s2 & ~d2;
          b[r2 + 4 >> 2] = q2;
          if ((g2 | 0) > 1) {
            g2 = g2 + -1 | 0;
          } else {
            break;
          }
        }
        a:
          do {
            if (((b[h >> 2] | 0) <= 1 ? (b[h + 4 >> 2] | 0) <= 1 : 0) ? (b[h + 8 >> 2] | 0) <= 1 : 0) {
              g2 = Ha(h) | 0;
              i2 = sa(n, g2) | 0;
              if ((i2 | 0) == 127) {
                k = 0;
              } else {
                k = la(i2) | 0;
              }
              b:
                do {
                  if (!g2) {
                    if ((l | 0) != 0 & (k | 0) != 0) {
                      t2 = Lb(a2, c2) | 0;
                      g2 = e2;
                      g2 = 21408 + (t2 * 28 | 0) + ((Lb(b[g2 >> 2] | 0, b[g2 + 4 >> 2] | 0) | 0) << 2) | 0;
                      g2 = b[g2 >> 2] | 0;
                      if ((g2 | 0) <= -1) {
                        H(23201, 22949, 433, 23134);
                      }
                      if (!g2) {
                        f = i2;
                        g2 = 55;
                      } else {
                        h = e2;
                        f = 0;
                        d2 = b[h >> 2] | 0;
                        h = b[h + 4 >> 2] | 0;
                        do {
                          d2 = Nb(d2, h) | 0;
                          h = G() | 0;
                          t2 = e2;
                          b[t2 >> 2] = d2;
                          b[t2 + 4 >> 2] = h;
                          f = f + 1 | 0;
                        } while ((f | 0) < (g2 | 0));
                        f = i2;
                        g2 = 54;
                      }
                    } else {
                      f = i2;
                      g2 = 54;
                    }
                  } else {
                    if (l) {
                      h = 21408 + ((Lb(a2, c2) | 0) * 28 | 0) + (g2 << 2) | 0;
                      h = b[h >> 2] | 0;
                      if ((h | 0) > 0) {
                        d2 = 0;
                        do {
                          g2 = Pa(g2) | 0;
                          d2 = d2 + 1 | 0;
                        } while ((d2 | 0) != (h | 0));
                      }
                      if ((g2 | 0) == 1) {
                        f = 3;
                        break a;
                      }
                      d2 = sa(n, g2) | 0;
                      if ((d2 | 0) == 127) {
                        H(23104, 22949, 376, 23134);
                      }
                      if (!(la(d2) | 0)) {
                        o = h;
                        m = g2;
                        f = d2;
                      } else {
                        H(23147, 22949, 377, 23134);
                      }
                    } else {
                      o = 0;
                      m = g2;
                      f = i2;
                    }
                    j = b[4304 + (n * 28 | 0) + (m << 2) >> 2] | 0;
                    if ((j | 0) <= -1) {
                      H(23178, 22949, 384, 23134);
                    }
                    if (!k) {
                      if ((o | 0) <= -1) {
                        H(23030, 22949, 417, 23134);
                      }
                      if (o | 0) {
                        h = e2;
                        g2 = 0;
                        d2 = b[h >> 2] | 0;
                        h = b[h + 4 >> 2] | 0;
                        do {
                          d2 = Nb(d2, h) | 0;
                          h = G() | 0;
                          t2 = e2;
                          b[t2 >> 2] = d2;
                          b[t2 + 4 >> 2] = h;
                          g2 = g2 + 1 | 0;
                        } while ((g2 | 0) < (o | 0));
                      }
                      if ((j | 0) <= 0) {
                        g2 = 54;
                        break;
                      }
                      h = e2;
                      g2 = 0;
                      d2 = b[h >> 2] | 0;
                      h = b[h + 4 >> 2] | 0;
                      while (1) {
                        d2 = Nb(d2, h) | 0;
                        h = G() | 0;
                        t2 = e2;
                        b[t2 >> 2] = d2;
                        b[t2 + 4 >> 2] = h;
                        g2 = g2 + 1 | 0;
                        if ((g2 | 0) == (j | 0)) {
                          g2 = 54;
                          break b;
                        }
                      }
                    }
                    i2 = ta(f, n) | 0;
                    if ((i2 | 0) == 7) {
                      H(22925, 22949, 393, 23134);
                    }
                    g2 = e2;
                    d2 = b[g2 >> 2] | 0;
                    g2 = b[g2 + 4 >> 2] | 0;
                    if ((j | 0) > 0) {
                      h = 0;
                      do {
                        d2 = Nb(d2, g2) | 0;
                        g2 = G() | 0;
                        t2 = e2;
                        b[t2 >> 2] = d2;
                        b[t2 + 4 >> 2] = g2;
                        h = h + 1 | 0;
                      } while ((h | 0) != (j | 0));
                    }
                    d2 = Lb(d2, g2) | 0;
                    t2 = ma(f) | 0;
                    d2 = b[(t2 ? 21824 : 21616) + (i2 * 28 | 0) + (d2 << 2) >> 2] | 0;
                    if ((d2 | 0) <= -1) {
                      H(23030, 22949, 412, 23134);
                    }
                    if (!d2) {
                      g2 = 54;
                    } else {
                      i2 = e2;
                      g2 = 0;
                      h = b[i2 >> 2] | 0;
                      i2 = b[i2 + 4 >> 2] | 0;
                      do {
                        h = Mb(h, i2) | 0;
                        i2 = G() | 0;
                        t2 = e2;
                        b[t2 >> 2] = h;
                        b[t2 + 4 >> 2] = i2;
                        g2 = g2 + 1 | 0;
                      } while ((g2 | 0) < (d2 | 0));
                      g2 = 54;
                    }
                  }
                } while (0);
              if ((g2 | 0) == 54) {
                if (k) {
                  g2 = 55;
                }
              }
              if ((g2 | 0) == 55) {
                t2 = e2;
                if ((Lb(b[t2 >> 2] | 0, b[t2 + 4 >> 2] | 0) | 0) == 1) {
                  f = 4;
                  break;
                }
              }
              t2 = e2;
              r2 = b[t2 >> 2] | 0;
              t2 = b[t2 + 4 >> 2] & -1040385;
              s2 = dd(f | 0, 0, 45) | 0;
              t2 = t2 | (G() | 0);
              f = e2;
              b[f >> 2] = r2 | s2;
              b[f + 4 >> 2] = t2;
              f = 0;
            } else {
              f = 2;
            }
          } while (0);
        t2 = f;
        S = p2;
        return t2 | 0;
      }
      function oc(a2, b2, c2, d2, e2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        var f = 0, g2 = 0;
        g2 = S;
        S = S + 16 | 0;
        f = g2;
        a2 = mc(a2, b2, c2, d2, f) | 0;
        if (!a2) {
          Ua(f, e2);
          a2 = 0;
        }
        S = g2;
        return a2 | 0;
      }
      function pc(a2, b2, c2, d2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        var e2 = 0, f = 0;
        e2 = S;
        S = S + 16 | 0;
        f = e2;
        Va(c2, f);
        d2 = nc(a2, b2, f, d2) | 0;
        S = e2;
        return d2 | 0;
      }
      function qc(a2, b2, c2, d2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        var e2 = 0, f = 0, g2 = 0;
        g2 = S;
        S = S + 32 | 0;
        e2 = g2 + 12 | 0;
        f = g2;
        if ((mc(a2, b2, a2, b2, e2) | 0) == 0 ? (mc(a2, b2, c2, d2, f) | 0) == 0 : 0) {
          a2 = Ta(e2, f) | 0;
        } else {
          a2 = -1;
        }
        S = g2;
        return a2 | 0;
      }
      function rc(a2, b2, c2, d2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        var e2 = 0, f = 0, g2 = 0;
        g2 = S;
        S = S + 32 | 0;
        e2 = g2 + 12 | 0;
        f = g2;
        if ((mc(a2, b2, a2, b2, e2) | 0) == 0 ? (mc(a2, b2, c2, d2, f) | 0) == 0 : 0) {
          a2 = Ta(e2, f) | 0;
        } else {
          a2 = -1;
        }
        S = g2;
        return (a2 >>> 31 ^ 1) + a2 | 0;
      }
      function sc(a2, c2, d2, e2, f) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        f = f | 0;
        var g2 = 0, h = 0, i2 = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, r2 = 0, s2 = 0, t2 = 0, u2 = 0, v2 = 0, w2 = 0, x3 = 0, y3 = 0;
        x3 = S;
        S = S + 48 | 0;
        g2 = x3 + 24 | 0;
        h = x3 + 12 | 0;
        w2 = x3;
        if ((mc(a2, c2, a2, c2, g2) | 0) == 0 ? (mc(a2, c2, d2, e2, h) | 0) == 0 : 0) {
          v2 = Ta(g2, h) | 0;
          if ((v2 | 0) < 0) {
            w2 = v2;
            S = x3;
            return w2 | 0;
          }
          b[g2 >> 2] = 0;
          b[g2 + 4 >> 2] = 0;
          b[g2 + 8 >> 2] = 0;
          b[h >> 2] = 0;
          b[h + 4 >> 2] = 0;
          b[h + 8 >> 2] = 0;
          mc(a2, c2, a2, c2, g2) | 0;
          mc(a2, c2, d2, e2, h) | 0;
          Wa(g2);
          Wa(h);
          if (!v2) {
            e2 = g2 + 4 | 0;
            n = g2 + 8 | 0;
            s2 = e2;
            t2 = n;
            u2 = g2;
            d2 = b[g2 >> 2] | 0;
            e2 = b[e2 >> 2] | 0;
            g2 = b[n >> 2] | 0;
            p2 = 0;
            r2 = 0;
            o = 0;
          } else {
            l = b[g2 >> 2] | 0;
            o = +(v2 | 0);
            s2 = g2 + 4 | 0;
            m = b[s2 >> 2] | 0;
            t2 = g2 + 8 | 0;
            n = b[t2 >> 2] | 0;
            u2 = g2;
            d2 = l;
            e2 = m;
            g2 = n;
            p2 = +((b[h >> 2] | 0) - l | 0) / o;
            r2 = +((b[h + 4 >> 2] | 0) - m | 0) / o;
            o = +((b[h + 8 >> 2] | 0) - n | 0) / o;
          }
          b[w2 >> 2] = d2;
          n = w2 + 4 | 0;
          b[n >> 2] = e2;
          m = w2 + 8 | 0;
          b[m >> 2] = g2;
          l = 0;
          while (1) {
            j = +(l | 0);
            y3 = p2 * j + +(d2 | 0);
            i2 = r2 * j + +(b[s2 >> 2] | 0);
            j = o * j + +(b[t2 >> 2] | 0);
            e2 = ~~+fd(+y3);
            h = ~~+fd(+i2);
            d2 = ~~+fd(+j);
            y3 = +q(+(+(e2 | 0) - y3));
            i2 = +q(+(+(h | 0) - i2));
            j = +q(+(+(d2 | 0) - j));
            do {
              if (!(y3 > i2 & y3 > j)) {
                k = 0 - e2 | 0;
                if (i2 > j) {
                  g2 = k - d2 | 0;
                  break;
                } else {
                  g2 = h;
                  d2 = k - h | 0;
                  break;
                }
              } else {
                e2 = 0 - (h + d2) | 0;
                g2 = h;
              }
            } while (0);
            b[w2 >> 2] = e2;
            b[n >> 2] = g2;
            b[m >> 2] = d2;
            Xa(w2);
            nc(a2, c2, w2, f + (l << 3) | 0) | 0;
            if ((l | 0) == (v2 | 0)) {
              break;
            }
            l = l + 1 | 0;
            d2 = b[u2 >> 2] | 0;
          }
          w2 = 0;
          S = x3;
          return w2 | 0;
        }
        w2 = -1;
        S = x3;
        return w2 | 0;
      }
      function tc(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        var c2 = 0;
        if (!b2) {
          c2 = 1;
          return c2 | 0;
        }
        c2 = a2;
        a2 = 1;
        do {
          a2 = B((b2 & 1 | 0) == 0 ? 1 : c2, a2) | 0;
          b2 = b2 >> 1;
          c2 = B(c2, c2) | 0;
        } while ((b2 | 0) != 0);
        return a2 | 0;
      }
      function uc(a2, c2, d2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        var f = 0, g2 = 0, h = 0, i2 = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0;
        if (!(xa(c2, d2) | 0)) {
          n = 0;
          return n | 0;
        }
        c2 = wa(c2) | 0;
        o = +e[d2 >> 3];
        f = +e[d2 + 8 >> 3];
        f = c2 & f < 0 ? f + 6.283185307179586 : f;
        n = b[a2 >> 2] | 0;
        if ((n | 0) <= 0) {
          n = 0;
          return n | 0;
        }
        m = b[a2 + 4 >> 2] | 0;
        if (c2) {
          c2 = 0;
          d2 = -1;
          a2 = 0;
          a:
            while (1) {
              l = a2;
              while (1) {
                i2 = +e[m + (l << 4) >> 3];
                k = +e[m + (l << 4) + 8 >> 3];
                a2 = (d2 + 2 | 0) % (n | 0) | 0;
                h = +e[m + (a2 << 4) >> 3];
                g2 = +e[m + (a2 << 4) + 8 >> 3];
                if (i2 > h) {
                  j = i2;
                  i2 = k;
                } else {
                  j = h;
                  h = i2;
                  i2 = g2;
                  g2 = k;
                }
                if (!(o < h | o > j)) {
                  break;
                }
                d2 = l + 1 | 0;
                if ((d2 | 0) < (n | 0)) {
                  a2 = l;
                  l = d2;
                  d2 = a2;
                } else {
                  d2 = 22;
                  break a;
                }
              }
              k = g2 < 0 ? g2 + 6.283185307179586 : g2;
              i2 = i2 < 0 ? i2 + 6.283185307179586 : i2;
              f = i2 == f | k == f ? f + -2220446049250313e-31 : f;
              k = k + (o - h) / (j - h) * (i2 - k);
              if ((k < 0 ? k + 6.283185307179586 : k) > f) {
                c2 = c2 ^ 1;
              }
              a2 = l + 1 | 0;
              if ((a2 | 0) >= (n | 0)) {
                d2 = 22;
                break;
              } else {
                d2 = l;
              }
            }
          if ((d2 | 0) == 22) {
            return c2 | 0;
          }
        } else {
          c2 = 0;
          d2 = -1;
          a2 = 0;
          b:
            while (1) {
              l = a2;
              while (1) {
                i2 = +e[m + (l << 4) >> 3];
                k = +e[m + (l << 4) + 8 >> 3];
                a2 = (d2 + 2 | 0) % (n | 0) | 0;
                h = +e[m + (a2 << 4) >> 3];
                g2 = +e[m + (a2 << 4) + 8 >> 3];
                if (i2 > h) {
                  j = i2;
                  i2 = k;
                } else {
                  j = h;
                  h = i2;
                  i2 = g2;
                  g2 = k;
                }
                if (!(o < h | o > j)) {
                  break;
                }
                d2 = l + 1 | 0;
                if ((d2 | 0) < (n | 0)) {
                  a2 = l;
                  l = d2;
                  d2 = a2;
                } else {
                  d2 = 22;
                  break b;
                }
              }
              f = i2 == f | g2 == f ? f + -2220446049250313e-31 : f;
              if (g2 + (o - h) / (j - h) * (i2 - g2) > f) {
                c2 = c2 ^ 1;
              }
              a2 = l + 1 | 0;
              if ((a2 | 0) >= (n | 0)) {
                d2 = 22;
                break;
              } else {
                d2 = l;
              }
            }
          if ((d2 | 0) == 22) {
            return c2 | 0;
          }
        }
        return 0;
      }
      function vc(a2, c2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        var d2 = 0, f = 0, g2 = 0, h = 0, i2 = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, r2 = 0, s2 = 0, t2 = 0, u2 = 0, v2 = 0;
        r2 = b[a2 >> 2] | 0;
        if (!r2) {
          b[c2 >> 2] = 0;
          b[c2 + 4 >> 2] = 0;
          b[c2 + 8 >> 2] = 0;
          b[c2 + 12 >> 2] = 0;
          b[c2 + 16 >> 2] = 0;
          b[c2 + 20 >> 2] = 0;
          b[c2 + 24 >> 2] = 0;
          b[c2 + 28 >> 2] = 0;
          return;
        }
        s2 = c2 + 8 | 0;
        e[s2 >> 3] = 17976931348623157e292;
        t2 = c2 + 24 | 0;
        e[t2 >> 3] = 17976931348623157e292;
        e[c2 >> 3] = -17976931348623157e292;
        u2 = c2 + 16 | 0;
        e[u2 >> 3] = -17976931348623157e292;
        if ((r2 | 0) <= 0) {
          return;
        }
        o = b[a2 + 4 >> 2] | 0;
        l = 17976931348623157e292;
        m = -17976931348623157e292;
        n = 0;
        a2 = -1;
        h = 17976931348623157e292;
        i2 = 17976931348623157e292;
        k = -17976931348623157e292;
        f = -17976931348623157e292;
        p2 = 0;
        while (1) {
          d2 = +e[o + (p2 << 4) >> 3];
          j = +e[o + (p2 << 4) + 8 >> 3];
          a2 = a2 + 2 | 0;
          g2 = +e[o + (((a2 | 0) == (r2 | 0) ? 0 : a2) << 4) + 8 >> 3];
          if (d2 < h) {
            e[s2 >> 3] = d2;
            h = d2;
          }
          if (j < i2) {
            e[t2 >> 3] = j;
            i2 = j;
          }
          if (d2 > k) {
            e[c2 >> 3] = d2;
          } else {
            d2 = k;
          }
          if (j > f) {
            e[u2 >> 3] = j;
            f = j;
          }
          l = j > 0 & j < l ? j : l;
          m = j < 0 & j > m ? j : m;
          n = n | +q(+(j - g2)) > 3.141592653589793;
          a2 = p2 + 1 | 0;
          if ((a2 | 0) == (r2 | 0)) {
            break;
          } else {
            v2 = p2;
            k = d2;
            p2 = a2;
            a2 = v2;
          }
        }
        if (!n) {
          return;
        }
        e[u2 >> 3] = m;
        e[t2 >> 3] = l;
        return;
      }
      function wc(a2, c2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        var d2 = 0, f = 0, g2 = 0, h = 0, i2 = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, r2 = 0, s2 = 0, t2 = 0, u2 = 0, v2 = 0, w2 = 0, x3 = 0, y3 = 0, z2 = 0, A2 = 0;
        r2 = b[a2 >> 2] | 0;
        if (r2) {
          s2 = c2 + 8 | 0;
          e[s2 >> 3] = 17976931348623157e292;
          t2 = c2 + 24 | 0;
          e[t2 >> 3] = 17976931348623157e292;
          e[c2 >> 3] = -17976931348623157e292;
          u2 = c2 + 16 | 0;
          e[u2 >> 3] = -17976931348623157e292;
          if ((r2 | 0) > 0) {
            g2 = b[a2 + 4 >> 2] | 0;
            o = 17976931348623157e292;
            p2 = -17976931348623157e292;
            f = 0;
            d2 = -1;
            k = 17976931348623157e292;
            l = 17976931348623157e292;
            n = -17976931348623157e292;
            i2 = -17976931348623157e292;
            v2 = 0;
            while (1) {
              h = +e[g2 + (v2 << 4) >> 3];
              m = +e[g2 + (v2 << 4) + 8 >> 3];
              z2 = d2 + 2 | 0;
              j = +e[g2 + (((z2 | 0) == (r2 | 0) ? 0 : z2) << 4) + 8 >> 3];
              if (h < k) {
                e[s2 >> 3] = h;
                k = h;
              }
              if (m < l) {
                e[t2 >> 3] = m;
                l = m;
              }
              if (h > n) {
                e[c2 >> 3] = h;
              } else {
                h = n;
              }
              if (m > i2) {
                e[u2 >> 3] = m;
                i2 = m;
              }
              o = m > 0 & m < o ? m : o;
              p2 = m < 0 & m > p2 ? m : p2;
              f = f | +q(+(m - j)) > 3.141592653589793;
              d2 = v2 + 1 | 0;
              if ((d2 | 0) == (r2 | 0)) {
                break;
              } else {
                z2 = v2;
                n = h;
                v2 = d2;
                d2 = z2;
              }
            }
            if (f) {
              e[u2 >> 3] = p2;
              e[t2 >> 3] = o;
            }
          }
        } else {
          b[c2 >> 2] = 0;
          b[c2 + 4 >> 2] = 0;
          b[c2 + 8 >> 2] = 0;
          b[c2 + 12 >> 2] = 0;
          b[c2 + 16 >> 2] = 0;
          b[c2 + 20 >> 2] = 0;
          b[c2 + 24 >> 2] = 0;
          b[c2 + 28 >> 2] = 0;
        }
        z2 = a2 + 8 | 0;
        d2 = b[z2 >> 2] | 0;
        if ((d2 | 0) <= 0) {
          return;
        }
        y3 = a2 + 12 | 0;
        x3 = 0;
        do {
          g2 = b[y3 >> 2] | 0;
          f = x3;
          x3 = x3 + 1 | 0;
          t2 = c2 + (x3 << 5) | 0;
          u2 = b[g2 + (f << 3) >> 2] | 0;
          if (u2) {
            v2 = c2 + (x3 << 5) + 8 | 0;
            e[v2 >> 3] = 17976931348623157e292;
            a2 = c2 + (x3 << 5) + 24 | 0;
            e[a2 >> 3] = 17976931348623157e292;
            e[t2 >> 3] = -17976931348623157e292;
            w2 = c2 + (x3 << 5) + 16 | 0;
            e[w2 >> 3] = -17976931348623157e292;
            if ((u2 | 0) > 0) {
              r2 = b[g2 + (f << 3) + 4 >> 2] | 0;
              o = 17976931348623157e292;
              p2 = -17976931348623157e292;
              g2 = 0;
              f = -1;
              s2 = 0;
              k = 17976931348623157e292;
              l = 17976931348623157e292;
              m = -17976931348623157e292;
              i2 = -17976931348623157e292;
              while (1) {
                h = +e[r2 + (s2 << 4) >> 3];
                n = +e[r2 + (s2 << 4) + 8 >> 3];
                f = f + 2 | 0;
                j = +e[r2 + (((f | 0) == (u2 | 0) ? 0 : f) << 4) + 8 >> 3];
                if (h < k) {
                  e[v2 >> 3] = h;
                  k = h;
                }
                if (n < l) {
                  e[a2 >> 3] = n;
                  l = n;
                }
                if (h > m) {
                  e[t2 >> 3] = h;
                } else {
                  h = m;
                }
                if (n > i2) {
                  e[w2 >> 3] = n;
                  i2 = n;
                }
                o = n > 0 & n < o ? n : o;
                p2 = n < 0 & n > p2 ? n : p2;
                g2 = g2 | +q(+(n - j)) > 3.141592653589793;
                f = s2 + 1 | 0;
                if ((f | 0) == (u2 | 0)) {
                  break;
                } else {
                  A2 = s2;
                  s2 = f;
                  m = h;
                  f = A2;
                }
              }
              if (g2) {
                e[w2 >> 3] = p2;
                e[a2 >> 3] = o;
              }
            }
          } else {
            b[t2 >> 2] = 0;
            b[t2 + 4 >> 2] = 0;
            b[t2 + 8 >> 2] = 0;
            b[t2 + 12 >> 2] = 0;
            b[t2 + 16 >> 2] = 0;
            b[t2 + 20 >> 2] = 0;
            b[t2 + 24 >> 2] = 0;
            b[t2 + 28 >> 2] = 0;
            d2 = b[z2 >> 2] | 0;
          }
        } while ((x3 | 0) < (d2 | 0));
        return;
      }
      function xc(a2, c2, d2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        var e2 = 0, f = 0, g2 = 0;
        if (!(uc(a2, c2, d2) | 0)) {
          f = 0;
          return f | 0;
        }
        f = a2 + 8 | 0;
        if ((b[f >> 2] | 0) <= 0) {
          f = 1;
          return f | 0;
        }
        e2 = a2 + 12 | 0;
        a2 = 0;
        while (1) {
          g2 = a2;
          a2 = a2 + 1 | 0;
          if (uc((b[e2 >> 2] | 0) + (g2 << 3) | 0, c2 + (a2 << 5) | 0, d2) | 0) {
            a2 = 0;
            e2 = 6;
            break;
          }
          if ((a2 | 0) >= (b[f >> 2] | 0)) {
            a2 = 1;
            e2 = 6;
            break;
          }
        }
        if ((e2 | 0) == 6) {
          return a2 | 0;
        }
        return 0;
      }
      function yc() {
        return 8;
      }
      function zc() {
        return 16;
      }
      function Ac() {
        return 168;
      }
      function Bc() {
        return 8;
      }
      function Cc() {
        return 16;
      }
      function Dc() {
        return 12;
      }
      function Ec() {
        return 8;
      }
      function Fc(a2) {
        a2 = a2 | 0;
        var b2 = 0, c2 = 0;
        c2 = +e[a2 >> 3];
        b2 = +e[a2 + 8 >> 3];
        return + +r(+(c2 * c2 + b2 * b2));
      }
      function Gc(a2, b2, c2, d2, f) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        f = f | 0;
        var g2 = 0, h = 0, i2 = 0, j = 0, k = 0, l = 0, m = 0, n = 0;
        k = +e[a2 >> 3];
        j = +e[b2 >> 3] - k;
        i2 = +e[a2 + 8 >> 3];
        h = +e[b2 + 8 >> 3] - i2;
        m = +e[c2 >> 3];
        g2 = +e[d2 >> 3] - m;
        n = +e[c2 + 8 >> 3];
        l = +e[d2 + 8 >> 3] - n;
        g2 = (g2 * (i2 - n) - (k - m) * l) / (j * l - h * g2);
        e[f >> 3] = k + j * g2;
        e[f + 8 >> 3] = i2 + h * g2;
        return;
      }
      function Hc(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        if (!(+e[a2 >> 3] == +e[b2 >> 3])) {
          b2 = 0;
          return b2 | 0;
        }
        b2 = +e[a2 + 8 >> 3] == +e[b2 + 8 >> 3];
        return b2 | 0;
      }
      function Ic(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        var c2 = 0, d2 = 0, f = 0;
        f = +e[a2 >> 3] - +e[b2 >> 3];
        d2 = +e[a2 + 8 >> 3] - +e[b2 + 8 >> 3];
        c2 = +e[a2 + 16 >> 3] - +e[b2 + 16 >> 3];
        return +(f * f + d2 * d2 + c2 * c2);
      }
      function Jc(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        var c2 = 0, d2 = 0, f = 0;
        c2 = +e[a2 >> 3];
        d2 = +t(+c2);
        c2 = +u(+c2);
        e[b2 + 16 >> 3] = c2;
        c2 = +e[a2 + 8 >> 3];
        f = d2 * +t(+c2);
        e[b2 >> 3] = f;
        c2 = d2 * +u(+c2);
        e[b2 + 8 >> 3] = c2;
        return;
      }
      function Kc(a2, c2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        var d2 = 0, e2 = 0, f = 0, g2 = 0, h = 0, i2 = 0, j = 0, k = 0;
        k = S;
        S = S + 32 | 0;
        f = k + 16 | 0;
        g2 = k;
        Ub(a2, c2, f);
        h = Ab(a2, c2) | 0;
        j = Lb(a2, c2) | 0;
        pa(h, g2);
        c2 = qa(h, b[f >> 2] | 0) | 0;
        if (!(la(h) | 0)) {
          j = c2;
          S = k;
          return j | 0;
        }
        do {
          switch (h | 0) {
            case 4: {
              a2 = 0;
              d2 = 14;
              break;
            }
            case 14: {
              a2 = 1;
              d2 = 14;
              break;
            }
            case 24: {
              a2 = 2;
              d2 = 14;
              break;
            }
            case 38: {
              a2 = 3;
              d2 = 14;
              break;
            }
            case 49: {
              a2 = 4;
              d2 = 14;
              break;
            }
            case 58: {
              a2 = 5;
              d2 = 14;
              break;
            }
            case 63: {
              a2 = 6;
              d2 = 14;
              break;
            }
            case 72: {
              a2 = 7;
              d2 = 14;
              break;
            }
            case 83: {
              a2 = 8;
              d2 = 14;
              break;
            }
            case 97: {
              a2 = 9;
              d2 = 14;
              break;
            }
            case 107: {
              a2 = 10;
              d2 = 14;
              break;
            }
            case 117: {
              a2 = 11;
              d2 = 14;
              break;
            }
            default: {
              i2 = 0;
              e2 = 0;
            }
          }
        } while (0);
        if ((d2 | 0) == 14) {
          i2 = b[22096 + (a2 * 24 | 0) + 8 >> 2] | 0;
          e2 = b[22096 + (a2 * 24 | 0) + 16 >> 2] | 0;
        }
        a2 = b[f >> 2] | 0;
        if ((a2 | 0) != (b[g2 >> 2] | 0)) {
          h = ma(h) | 0;
          a2 = b[f >> 2] | 0;
          if (h | (a2 | 0) == (e2 | 0)) {
            c2 = (c2 + 1 | 0) % 6 | 0;
          }
        }
        if ((j | 0) == 3 & (a2 | 0) == (e2 | 0)) {
          j = (c2 + 5 | 0) % 6 | 0;
          S = k;
          return j | 0;
        }
        if (!((j | 0) == 5 & (a2 | 0) == (i2 | 0))) {
          j = c2;
          S = k;
          return j | 0;
        }
        j = (c2 + 1 | 0) % 6 | 0;
        S = k;
        return j | 0;
      }
      function Lc(a2, c2, d2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        var e2 = 0, f = 0;
        e2 = Fb(a2, c2) | 0;
        if ((d2 + -1 | 0) >>> 0 > 5) {
          d2 = -1;
          return d2 | 0;
        }
        f = (e2 | 0) != 0;
        if ((d2 | 0) == 1 & f) {
          d2 = -1;
          return d2 | 0;
        }
        e2 = Kc(a2, c2) | 0;
        if (f) {
          d2 = (5 - e2 + (b[22384 + (d2 << 2) >> 2] | 0) | 0) % 5 | 0;
          return d2 | 0;
        } else {
          d2 = (6 - e2 + (b[22416 + (d2 << 2) >> 2] | 0) | 0) % 6 | 0;
          return d2 | 0;
        }
        return 0;
      }
      function Mc(a2, c2, d2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        var e2 = 0;
        if ((c2 | 0) > 0) {
          e2 = Yc(c2, 4) | 0;
          b[a2 >> 2] = e2;
          if (!e2) {
            H(23230, 23253, 40, 23267);
          }
        } else {
          b[a2 >> 2] = 0;
        }
        b[a2 + 4 >> 2] = c2;
        b[a2 + 8 >> 2] = 0;
        b[a2 + 12 >> 2] = d2;
        return;
      }
      function Nc(a2) {
        a2 = a2 | 0;
        var c2 = 0, d2 = 0, f = 0, g2 = 0, h = 0, i2 = 0, j = 0;
        g2 = a2 + 4 | 0;
        h = a2 + 12 | 0;
        i2 = a2 + 8 | 0;
        a:
          while (1) {
            d2 = b[g2 >> 2] | 0;
            c2 = 0;
            while (1) {
              if ((c2 | 0) >= (d2 | 0)) {
                break a;
              }
              f = b[a2 >> 2] | 0;
              j = b[f + (c2 << 2) >> 2] | 0;
              if (!j) {
                c2 = c2 + 1 | 0;
              } else {
                break;
              }
            }
            c2 = f + (~~(+q(+(+s(10, + +(15 - (b[h >> 2] | 0) | 0)) * (+e[j >> 3] + +e[j + 8 >> 3]))) % +(d2 | 0)) >>> 0 << 2) | 0;
            d2 = b[c2 >> 2] | 0;
            b:
              do {
                if (d2 | 0) {
                  f = j + 32 | 0;
                  if ((d2 | 0) == (j | 0)) {
                    b[c2 >> 2] = b[f >> 2];
                  } else {
                    d2 = d2 + 32 | 0;
                    c2 = b[d2 >> 2] | 0;
                    if (!c2) {
                      break;
                    }
                    while (1) {
                      if ((c2 | 0) == (j | 0)) {
                        break;
                      }
                      d2 = c2 + 32 | 0;
                      c2 = b[d2 >> 2] | 0;
                      if (!c2) {
                        break b;
                      }
                    }
                    b[d2 >> 2] = b[f >> 2];
                  }
                  Xc(j);
                  b[i2 >> 2] = (b[i2 >> 2] | 0) + -1;
                }
              } while (0);
          }
        Xc(b[a2 >> 2] | 0);
        return;
      }
      function Oc(a2) {
        a2 = a2 | 0;
        var c2 = 0, d2 = 0, e2 = 0;
        e2 = b[a2 + 4 >> 2] | 0;
        d2 = 0;
        while (1) {
          if ((d2 | 0) >= (e2 | 0)) {
            c2 = 0;
            d2 = 4;
            break;
          }
          c2 = b[(b[a2 >> 2] | 0) + (d2 << 2) >> 2] | 0;
          if (!c2) {
            d2 = d2 + 1 | 0;
          } else {
            d2 = 4;
            break;
          }
        }
        if ((d2 | 0) == 4) {
          return c2 | 0;
        }
        return 0;
      }
      function Pc(a2, c2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        var d2 = 0, f = 0, g2 = 0, h = 0;
        d2 = ~~(+q(+(+s(10, + +(15 - (b[a2 + 12 >> 2] | 0) | 0)) * (+e[c2 >> 3] + +e[c2 + 8 >> 3]))) % +(b[a2 + 4 >> 2] | 0)) >>> 0;
        d2 = (b[a2 >> 2] | 0) + (d2 << 2) | 0;
        f = b[d2 >> 2] | 0;
        if (!f) {
          h = 1;
          return h | 0;
        }
        h = c2 + 32 | 0;
        do {
          if ((f | 0) != (c2 | 0)) {
            d2 = b[f + 32 >> 2] | 0;
            if (!d2) {
              h = 1;
              return h | 0;
            }
            g2 = d2;
            while (1) {
              if ((g2 | 0) == (c2 | 0)) {
                g2 = 8;
                break;
              }
              d2 = b[g2 + 32 >> 2] | 0;
              if (!d2) {
                d2 = 1;
                g2 = 10;
                break;
              } else {
                f = g2;
                g2 = d2;
              }
            }
            if ((g2 | 0) == 8) {
              b[f + 32 >> 2] = b[h >> 2];
              break;
            } else if ((g2 | 0) == 10) {
              return d2 | 0;
            }
          } else {
            b[d2 >> 2] = b[h >> 2];
          }
        } while (0);
        Xc(c2);
        h = a2 + 8 | 0;
        b[h >> 2] = (b[h >> 2] | 0) + -1;
        h = 0;
        return h | 0;
      }
      function Qc(a2, c2, d2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        var f = 0, g2 = 0, h = 0, i2 = 0;
        h = Wc(40) | 0;
        if (!h) {
          H(23283, 23253, 98, 23296);
        }
        b[h >> 2] = b[c2 >> 2];
        b[h + 4 >> 2] = b[c2 + 4 >> 2];
        b[h + 8 >> 2] = b[c2 + 8 >> 2];
        b[h + 12 >> 2] = b[c2 + 12 >> 2];
        g2 = h + 16 | 0;
        b[g2 >> 2] = b[d2 >> 2];
        b[g2 + 4 >> 2] = b[d2 + 4 >> 2];
        b[g2 + 8 >> 2] = b[d2 + 8 >> 2];
        b[g2 + 12 >> 2] = b[d2 + 12 >> 2];
        b[h + 32 >> 2] = 0;
        g2 = ~~(+q(+(+s(10, + +(15 - (b[a2 + 12 >> 2] | 0) | 0)) * (+e[c2 >> 3] + +e[c2 + 8 >> 3]))) % +(b[a2 + 4 >> 2] | 0)) >>> 0;
        g2 = (b[a2 >> 2] | 0) + (g2 << 2) | 0;
        f = b[g2 >> 2] | 0;
        do {
          if (!f) {
            b[g2 >> 2] = h;
          } else {
            while (1) {
              if (hb(f, c2) | 0 ? hb(f + 16 | 0, d2) | 0 : 0) {
                break;
              }
              g2 = b[f + 32 >> 2] | 0;
              f = (g2 | 0) == 0 ? f : g2;
              if (!(b[f + 32 >> 2] | 0)) {
                i2 = 10;
                break;
              }
            }
            if ((i2 | 0) == 10) {
              b[f + 32 >> 2] = h;
              break;
            }
            Xc(h);
            i2 = f;
            return i2 | 0;
          }
        } while (0);
        i2 = a2 + 8 | 0;
        b[i2 >> 2] = (b[i2 >> 2] | 0) + 1;
        i2 = h;
        return i2 | 0;
      }
      function Rc(a2, c2, d2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        var f = 0, g2 = 0;
        g2 = ~~(+q(+(+s(10, + +(15 - (b[a2 + 12 >> 2] | 0) | 0)) * (+e[c2 >> 3] + +e[c2 + 8 >> 3]))) % +(b[a2 + 4 >> 2] | 0)) >>> 0;
        g2 = b[(b[a2 >> 2] | 0) + (g2 << 2) >> 2] | 0;
        if (!g2) {
          d2 = 0;
          return d2 | 0;
        }
        if (!d2) {
          a2 = g2;
          while (1) {
            if (hb(a2, c2) | 0) {
              f = 10;
              break;
            }
            a2 = b[a2 + 32 >> 2] | 0;
            if (!a2) {
              a2 = 0;
              f = 10;
              break;
            }
          }
          if ((f | 0) == 10) {
            return a2 | 0;
          }
        }
        a2 = g2;
        while (1) {
          if (hb(a2, c2) | 0 ? hb(a2 + 16 | 0, d2) | 0 : 0) {
            f = 10;
            break;
          }
          a2 = b[a2 + 32 >> 2] | 0;
          if (!a2) {
            a2 = 0;
            f = 10;
            break;
          }
        }
        if ((f | 0) == 10) {
          return a2 | 0;
        }
        return 0;
      }
      function Sc(a2, c2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        var d2 = 0;
        d2 = ~~(+q(+(+s(10, + +(15 - (b[a2 + 12 >> 2] | 0) | 0)) * (+e[c2 >> 3] + +e[c2 + 8 >> 3]))) % +(b[a2 + 4 >> 2] | 0)) >>> 0;
        a2 = b[(b[a2 >> 2] | 0) + (d2 << 2) >> 2] | 0;
        if (!a2) {
          d2 = 0;
          return d2 | 0;
        }
        while (1) {
          if (hb(a2, c2) | 0) {
            c2 = 5;
            break;
          }
          a2 = b[a2 + 32 >> 2] | 0;
          if (!a2) {
            a2 = 0;
            c2 = 5;
            break;
          }
        }
        if ((c2 | 0) == 5) {
          return a2 | 0;
        }
        return 0;
      }
      function Tc() {
        return 23312;
      }
      function Uc(a2) {
        a2 = +a2;
        return + +id(+a2);
      }
      function Vc(a2) {
        a2 = +a2;
        return ~~+Uc(a2) | 0;
      }
      function Wc(a2) {
        a2 = a2 | 0;
        var c2 = 0, d2 = 0, e2 = 0, f = 0, g2 = 0, h = 0, i2 = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t2 = 0, u2 = 0, v2 = 0, w2 = 0;
        w2 = S;
        S = S + 16 | 0;
        n = w2;
        do {
          if (a2 >>> 0 < 245) {
            k = a2 >>> 0 < 11 ? 16 : a2 + 11 & -8;
            a2 = k >>> 3;
            m = b[5829] | 0;
            d2 = m >>> a2;
            if (d2 & 3 | 0) {
              c2 = (d2 & 1 ^ 1) + a2 | 0;
              a2 = 23356 + (c2 << 1 << 2) | 0;
              d2 = a2 + 8 | 0;
              e2 = b[d2 >> 2] | 0;
              f = e2 + 8 | 0;
              g2 = b[f >> 2] | 0;
              if ((g2 | 0) == (a2 | 0)) {
                b[5829] = m & ~(1 << c2);
              } else {
                b[g2 + 12 >> 2] = a2;
                b[d2 >> 2] = g2;
              }
              v2 = c2 << 3;
              b[e2 + 4 >> 2] = v2 | 3;
              v2 = e2 + v2 + 4 | 0;
              b[v2 >> 2] = b[v2 >> 2] | 1;
              v2 = f;
              S = w2;
              return v2 | 0;
            }
            l = b[5831] | 0;
            if (k >>> 0 > l >>> 0) {
              if (d2 | 0) {
                c2 = 2 << a2;
                c2 = d2 << a2 & (c2 | 0 - c2);
                c2 = (c2 & 0 - c2) + -1 | 0;
                i2 = c2 >>> 12 & 16;
                c2 = c2 >>> i2;
                d2 = c2 >>> 5 & 8;
                c2 = c2 >>> d2;
                g2 = c2 >>> 2 & 4;
                c2 = c2 >>> g2;
                a2 = c2 >>> 1 & 2;
                c2 = c2 >>> a2;
                e2 = c2 >>> 1 & 1;
                e2 = (d2 | i2 | g2 | a2 | e2) + (c2 >>> e2) | 0;
                c2 = 23356 + (e2 << 1 << 2) | 0;
                a2 = c2 + 8 | 0;
                g2 = b[a2 >> 2] | 0;
                i2 = g2 + 8 | 0;
                d2 = b[i2 >> 2] | 0;
                if ((d2 | 0) == (c2 | 0)) {
                  a2 = m & ~(1 << e2);
                  b[5829] = a2;
                } else {
                  b[d2 + 12 >> 2] = c2;
                  b[a2 >> 2] = d2;
                  a2 = m;
                }
                v2 = e2 << 3;
                h = v2 - k | 0;
                b[g2 + 4 >> 2] = k | 3;
                f = g2 + k | 0;
                b[f + 4 >> 2] = h | 1;
                b[g2 + v2 >> 2] = h;
                if (l | 0) {
                  e2 = b[5834] | 0;
                  c2 = l >>> 3;
                  d2 = 23356 + (c2 << 1 << 2) | 0;
                  c2 = 1 << c2;
                  if (!(a2 & c2)) {
                    b[5829] = a2 | c2;
                    c2 = d2;
                    a2 = d2 + 8 | 0;
                  } else {
                    a2 = d2 + 8 | 0;
                    c2 = b[a2 >> 2] | 0;
                  }
                  b[a2 >> 2] = e2;
                  b[c2 + 12 >> 2] = e2;
                  b[e2 + 8 >> 2] = c2;
                  b[e2 + 12 >> 2] = d2;
                }
                b[5831] = h;
                b[5834] = f;
                v2 = i2;
                S = w2;
                return v2 | 0;
              }
              g2 = b[5830] | 0;
              if (g2) {
                d2 = (g2 & 0 - g2) + -1 | 0;
                f = d2 >>> 12 & 16;
                d2 = d2 >>> f;
                e2 = d2 >>> 5 & 8;
                d2 = d2 >>> e2;
                h = d2 >>> 2 & 4;
                d2 = d2 >>> h;
                i2 = d2 >>> 1 & 2;
                d2 = d2 >>> i2;
                j = d2 >>> 1 & 1;
                j = b[23620 + ((e2 | f | h | i2 | j) + (d2 >>> j) << 2) >> 2] | 0;
                d2 = j;
                i2 = j;
                j = (b[j + 4 >> 2] & -8) - k | 0;
                while (1) {
                  a2 = b[d2 + 16 >> 2] | 0;
                  if (!a2) {
                    a2 = b[d2 + 20 >> 2] | 0;
                    if (!a2) {
                      break;
                    }
                  }
                  h = (b[a2 + 4 >> 2] & -8) - k | 0;
                  f = h >>> 0 < j >>> 0;
                  d2 = a2;
                  i2 = f ? a2 : i2;
                  j = f ? h : j;
                }
                h = i2 + k | 0;
                if (h >>> 0 > i2 >>> 0) {
                  f = b[i2 + 24 >> 2] | 0;
                  c2 = b[i2 + 12 >> 2] | 0;
                  do {
                    if ((c2 | 0) == (i2 | 0)) {
                      a2 = i2 + 20 | 0;
                      c2 = b[a2 >> 2] | 0;
                      if (!c2) {
                        a2 = i2 + 16 | 0;
                        c2 = b[a2 >> 2] | 0;
                        if (!c2) {
                          d2 = 0;
                          break;
                        }
                      }
                      while (1) {
                        e2 = c2 + 20 | 0;
                        d2 = b[e2 >> 2] | 0;
                        if (!d2) {
                          e2 = c2 + 16 | 0;
                          d2 = b[e2 >> 2] | 0;
                          if (!d2) {
                            break;
                          } else {
                            c2 = d2;
                            a2 = e2;
                          }
                        } else {
                          c2 = d2;
                          a2 = e2;
                        }
                      }
                      b[a2 >> 2] = 0;
                      d2 = c2;
                    } else {
                      d2 = b[i2 + 8 >> 2] | 0;
                      b[d2 + 12 >> 2] = c2;
                      b[c2 + 8 >> 2] = d2;
                      d2 = c2;
                    }
                  } while (0);
                  do {
                    if (f | 0) {
                      c2 = b[i2 + 28 >> 2] | 0;
                      a2 = 23620 + (c2 << 2) | 0;
                      if ((i2 | 0) == (b[a2 >> 2] | 0)) {
                        b[a2 >> 2] = d2;
                        if (!d2) {
                          b[5830] = g2 & ~(1 << c2);
                          break;
                        }
                      } else {
                        v2 = f + 16 | 0;
                        b[((b[v2 >> 2] | 0) == (i2 | 0) ? v2 : f + 20 | 0) >> 2] = d2;
                        if (!d2) {
                          break;
                        }
                      }
                      b[d2 + 24 >> 2] = f;
                      c2 = b[i2 + 16 >> 2] | 0;
                      if (c2 | 0) {
                        b[d2 + 16 >> 2] = c2;
                        b[c2 + 24 >> 2] = d2;
                      }
                      c2 = b[i2 + 20 >> 2] | 0;
                      if (c2 | 0) {
                        b[d2 + 20 >> 2] = c2;
                        b[c2 + 24 >> 2] = d2;
                      }
                    }
                  } while (0);
                  if (j >>> 0 < 16) {
                    v2 = j + k | 0;
                    b[i2 + 4 >> 2] = v2 | 3;
                    v2 = i2 + v2 + 4 | 0;
                    b[v2 >> 2] = b[v2 >> 2] | 1;
                  } else {
                    b[i2 + 4 >> 2] = k | 3;
                    b[h + 4 >> 2] = j | 1;
                    b[h + j >> 2] = j;
                    if (l | 0) {
                      e2 = b[5834] | 0;
                      c2 = l >>> 3;
                      d2 = 23356 + (c2 << 1 << 2) | 0;
                      c2 = 1 << c2;
                      if (!(c2 & m)) {
                        b[5829] = c2 | m;
                        c2 = d2;
                        a2 = d2 + 8 | 0;
                      } else {
                        a2 = d2 + 8 | 0;
                        c2 = b[a2 >> 2] | 0;
                      }
                      b[a2 >> 2] = e2;
                      b[c2 + 12 >> 2] = e2;
                      b[e2 + 8 >> 2] = c2;
                      b[e2 + 12 >> 2] = d2;
                    }
                    b[5831] = j;
                    b[5834] = h;
                  }
                  v2 = i2 + 8 | 0;
                  S = w2;
                  return v2 | 0;
                } else {
                  m = k;
                }
              } else {
                m = k;
              }
            } else {
              m = k;
            }
          } else if (a2 >>> 0 <= 4294967231) {
            a2 = a2 + 11 | 0;
            k = a2 & -8;
            e2 = b[5830] | 0;
            if (e2) {
              f = 0 - k | 0;
              a2 = a2 >>> 8;
              if (a2) {
                if (k >>> 0 > 16777215) {
                  j = 31;
                } else {
                  m = (a2 + 1048320 | 0) >>> 16 & 8;
                  q2 = a2 << m;
                  i2 = (q2 + 520192 | 0) >>> 16 & 4;
                  q2 = q2 << i2;
                  j = (q2 + 245760 | 0) >>> 16 & 2;
                  j = 14 - (i2 | m | j) + (q2 << j >>> 15) | 0;
                  j = k >>> (j + 7 | 0) & 1 | j << 1;
                }
              } else {
                j = 0;
              }
              d2 = b[23620 + (j << 2) >> 2] | 0;
              a:
                do {
                  if (!d2) {
                    d2 = 0;
                    a2 = 0;
                    q2 = 61;
                  } else {
                    a2 = 0;
                    i2 = k << ((j | 0) == 31 ? 0 : 25 - (j >>> 1) | 0);
                    g2 = 0;
                    while (1) {
                      h = (b[d2 + 4 >> 2] & -8) - k | 0;
                      if (h >>> 0 < f >>> 0) {
                        if (!h) {
                          a2 = d2;
                          f = 0;
                          q2 = 65;
                          break a;
                        } else {
                          a2 = d2;
                          f = h;
                        }
                      }
                      q2 = b[d2 + 20 >> 2] | 0;
                      d2 = b[d2 + 16 + (i2 >>> 31 << 2) >> 2] | 0;
                      g2 = (q2 | 0) == 0 | (q2 | 0) == (d2 | 0) ? g2 : q2;
                      if (!d2) {
                        d2 = g2;
                        q2 = 61;
                        break;
                      } else {
                        i2 = i2 << 1;
                      }
                    }
                  }
                } while (0);
              if ((q2 | 0) == 61) {
                if ((d2 | 0) == 0 & (a2 | 0) == 0) {
                  a2 = 2 << j;
                  a2 = (a2 | 0 - a2) & e2;
                  if (!a2) {
                    m = k;
                    break;
                  }
                  m = (a2 & 0 - a2) + -1 | 0;
                  h = m >>> 12 & 16;
                  m = m >>> h;
                  g2 = m >>> 5 & 8;
                  m = m >>> g2;
                  i2 = m >>> 2 & 4;
                  m = m >>> i2;
                  j = m >>> 1 & 2;
                  m = m >>> j;
                  d2 = m >>> 1 & 1;
                  a2 = 0;
                  d2 = b[23620 + ((g2 | h | i2 | j | d2) + (m >>> d2) << 2) >> 2] | 0;
                }
                if (!d2) {
                  i2 = a2;
                  h = f;
                } else {
                  q2 = 65;
                }
              }
              if ((q2 | 0) == 65) {
                g2 = d2;
                while (1) {
                  m = (b[g2 + 4 >> 2] & -8) - k | 0;
                  d2 = m >>> 0 < f >>> 0;
                  f = d2 ? m : f;
                  a2 = d2 ? g2 : a2;
                  d2 = b[g2 + 16 >> 2] | 0;
                  if (!d2) {
                    d2 = b[g2 + 20 >> 2] | 0;
                  }
                  if (!d2) {
                    i2 = a2;
                    h = f;
                    break;
                  } else {
                    g2 = d2;
                  }
                }
              }
              if (((i2 | 0) != 0 ? h >>> 0 < ((b[5831] | 0) - k | 0) >>> 0 : 0) ? (l = i2 + k | 0, l >>> 0 > i2 >>> 0) : 0) {
                g2 = b[i2 + 24 >> 2] | 0;
                c2 = b[i2 + 12 >> 2] | 0;
                do {
                  if ((c2 | 0) == (i2 | 0)) {
                    a2 = i2 + 20 | 0;
                    c2 = b[a2 >> 2] | 0;
                    if (!c2) {
                      a2 = i2 + 16 | 0;
                      c2 = b[a2 >> 2] | 0;
                      if (!c2) {
                        c2 = 0;
                        break;
                      }
                    }
                    while (1) {
                      f = c2 + 20 | 0;
                      d2 = b[f >> 2] | 0;
                      if (!d2) {
                        f = c2 + 16 | 0;
                        d2 = b[f >> 2] | 0;
                        if (!d2) {
                          break;
                        } else {
                          c2 = d2;
                          a2 = f;
                        }
                      } else {
                        c2 = d2;
                        a2 = f;
                      }
                    }
                    b[a2 >> 2] = 0;
                  } else {
                    v2 = b[i2 + 8 >> 2] | 0;
                    b[v2 + 12 >> 2] = c2;
                    b[c2 + 8 >> 2] = v2;
                  }
                } while (0);
                do {
                  if (g2) {
                    a2 = b[i2 + 28 >> 2] | 0;
                    d2 = 23620 + (a2 << 2) | 0;
                    if ((i2 | 0) == (b[d2 >> 2] | 0)) {
                      b[d2 >> 2] = c2;
                      if (!c2) {
                        e2 = e2 & ~(1 << a2);
                        b[5830] = e2;
                        break;
                      }
                    } else {
                      v2 = g2 + 16 | 0;
                      b[((b[v2 >> 2] | 0) == (i2 | 0) ? v2 : g2 + 20 | 0) >> 2] = c2;
                      if (!c2) {
                        break;
                      }
                    }
                    b[c2 + 24 >> 2] = g2;
                    a2 = b[i2 + 16 >> 2] | 0;
                    if (a2 | 0) {
                      b[c2 + 16 >> 2] = a2;
                      b[a2 + 24 >> 2] = c2;
                    }
                    a2 = b[i2 + 20 >> 2] | 0;
                    if (a2) {
                      b[c2 + 20 >> 2] = a2;
                      b[a2 + 24 >> 2] = c2;
                    }
                  }
                } while (0);
                b:
                  do {
                    if (h >>> 0 < 16) {
                      v2 = h + k | 0;
                      b[i2 + 4 >> 2] = v2 | 3;
                      v2 = i2 + v2 + 4 | 0;
                      b[v2 >> 2] = b[v2 >> 2] | 1;
                    } else {
                      b[i2 + 4 >> 2] = k | 3;
                      b[l + 4 >> 2] = h | 1;
                      b[l + h >> 2] = h;
                      c2 = h >>> 3;
                      if (h >>> 0 < 256) {
                        d2 = 23356 + (c2 << 1 << 2) | 0;
                        a2 = b[5829] | 0;
                        c2 = 1 << c2;
                        if (!(a2 & c2)) {
                          b[5829] = a2 | c2;
                          c2 = d2;
                          a2 = d2 + 8 | 0;
                        } else {
                          a2 = d2 + 8 | 0;
                          c2 = b[a2 >> 2] | 0;
                        }
                        b[a2 >> 2] = l;
                        b[c2 + 12 >> 2] = l;
                        b[l + 8 >> 2] = c2;
                        b[l + 12 >> 2] = d2;
                        break;
                      }
                      c2 = h >>> 8;
                      if (c2) {
                        if (h >>> 0 > 16777215) {
                          d2 = 31;
                        } else {
                          u2 = (c2 + 1048320 | 0) >>> 16 & 8;
                          v2 = c2 << u2;
                          t2 = (v2 + 520192 | 0) >>> 16 & 4;
                          v2 = v2 << t2;
                          d2 = (v2 + 245760 | 0) >>> 16 & 2;
                          d2 = 14 - (t2 | u2 | d2) + (v2 << d2 >>> 15) | 0;
                          d2 = h >>> (d2 + 7 | 0) & 1 | d2 << 1;
                        }
                      } else {
                        d2 = 0;
                      }
                      c2 = 23620 + (d2 << 2) | 0;
                      b[l + 28 >> 2] = d2;
                      a2 = l + 16 | 0;
                      b[a2 + 4 >> 2] = 0;
                      b[a2 >> 2] = 0;
                      a2 = 1 << d2;
                      if (!(e2 & a2)) {
                        b[5830] = e2 | a2;
                        b[c2 >> 2] = l;
                        b[l + 24 >> 2] = c2;
                        b[l + 12 >> 2] = l;
                        b[l + 8 >> 2] = l;
                        break;
                      }
                      c2 = b[c2 >> 2] | 0;
                      c:
                        do {
                          if ((b[c2 + 4 >> 2] & -8 | 0) != (h | 0)) {
                            e2 = h << ((d2 | 0) == 31 ? 0 : 25 - (d2 >>> 1) | 0);
                            while (1) {
                              d2 = c2 + 16 + (e2 >>> 31 << 2) | 0;
                              a2 = b[d2 >> 2] | 0;
                              if (!a2) {
                                break;
                              }
                              if ((b[a2 + 4 >> 2] & -8 | 0) == (h | 0)) {
                                c2 = a2;
                                break c;
                              } else {
                                e2 = e2 << 1;
                                c2 = a2;
                              }
                            }
                            b[d2 >> 2] = l;
                            b[l + 24 >> 2] = c2;
                            b[l + 12 >> 2] = l;
                            b[l + 8 >> 2] = l;
                            break b;
                          }
                        } while (0);
                      u2 = c2 + 8 | 0;
                      v2 = b[u2 >> 2] | 0;
                      b[v2 + 12 >> 2] = l;
                      b[u2 >> 2] = l;
                      b[l + 8 >> 2] = v2;
                      b[l + 12 >> 2] = c2;
                      b[l + 24 >> 2] = 0;
                    }
                  } while (0);
                v2 = i2 + 8 | 0;
                S = w2;
                return v2 | 0;
              } else {
                m = k;
              }
            } else {
              m = k;
            }
          } else {
            m = -1;
          }
        } while (0);
        d2 = b[5831] | 0;
        if (d2 >>> 0 >= m >>> 0) {
          c2 = d2 - m | 0;
          a2 = b[5834] | 0;
          if (c2 >>> 0 > 15) {
            v2 = a2 + m | 0;
            b[5834] = v2;
            b[5831] = c2;
            b[v2 + 4 >> 2] = c2 | 1;
            b[a2 + d2 >> 2] = c2;
            b[a2 + 4 >> 2] = m | 3;
          } else {
            b[5831] = 0;
            b[5834] = 0;
            b[a2 + 4 >> 2] = d2 | 3;
            v2 = a2 + d2 + 4 | 0;
            b[v2 >> 2] = b[v2 >> 2] | 1;
          }
          v2 = a2 + 8 | 0;
          S = w2;
          return v2 | 0;
        }
        h = b[5832] | 0;
        if (h >>> 0 > m >>> 0) {
          t2 = h - m | 0;
          b[5832] = t2;
          v2 = b[5835] | 0;
          u2 = v2 + m | 0;
          b[5835] = u2;
          b[u2 + 4 >> 2] = t2 | 1;
          b[v2 + 4 >> 2] = m | 3;
          v2 = v2 + 8 | 0;
          S = w2;
          return v2 | 0;
        }
        if (!(b[5947] | 0)) {
          b[5949] = 4096;
          b[5948] = 4096;
          b[5950] = -1;
          b[5951] = -1;
          b[5952] = 0;
          b[5940] = 0;
          b[5947] = n & -16 ^ 1431655768;
          a2 = 4096;
        } else {
          a2 = b[5949] | 0;
        }
        i2 = m + 48 | 0;
        j = m + 47 | 0;
        g2 = a2 + j | 0;
        f = 0 - a2 | 0;
        k = g2 & f;
        if (k >>> 0 <= m >>> 0) {
          v2 = 0;
          S = w2;
          return v2 | 0;
        }
        a2 = b[5939] | 0;
        if (a2 | 0 ? (l = b[5937] | 0, n = l + k | 0, n >>> 0 <= l >>> 0 | n >>> 0 > a2 >>> 0) : 0) {
          v2 = 0;
          S = w2;
          return v2 | 0;
        }
        d:
          do {
            if (!(b[5940] & 4)) {
              d2 = b[5835] | 0;
              e:
                do {
                  if (d2) {
                    e2 = 23764;
                    while (1) {
                      n = b[e2 >> 2] | 0;
                      if (n >>> 0 <= d2 >>> 0 ? (n + (b[e2 + 4 >> 2] | 0) | 0) >>> 0 > d2 >>> 0 : 0) {
                        break;
                      }
                      a2 = b[e2 + 8 >> 2] | 0;
                      if (!a2) {
                        q2 = 128;
                        break e;
                      } else {
                        e2 = a2;
                      }
                    }
                    c2 = g2 - h & f;
                    if (c2 >>> 0 < 2147483647) {
                      a2 = jd(c2 | 0) | 0;
                      if ((a2 | 0) == ((b[e2 >> 2] | 0) + (b[e2 + 4 >> 2] | 0) | 0)) {
                        if ((a2 | 0) != (-1 | 0)) {
                          h = c2;
                          g2 = a2;
                          q2 = 145;
                          break d;
                        }
                      } else {
                        e2 = a2;
                        q2 = 136;
                      }
                    } else {
                      c2 = 0;
                    }
                  } else {
                    q2 = 128;
                  }
                } while (0);
              do {
                if ((q2 | 0) == 128) {
                  d2 = jd(0) | 0;
                  if ((d2 | 0) != (-1 | 0) ? (c2 = d2, o = b[5948] | 0, p2 = o + -1 | 0, c2 = ((p2 & c2 | 0) == 0 ? 0 : (p2 + c2 & 0 - o) - c2 | 0) + k | 0, o = b[5937] | 0, p2 = c2 + o | 0, c2 >>> 0 > m >>> 0 & c2 >>> 0 < 2147483647) : 0) {
                    n = b[5939] | 0;
                    if (n | 0 ? p2 >>> 0 <= o >>> 0 | p2 >>> 0 > n >>> 0 : 0) {
                      c2 = 0;
                      break;
                    }
                    a2 = jd(c2 | 0) | 0;
                    if ((a2 | 0) == (d2 | 0)) {
                      h = c2;
                      g2 = d2;
                      q2 = 145;
                      break d;
                    } else {
                      e2 = a2;
                      q2 = 136;
                    }
                  } else {
                    c2 = 0;
                  }
                }
              } while (0);
              do {
                if ((q2 | 0) == 136) {
                  d2 = 0 - c2 | 0;
                  if (!(i2 >>> 0 > c2 >>> 0 & (c2 >>> 0 < 2147483647 & (e2 | 0) != (-1 | 0)))) {
                    if ((e2 | 0) == (-1 | 0)) {
                      c2 = 0;
                      break;
                    } else {
                      h = c2;
                      g2 = e2;
                      q2 = 145;
                      break d;
                    }
                  }
                  a2 = b[5949] | 0;
                  a2 = j - c2 + a2 & 0 - a2;
                  if (a2 >>> 0 >= 2147483647) {
                    h = c2;
                    g2 = e2;
                    q2 = 145;
                    break d;
                  }
                  if ((jd(a2 | 0) | 0) == (-1 | 0)) {
                    jd(d2 | 0) | 0;
                    c2 = 0;
                    break;
                  } else {
                    h = a2 + c2 | 0;
                    g2 = e2;
                    q2 = 145;
                    break d;
                  }
                }
              } while (0);
              b[5940] = b[5940] | 4;
              q2 = 143;
            } else {
              c2 = 0;
              q2 = 143;
            }
          } while (0);
        if (((q2 | 0) == 143 ? k >>> 0 < 2147483647 : 0) ? (t2 = jd(k | 0) | 0, p2 = jd(0) | 0, r2 = p2 - t2 | 0, s2 = r2 >>> 0 > (m + 40 | 0) >>> 0, !((t2 | 0) == (-1 | 0) | s2 ^ 1 | t2 >>> 0 < p2 >>> 0 & ((t2 | 0) != (-1 | 0) & (p2 | 0) != (-1 | 0)) ^ 1)) : 0) {
          h = s2 ? r2 : c2;
          g2 = t2;
          q2 = 145;
        }
        if ((q2 | 0) == 145) {
          c2 = (b[5937] | 0) + h | 0;
          b[5937] = c2;
          if (c2 >>> 0 > (b[5938] | 0) >>> 0) {
            b[5938] = c2;
          }
          j = b[5835] | 0;
          f:
            do {
              if (j) {
                c2 = 23764;
                while (1) {
                  a2 = b[c2 >> 2] | 0;
                  d2 = b[c2 + 4 >> 2] | 0;
                  if ((g2 | 0) == (a2 + d2 | 0)) {
                    q2 = 154;
                    break;
                  }
                  e2 = b[c2 + 8 >> 2] | 0;
                  if (!e2) {
                    break;
                  } else {
                    c2 = e2;
                  }
                }
                if (((q2 | 0) == 154 ? (u2 = c2 + 4 | 0, (b[c2 + 12 >> 2] & 8 | 0) == 0) : 0) ? g2 >>> 0 > j >>> 0 & a2 >>> 0 <= j >>> 0 : 0) {
                  b[u2 >> 2] = d2 + h;
                  v2 = (b[5832] | 0) + h | 0;
                  t2 = j + 8 | 0;
                  t2 = (t2 & 7 | 0) == 0 ? 0 : 0 - t2 & 7;
                  u2 = j + t2 | 0;
                  t2 = v2 - t2 | 0;
                  b[5835] = u2;
                  b[5832] = t2;
                  b[u2 + 4 >> 2] = t2 | 1;
                  b[j + v2 + 4 >> 2] = 40;
                  b[5836] = b[5951];
                  break;
                }
                if (g2 >>> 0 < (b[5833] | 0) >>> 0) {
                  b[5833] = g2;
                }
                d2 = g2 + h | 0;
                c2 = 23764;
                while (1) {
                  if ((b[c2 >> 2] | 0) == (d2 | 0)) {
                    q2 = 162;
                    break;
                  }
                  a2 = b[c2 + 8 >> 2] | 0;
                  if (!a2) {
                    break;
                  } else {
                    c2 = a2;
                  }
                }
                if ((q2 | 0) == 162 ? (b[c2 + 12 >> 2] & 8 | 0) == 0 : 0) {
                  b[c2 >> 2] = g2;
                  l = c2 + 4 | 0;
                  b[l >> 2] = (b[l >> 2] | 0) + h;
                  l = g2 + 8 | 0;
                  l = g2 + ((l & 7 | 0) == 0 ? 0 : 0 - l & 7) | 0;
                  c2 = d2 + 8 | 0;
                  c2 = d2 + ((c2 & 7 | 0) == 0 ? 0 : 0 - c2 & 7) | 0;
                  k = l + m | 0;
                  i2 = c2 - l - m | 0;
                  b[l + 4 >> 2] = m | 3;
                  g:
                    do {
                      if ((j | 0) == (c2 | 0)) {
                        v2 = (b[5832] | 0) + i2 | 0;
                        b[5832] = v2;
                        b[5835] = k;
                        b[k + 4 >> 2] = v2 | 1;
                      } else {
                        if ((b[5834] | 0) == (c2 | 0)) {
                          v2 = (b[5831] | 0) + i2 | 0;
                          b[5831] = v2;
                          b[5834] = k;
                          b[k + 4 >> 2] = v2 | 1;
                          b[k + v2 >> 2] = v2;
                          break;
                        }
                        a2 = b[c2 + 4 >> 2] | 0;
                        if ((a2 & 3 | 0) == 1) {
                          h = a2 & -8;
                          e2 = a2 >>> 3;
                          h:
                            do {
                              if (a2 >>> 0 < 256) {
                                a2 = b[c2 + 8 >> 2] | 0;
                                d2 = b[c2 + 12 >> 2] | 0;
                                if ((d2 | 0) == (a2 | 0)) {
                                  b[5829] = b[5829] & ~(1 << e2);
                                  break;
                                } else {
                                  b[a2 + 12 >> 2] = d2;
                                  b[d2 + 8 >> 2] = a2;
                                  break;
                                }
                              } else {
                                g2 = b[c2 + 24 >> 2] | 0;
                                a2 = b[c2 + 12 >> 2] | 0;
                                do {
                                  if ((a2 | 0) == (c2 | 0)) {
                                    d2 = c2 + 16 | 0;
                                    e2 = d2 + 4 | 0;
                                    a2 = b[e2 >> 2] | 0;
                                    if (!a2) {
                                      a2 = b[d2 >> 2] | 0;
                                      if (!a2) {
                                        a2 = 0;
                                        break;
                                      }
                                    } else {
                                      d2 = e2;
                                    }
                                    while (1) {
                                      f = a2 + 20 | 0;
                                      e2 = b[f >> 2] | 0;
                                      if (!e2) {
                                        f = a2 + 16 | 0;
                                        e2 = b[f >> 2] | 0;
                                        if (!e2) {
                                          break;
                                        } else {
                                          a2 = e2;
                                          d2 = f;
                                        }
                                      } else {
                                        a2 = e2;
                                        d2 = f;
                                      }
                                    }
                                    b[d2 >> 2] = 0;
                                  } else {
                                    v2 = b[c2 + 8 >> 2] | 0;
                                    b[v2 + 12 >> 2] = a2;
                                    b[a2 + 8 >> 2] = v2;
                                  }
                                } while (0);
                                if (!g2) {
                                  break;
                                }
                                d2 = b[c2 + 28 >> 2] | 0;
                                e2 = 23620 + (d2 << 2) | 0;
                                do {
                                  if ((b[e2 >> 2] | 0) != (c2 | 0)) {
                                    v2 = g2 + 16 | 0;
                                    b[((b[v2 >> 2] | 0) == (c2 | 0) ? v2 : g2 + 20 | 0) >> 2] = a2;
                                    if (!a2) {
                                      break h;
                                    }
                                  } else {
                                    b[e2 >> 2] = a2;
                                    if (a2 | 0) {
                                      break;
                                    }
                                    b[5830] = b[5830] & ~(1 << d2);
                                    break h;
                                  }
                                } while (0);
                                b[a2 + 24 >> 2] = g2;
                                d2 = c2 + 16 | 0;
                                e2 = b[d2 >> 2] | 0;
                                if (e2 | 0) {
                                  b[a2 + 16 >> 2] = e2;
                                  b[e2 + 24 >> 2] = a2;
                                }
                                d2 = b[d2 + 4 >> 2] | 0;
                                if (!d2) {
                                  break;
                                }
                                b[a2 + 20 >> 2] = d2;
                                b[d2 + 24 >> 2] = a2;
                              }
                            } while (0);
                          c2 = c2 + h | 0;
                          f = h + i2 | 0;
                        } else {
                          f = i2;
                        }
                        c2 = c2 + 4 | 0;
                        b[c2 >> 2] = b[c2 >> 2] & -2;
                        b[k + 4 >> 2] = f | 1;
                        b[k + f >> 2] = f;
                        c2 = f >>> 3;
                        if (f >>> 0 < 256) {
                          d2 = 23356 + (c2 << 1 << 2) | 0;
                          a2 = b[5829] | 0;
                          c2 = 1 << c2;
                          if (!(a2 & c2)) {
                            b[5829] = a2 | c2;
                            c2 = d2;
                            a2 = d2 + 8 | 0;
                          } else {
                            a2 = d2 + 8 | 0;
                            c2 = b[a2 >> 2] | 0;
                          }
                          b[a2 >> 2] = k;
                          b[c2 + 12 >> 2] = k;
                          b[k + 8 >> 2] = c2;
                          b[k + 12 >> 2] = d2;
                          break;
                        }
                        c2 = f >>> 8;
                        do {
                          if (!c2) {
                            e2 = 0;
                          } else {
                            if (f >>> 0 > 16777215) {
                              e2 = 31;
                              break;
                            }
                            u2 = (c2 + 1048320 | 0) >>> 16 & 8;
                            v2 = c2 << u2;
                            t2 = (v2 + 520192 | 0) >>> 16 & 4;
                            v2 = v2 << t2;
                            e2 = (v2 + 245760 | 0) >>> 16 & 2;
                            e2 = 14 - (t2 | u2 | e2) + (v2 << e2 >>> 15) | 0;
                            e2 = f >>> (e2 + 7 | 0) & 1 | e2 << 1;
                          }
                        } while (0);
                        c2 = 23620 + (e2 << 2) | 0;
                        b[k + 28 >> 2] = e2;
                        a2 = k + 16 | 0;
                        b[a2 + 4 >> 2] = 0;
                        b[a2 >> 2] = 0;
                        a2 = b[5830] | 0;
                        d2 = 1 << e2;
                        if (!(a2 & d2)) {
                          b[5830] = a2 | d2;
                          b[c2 >> 2] = k;
                          b[k + 24 >> 2] = c2;
                          b[k + 12 >> 2] = k;
                          b[k + 8 >> 2] = k;
                          break;
                        }
                        c2 = b[c2 >> 2] | 0;
                        i:
                          do {
                            if ((b[c2 + 4 >> 2] & -8 | 0) != (f | 0)) {
                              e2 = f << ((e2 | 0) == 31 ? 0 : 25 - (e2 >>> 1) | 0);
                              while (1) {
                                d2 = c2 + 16 + (e2 >>> 31 << 2) | 0;
                                a2 = b[d2 >> 2] | 0;
                                if (!a2) {
                                  break;
                                }
                                if ((b[a2 + 4 >> 2] & -8 | 0) == (f | 0)) {
                                  c2 = a2;
                                  break i;
                                } else {
                                  e2 = e2 << 1;
                                  c2 = a2;
                                }
                              }
                              b[d2 >> 2] = k;
                              b[k + 24 >> 2] = c2;
                              b[k + 12 >> 2] = k;
                              b[k + 8 >> 2] = k;
                              break g;
                            }
                          } while (0);
                        u2 = c2 + 8 | 0;
                        v2 = b[u2 >> 2] | 0;
                        b[v2 + 12 >> 2] = k;
                        b[u2 >> 2] = k;
                        b[k + 8 >> 2] = v2;
                        b[k + 12 >> 2] = c2;
                        b[k + 24 >> 2] = 0;
                      }
                    } while (0);
                  v2 = l + 8 | 0;
                  S = w2;
                  return v2 | 0;
                }
                c2 = 23764;
                while (1) {
                  a2 = b[c2 >> 2] | 0;
                  if (a2 >>> 0 <= j >>> 0 ? (v2 = a2 + (b[c2 + 4 >> 2] | 0) | 0, v2 >>> 0 > j >>> 0) : 0) {
                    break;
                  }
                  c2 = b[c2 + 8 >> 2] | 0;
                }
                f = v2 + -47 | 0;
                a2 = f + 8 | 0;
                a2 = f + ((a2 & 7 | 0) == 0 ? 0 : 0 - a2 & 7) | 0;
                f = j + 16 | 0;
                a2 = a2 >>> 0 < f >>> 0 ? j : a2;
                c2 = a2 + 8 | 0;
                d2 = h + -40 | 0;
                t2 = g2 + 8 | 0;
                t2 = (t2 & 7 | 0) == 0 ? 0 : 0 - t2 & 7;
                u2 = g2 + t2 | 0;
                t2 = d2 - t2 | 0;
                b[5835] = u2;
                b[5832] = t2;
                b[u2 + 4 >> 2] = t2 | 1;
                b[g2 + d2 + 4 >> 2] = 40;
                b[5836] = b[5951];
                d2 = a2 + 4 | 0;
                b[d2 >> 2] = 27;
                b[c2 >> 2] = b[5941];
                b[c2 + 4 >> 2] = b[5942];
                b[c2 + 8 >> 2] = b[5943];
                b[c2 + 12 >> 2] = b[5944];
                b[5941] = g2;
                b[5942] = h;
                b[5944] = 0;
                b[5943] = c2;
                c2 = a2 + 24 | 0;
                do {
                  u2 = c2;
                  c2 = c2 + 4 | 0;
                  b[c2 >> 2] = 7;
                } while ((u2 + 8 | 0) >>> 0 < v2 >>> 0);
                if ((a2 | 0) != (j | 0)) {
                  g2 = a2 - j | 0;
                  b[d2 >> 2] = b[d2 >> 2] & -2;
                  b[j + 4 >> 2] = g2 | 1;
                  b[a2 >> 2] = g2;
                  c2 = g2 >>> 3;
                  if (g2 >>> 0 < 256) {
                    d2 = 23356 + (c2 << 1 << 2) | 0;
                    a2 = b[5829] | 0;
                    c2 = 1 << c2;
                    if (!(a2 & c2)) {
                      b[5829] = a2 | c2;
                      c2 = d2;
                      a2 = d2 + 8 | 0;
                    } else {
                      a2 = d2 + 8 | 0;
                      c2 = b[a2 >> 2] | 0;
                    }
                    b[a2 >> 2] = j;
                    b[c2 + 12 >> 2] = j;
                    b[j + 8 >> 2] = c2;
                    b[j + 12 >> 2] = d2;
                    break;
                  }
                  c2 = g2 >>> 8;
                  if (c2) {
                    if (g2 >>> 0 > 16777215) {
                      e2 = 31;
                    } else {
                      u2 = (c2 + 1048320 | 0) >>> 16 & 8;
                      v2 = c2 << u2;
                      t2 = (v2 + 520192 | 0) >>> 16 & 4;
                      v2 = v2 << t2;
                      e2 = (v2 + 245760 | 0) >>> 16 & 2;
                      e2 = 14 - (t2 | u2 | e2) + (v2 << e2 >>> 15) | 0;
                      e2 = g2 >>> (e2 + 7 | 0) & 1 | e2 << 1;
                    }
                  } else {
                    e2 = 0;
                  }
                  d2 = 23620 + (e2 << 2) | 0;
                  b[j + 28 >> 2] = e2;
                  b[j + 20 >> 2] = 0;
                  b[f >> 2] = 0;
                  c2 = b[5830] | 0;
                  a2 = 1 << e2;
                  if (!(c2 & a2)) {
                    b[5830] = c2 | a2;
                    b[d2 >> 2] = j;
                    b[j + 24 >> 2] = d2;
                    b[j + 12 >> 2] = j;
                    b[j + 8 >> 2] = j;
                    break;
                  }
                  c2 = b[d2 >> 2] | 0;
                  j:
                    do {
                      if ((b[c2 + 4 >> 2] & -8 | 0) != (g2 | 0)) {
                        e2 = g2 << ((e2 | 0) == 31 ? 0 : 25 - (e2 >>> 1) | 0);
                        while (1) {
                          d2 = c2 + 16 + (e2 >>> 31 << 2) | 0;
                          a2 = b[d2 >> 2] | 0;
                          if (!a2) {
                            break;
                          }
                          if ((b[a2 + 4 >> 2] & -8 | 0) == (g2 | 0)) {
                            c2 = a2;
                            break j;
                          } else {
                            e2 = e2 << 1;
                            c2 = a2;
                          }
                        }
                        b[d2 >> 2] = j;
                        b[j + 24 >> 2] = c2;
                        b[j + 12 >> 2] = j;
                        b[j + 8 >> 2] = j;
                        break f;
                      }
                    } while (0);
                  u2 = c2 + 8 | 0;
                  v2 = b[u2 >> 2] | 0;
                  b[v2 + 12 >> 2] = j;
                  b[u2 >> 2] = j;
                  b[j + 8 >> 2] = v2;
                  b[j + 12 >> 2] = c2;
                  b[j + 24 >> 2] = 0;
                }
              } else {
                v2 = b[5833] | 0;
                if ((v2 | 0) == 0 | g2 >>> 0 < v2 >>> 0) {
                  b[5833] = g2;
                }
                b[5941] = g2;
                b[5942] = h;
                b[5944] = 0;
                b[5838] = b[5947];
                b[5837] = -1;
                b[5842] = 23356;
                b[5841] = 23356;
                b[5844] = 23364;
                b[5843] = 23364;
                b[5846] = 23372;
                b[5845] = 23372;
                b[5848] = 23380;
                b[5847] = 23380;
                b[5850] = 23388;
                b[5849] = 23388;
                b[5852] = 23396;
                b[5851] = 23396;
                b[5854] = 23404;
                b[5853] = 23404;
                b[5856] = 23412;
                b[5855] = 23412;
                b[5858] = 23420;
                b[5857] = 23420;
                b[5860] = 23428;
                b[5859] = 23428;
                b[5862] = 23436;
                b[5861] = 23436;
                b[5864] = 23444;
                b[5863] = 23444;
                b[5866] = 23452;
                b[5865] = 23452;
                b[5868] = 23460;
                b[5867] = 23460;
                b[5870] = 23468;
                b[5869] = 23468;
                b[5872] = 23476;
                b[5871] = 23476;
                b[5874] = 23484;
                b[5873] = 23484;
                b[5876] = 23492;
                b[5875] = 23492;
                b[5878] = 23500;
                b[5877] = 23500;
                b[5880] = 23508;
                b[5879] = 23508;
                b[5882] = 23516;
                b[5881] = 23516;
                b[5884] = 23524;
                b[5883] = 23524;
                b[5886] = 23532;
                b[5885] = 23532;
                b[5888] = 23540;
                b[5887] = 23540;
                b[5890] = 23548;
                b[5889] = 23548;
                b[5892] = 23556;
                b[5891] = 23556;
                b[5894] = 23564;
                b[5893] = 23564;
                b[5896] = 23572;
                b[5895] = 23572;
                b[5898] = 23580;
                b[5897] = 23580;
                b[5900] = 23588;
                b[5899] = 23588;
                b[5902] = 23596;
                b[5901] = 23596;
                b[5904] = 23604;
                b[5903] = 23604;
                v2 = h + -40 | 0;
                t2 = g2 + 8 | 0;
                t2 = (t2 & 7 | 0) == 0 ? 0 : 0 - t2 & 7;
                u2 = g2 + t2 | 0;
                t2 = v2 - t2 | 0;
                b[5835] = u2;
                b[5832] = t2;
                b[u2 + 4 >> 2] = t2 | 1;
                b[g2 + v2 + 4 >> 2] = 40;
                b[5836] = b[5951];
              }
            } while (0);
          c2 = b[5832] | 0;
          if (c2 >>> 0 > m >>> 0) {
            t2 = c2 - m | 0;
            b[5832] = t2;
            v2 = b[5835] | 0;
            u2 = v2 + m | 0;
            b[5835] = u2;
            b[u2 + 4 >> 2] = t2 | 1;
            b[v2 + 4 >> 2] = m | 3;
            v2 = v2 + 8 | 0;
            S = w2;
            return v2 | 0;
          }
        }
        v2 = Tc() | 0;
        b[v2 >> 2] = 12;
        v2 = 0;
        S = w2;
        return v2 | 0;
      }
      function Xc(a2) {
        a2 = a2 | 0;
        var c2 = 0, d2 = 0, e2 = 0, f = 0, g2 = 0, h = 0, i2 = 0, j = 0;
        if (!a2) {
          return;
        }
        d2 = a2 + -8 | 0;
        f = b[5833] | 0;
        a2 = b[a2 + -4 >> 2] | 0;
        c2 = a2 & -8;
        j = d2 + c2 | 0;
        do {
          if (!(a2 & 1)) {
            e2 = b[d2 >> 2] | 0;
            if (!(a2 & 3)) {
              return;
            }
            h = d2 + (0 - e2) | 0;
            g2 = e2 + c2 | 0;
            if (h >>> 0 < f >>> 0) {
              return;
            }
            if ((b[5834] | 0) == (h | 0)) {
              a2 = j + 4 | 0;
              c2 = b[a2 >> 2] | 0;
              if ((c2 & 3 | 0) != 3) {
                i2 = h;
                c2 = g2;
                break;
              }
              b[5831] = g2;
              b[a2 >> 2] = c2 & -2;
              b[h + 4 >> 2] = g2 | 1;
              b[h + g2 >> 2] = g2;
              return;
            }
            d2 = e2 >>> 3;
            if (e2 >>> 0 < 256) {
              a2 = b[h + 8 >> 2] | 0;
              c2 = b[h + 12 >> 2] | 0;
              if ((c2 | 0) == (a2 | 0)) {
                b[5829] = b[5829] & ~(1 << d2);
                i2 = h;
                c2 = g2;
                break;
              } else {
                b[a2 + 12 >> 2] = c2;
                b[c2 + 8 >> 2] = a2;
                i2 = h;
                c2 = g2;
                break;
              }
            }
            f = b[h + 24 >> 2] | 0;
            a2 = b[h + 12 >> 2] | 0;
            do {
              if ((a2 | 0) == (h | 0)) {
                c2 = h + 16 | 0;
                d2 = c2 + 4 | 0;
                a2 = b[d2 >> 2] | 0;
                if (!a2) {
                  a2 = b[c2 >> 2] | 0;
                  if (!a2) {
                    a2 = 0;
                    break;
                  }
                } else {
                  c2 = d2;
                }
                while (1) {
                  e2 = a2 + 20 | 0;
                  d2 = b[e2 >> 2] | 0;
                  if (!d2) {
                    e2 = a2 + 16 | 0;
                    d2 = b[e2 >> 2] | 0;
                    if (!d2) {
                      break;
                    } else {
                      a2 = d2;
                      c2 = e2;
                    }
                  } else {
                    a2 = d2;
                    c2 = e2;
                  }
                }
                b[c2 >> 2] = 0;
              } else {
                i2 = b[h + 8 >> 2] | 0;
                b[i2 + 12 >> 2] = a2;
                b[a2 + 8 >> 2] = i2;
              }
            } while (0);
            if (f) {
              c2 = b[h + 28 >> 2] | 0;
              d2 = 23620 + (c2 << 2) | 0;
              if ((b[d2 >> 2] | 0) == (h | 0)) {
                b[d2 >> 2] = a2;
                if (!a2) {
                  b[5830] = b[5830] & ~(1 << c2);
                  i2 = h;
                  c2 = g2;
                  break;
                }
              } else {
                i2 = f + 16 | 0;
                b[((b[i2 >> 2] | 0) == (h | 0) ? i2 : f + 20 | 0) >> 2] = a2;
                if (!a2) {
                  i2 = h;
                  c2 = g2;
                  break;
                }
              }
              b[a2 + 24 >> 2] = f;
              c2 = h + 16 | 0;
              d2 = b[c2 >> 2] | 0;
              if (d2 | 0) {
                b[a2 + 16 >> 2] = d2;
                b[d2 + 24 >> 2] = a2;
              }
              c2 = b[c2 + 4 >> 2] | 0;
              if (c2) {
                b[a2 + 20 >> 2] = c2;
                b[c2 + 24 >> 2] = a2;
                i2 = h;
                c2 = g2;
              } else {
                i2 = h;
                c2 = g2;
              }
            } else {
              i2 = h;
              c2 = g2;
            }
          } else {
            i2 = d2;
            h = d2;
          }
        } while (0);
        if (h >>> 0 >= j >>> 0) {
          return;
        }
        a2 = j + 4 | 0;
        e2 = b[a2 >> 2] | 0;
        if (!(e2 & 1)) {
          return;
        }
        if (!(e2 & 2)) {
          if ((b[5835] | 0) == (j | 0)) {
            j = (b[5832] | 0) + c2 | 0;
            b[5832] = j;
            b[5835] = i2;
            b[i2 + 4 >> 2] = j | 1;
            if ((i2 | 0) != (b[5834] | 0)) {
              return;
            }
            b[5834] = 0;
            b[5831] = 0;
            return;
          }
          if ((b[5834] | 0) == (j | 0)) {
            j = (b[5831] | 0) + c2 | 0;
            b[5831] = j;
            b[5834] = h;
            b[i2 + 4 >> 2] = j | 1;
            b[h + j >> 2] = j;
            return;
          }
          f = (e2 & -8) + c2 | 0;
          d2 = e2 >>> 3;
          do {
            if (e2 >>> 0 < 256) {
              c2 = b[j + 8 >> 2] | 0;
              a2 = b[j + 12 >> 2] | 0;
              if ((a2 | 0) == (c2 | 0)) {
                b[5829] = b[5829] & ~(1 << d2);
                break;
              } else {
                b[c2 + 12 >> 2] = a2;
                b[a2 + 8 >> 2] = c2;
                break;
              }
            } else {
              g2 = b[j + 24 >> 2] | 0;
              a2 = b[j + 12 >> 2] | 0;
              do {
                if ((a2 | 0) == (j | 0)) {
                  c2 = j + 16 | 0;
                  d2 = c2 + 4 | 0;
                  a2 = b[d2 >> 2] | 0;
                  if (!a2) {
                    a2 = b[c2 >> 2] | 0;
                    if (!a2) {
                      d2 = 0;
                      break;
                    }
                  } else {
                    c2 = d2;
                  }
                  while (1) {
                    e2 = a2 + 20 | 0;
                    d2 = b[e2 >> 2] | 0;
                    if (!d2) {
                      e2 = a2 + 16 | 0;
                      d2 = b[e2 >> 2] | 0;
                      if (!d2) {
                        break;
                      } else {
                        a2 = d2;
                        c2 = e2;
                      }
                    } else {
                      a2 = d2;
                      c2 = e2;
                    }
                  }
                  b[c2 >> 2] = 0;
                  d2 = a2;
                } else {
                  d2 = b[j + 8 >> 2] | 0;
                  b[d2 + 12 >> 2] = a2;
                  b[a2 + 8 >> 2] = d2;
                  d2 = a2;
                }
              } while (0);
              if (g2 | 0) {
                a2 = b[j + 28 >> 2] | 0;
                c2 = 23620 + (a2 << 2) | 0;
                if ((b[c2 >> 2] | 0) == (j | 0)) {
                  b[c2 >> 2] = d2;
                  if (!d2) {
                    b[5830] = b[5830] & ~(1 << a2);
                    break;
                  }
                } else {
                  e2 = g2 + 16 | 0;
                  b[((b[e2 >> 2] | 0) == (j | 0) ? e2 : g2 + 20 | 0) >> 2] = d2;
                  if (!d2) {
                    break;
                  }
                }
                b[d2 + 24 >> 2] = g2;
                a2 = j + 16 | 0;
                c2 = b[a2 >> 2] | 0;
                if (c2 | 0) {
                  b[d2 + 16 >> 2] = c2;
                  b[c2 + 24 >> 2] = d2;
                }
                a2 = b[a2 + 4 >> 2] | 0;
                if (a2 | 0) {
                  b[d2 + 20 >> 2] = a2;
                  b[a2 + 24 >> 2] = d2;
                }
              }
            }
          } while (0);
          b[i2 + 4 >> 2] = f | 1;
          b[h + f >> 2] = f;
          if ((i2 | 0) == (b[5834] | 0)) {
            b[5831] = f;
            return;
          }
        } else {
          b[a2 >> 2] = e2 & -2;
          b[i2 + 4 >> 2] = c2 | 1;
          b[h + c2 >> 2] = c2;
          f = c2;
        }
        a2 = f >>> 3;
        if (f >>> 0 < 256) {
          d2 = 23356 + (a2 << 1 << 2) | 0;
          c2 = b[5829] | 0;
          a2 = 1 << a2;
          if (!(c2 & a2)) {
            b[5829] = c2 | a2;
            a2 = d2;
            c2 = d2 + 8 | 0;
          } else {
            c2 = d2 + 8 | 0;
            a2 = b[c2 >> 2] | 0;
          }
          b[c2 >> 2] = i2;
          b[a2 + 12 >> 2] = i2;
          b[i2 + 8 >> 2] = a2;
          b[i2 + 12 >> 2] = d2;
          return;
        }
        a2 = f >>> 8;
        if (a2) {
          if (f >>> 0 > 16777215) {
            e2 = 31;
          } else {
            h = (a2 + 1048320 | 0) >>> 16 & 8;
            j = a2 << h;
            g2 = (j + 520192 | 0) >>> 16 & 4;
            j = j << g2;
            e2 = (j + 245760 | 0) >>> 16 & 2;
            e2 = 14 - (g2 | h | e2) + (j << e2 >>> 15) | 0;
            e2 = f >>> (e2 + 7 | 0) & 1 | e2 << 1;
          }
        } else {
          e2 = 0;
        }
        a2 = 23620 + (e2 << 2) | 0;
        b[i2 + 28 >> 2] = e2;
        b[i2 + 20 >> 2] = 0;
        b[i2 + 16 >> 2] = 0;
        c2 = b[5830] | 0;
        d2 = 1 << e2;
        a:
          do {
            if (!(c2 & d2)) {
              b[5830] = c2 | d2;
              b[a2 >> 2] = i2;
              b[i2 + 24 >> 2] = a2;
              b[i2 + 12 >> 2] = i2;
              b[i2 + 8 >> 2] = i2;
            } else {
              a2 = b[a2 >> 2] | 0;
              b:
                do {
                  if ((b[a2 + 4 >> 2] & -8 | 0) != (f | 0)) {
                    e2 = f << ((e2 | 0) == 31 ? 0 : 25 - (e2 >>> 1) | 0);
                    while (1) {
                      d2 = a2 + 16 + (e2 >>> 31 << 2) | 0;
                      c2 = b[d2 >> 2] | 0;
                      if (!c2) {
                        break;
                      }
                      if ((b[c2 + 4 >> 2] & -8 | 0) == (f | 0)) {
                        a2 = c2;
                        break b;
                      } else {
                        e2 = e2 << 1;
                        a2 = c2;
                      }
                    }
                    b[d2 >> 2] = i2;
                    b[i2 + 24 >> 2] = a2;
                    b[i2 + 12 >> 2] = i2;
                    b[i2 + 8 >> 2] = i2;
                    break a;
                  }
                } while (0);
              h = a2 + 8 | 0;
              j = b[h >> 2] | 0;
              b[j + 12 >> 2] = i2;
              b[h >> 2] = i2;
              b[i2 + 8 >> 2] = j;
              b[i2 + 12 >> 2] = a2;
              b[i2 + 24 >> 2] = 0;
            }
          } while (0);
        j = (b[5837] | 0) + -1 | 0;
        b[5837] = j;
        if (j | 0) {
          return;
        }
        a2 = 23772;
        while (1) {
          a2 = b[a2 >> 2] | 0;
          if (!a2) {
            break;
          } else {
            a2 = a2 + 8 | 0;
          }
        }
        b[5837] = -1;
        return;
      }
      function Yc(a2, c2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        var d2 = 0;
        if (a2) {
          d2 = B(c2, a2) | 0;
          if ((c2 | a2) >>> 0 > 65535) {
            d2 = ((d2 >>> 0) / (a2 >>> 0) | 0 | 0) == (c2 | 0) ? d2 : -1;
          }
        } else {
          d2 = 0;
        }
        a2 = Wc(d2) | 0;
        if (!a2) {
          return a2 | 0;
        }
        if (!(b[a2 + -4 >> 2] & 3)) {
          return a2 | 0;
        }
        hd(a2 | 0, 0, d2 | 0) | 0;
        return a2 | 0;
      }
      function Zc(a2, b2, c2, d2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        c2 = a2 + c2 >>> 0;
        return (F(b2 + d2 + (c2 >>> 0 < a2 >>> 0 | 0) >>> 0 | 0), c2 | 0) | 0;
      }
      function _c(a2, b2, c2, d2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        d2 = b2 - d2 - (c2 >>> 0 > a2 >>> 0 | 0) >>> 0;
        return (F(d2 | 0), a2 - c2 >>> 0 | 0) | 0;
      }
      function $c(a2) {
        a2 = a2 | 0;
        return (a2 ? 31 - (D(a2 ^ a2 - 1) | 0) | 0 : 32) | 0;
      }
      function ad(a2, c2, d2, e2, f) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        f = f | 0;
        var g2 = 0, h = 0, i2 = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0;
        l = a2;
        j = c2;
        k = j;
        h = d2;
        n = e2;
        i2 = n;
        if (!k) {
          g2 = (f | 0) != 0;
          if (!i2) {
            if (g2) {
              b[f >> 2] = (l >>> 0) % (h >>> 0);
              b[f + 4 >> 2] = 0;
            }
            n = 0;
            f = (l >>> 0) / (h >>> 0) >>> 0;
            return (F(n | 0), f) | 0;
          } else {
            if (!g2) {
              n = 0;
              f = 0;
              return (F(n | 0), f) | 0;
            }
            b[f >> 2] = a2 | 0;
            b[f + 4 >> 2] = c2 & 0;
            n = 0;
            f = 0;
            return (F(n | 0), f) | 0;
          }
        }
        g2 = (i2 | 0) == 0;
        do {
          if (h) {
            if (!g2) {
              g2 = (D(i2 | 0) | 0) - (D(k | 0) | 0) | 0;
              if (g2 >>> 0 <= 31) {
                m = g2 + 1 | 0;
                i2 = 31 - g2 | 0;
                c2 = g2 - 31 >> 31;
                h = m;
                a2 = l >>> (m >>> 0) & c2 | k << i2;
                c2 = k >>> (m >>> 0) & c2;
                g2 = 0;
                i2 = l << i2;
                break;
              }
              if (!f) {
                n = 0;
                f = 0;
                return (F(n | 0), f) | 0;
              }
              b[f >> 2] = a2 | 0;
              b[f + 4 >> 2] = j | c2 & 0;
              n = 0;
              f = 0;
              return (F(n | 0), f) | 0;
            }
            g2 = h - 1 | 0;
            if (g2 & h | 0) {
              i2 = (D(h | 0) | 0) + 33 - (D(k | 0) | 0) | 0;
              p2 = 64 - i2 | 0;
              m = 32 - i2 | 0;
              j = m >> 31;
              o = i2 - 32 | 0;
              c2 = o >> 31;
              h = i2;
              a2 = m - 1 >> 31 & k >>> (o >>> 0) | (k << m | l >>> (i2 >>> 0)) & c2;
              c2 = c2 & k >>> (i2 >>> 0);
              g2 = l << p2 & j;
              i2 = (k << p2 | l >>> (o >>> 0)) & j | l << m & i2 - 33 >> 31;
              break;
            }
            if (f | 0) {
              b[f >> 2] = g2 & l;
              b[f + 4 >> 2] = 0;
            }
            if ((h | 0) == 1) {
              o = j | c2 & 0;
              p2 = a2 | 0 | 0;
              return (F(o | 0), p2) | 0;
            } else {
              p2 = $c(h | 0) | 0;
              o = k >>> (p2 >>> 0) | 0;
              p2 = k << 32 - p2 | l >>> (p2 >>> 0) | 0;
              return (F(o | 0), p2) | 0;
            }
          } else {
            if (g2) {
              if (f | 0) {
                b[f >> 2] = (k >>> 0) % (h >>> 0);
                b[f + 4 >> 2] = 0;
              }
              o = 0;
              p2 = (k >>> 0) / (h >>> 0) >>> 0;
              return (F(o | 0), p2) | 0;
            }
            if (!l) {
              if (f | 0) {
                b[f >> 2] = 0;
                b[f + 4 >> 2] = (k >>> 0) % (i2 >>> 0);
              }
              o = 0;
              p2 = (k >>> 0) / (i2 >>> 0) >>> 0;
              return (F(o | 0), p2) | 0;
            }
            g2 = i2 - 1 | 0;
            if (!(g2 & i2)) {
              if (f | 0) {
                b[f >> 2] = a2 | 0;
                b[f + 4 >> 2] = g2 & k | c2 & 0;
              }
              o = 0;
              p2 = k >>> (($c(i2 | 0) | 0) >>> 0);
              return (F(o | 0), p2) | 0;
            }
            g2 = (D(i2 | 0) | 0) - (D(k | 0) | 0) | 0;
            if (g2 >>> 0 <= 30) {
              c2 = g2 + 1 | 0;
              i2 = 31 - g2 | 0;
              h = c2;
              a2 = k << i2 | l >>> (c2 >>> 0);
              c2 = k >>> (c2 >>> 0);
              g2 = 0;
              i2 = l << i2;
              break;
            }
            if (!f) {
              o = 0;
              p2 = 0;
              return (F(o | 0), p2) | 0;
            }
            b[f >> 2] = a2 | 0;
            b[f + 4 >> 2] = j | c2 & 0;
            o = 0;
            p2 = 0;
            return (F(o | 0), p2) | 0;
          }
        } while (0);
        if (!h) {
          k = i2;
          j = 0;
          i2 = 0;
        } else {
          m = d2 | 0 | 0;
          l = n | e2 & 0;
          k = Zc(m | 0, l | 0, -1, -1) | 0;
          d2 = G() | 0;
          j = i2;
          i2 = 0;
          do {
            e2 = j;
            j = g2 >>> 31 | j << 1;
            g2 = i2 | g2 << 1;
            e2 = a2 << 1 | e2 >>> 31 | 0;
            n = a2 >>> 31 | c2 << 1 | 0;
            _c(k | 0, d2 | 0, e2 | 0, n | 0) | 0;
            p2 = G() | 0;
            o = p2 >> 31 | ((p2 | 0) < 0 ? -1 : 0) << 1;
            i2 = o & 1;
            a2 = _c(e2 | 0, n | 0, o & m | 0, (((p2 | 0) < 0 ? -1 : 0) >> 31 | ((p2 | 0) < 0 ? -1 : 0) << 1) & l | 0) | 0;
            c2 = G() | 0;
            h = h - 1 | 0;
          } while ((h | 0) != 0);
          k = j;
          j = 0;
        }
        h = 0;
        if (f | 0) {
          b[f >> 2] = a2;
          b[f + 4 >> 2] = c2;
        }
        o = (g2 | 0) >>> 31 | (k | h) << 1 | (h << 1 | g2 >>> 31) & 0 | j;
        p2 = (g2 << 1 | 0 >>> 31) & -2 | i2;
        return (F(o | 0), p2) | 0;
      }
      function bd(a2, c2, d2, e2) {
        a2 = a2 | 0;
        c2 = c2 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        var f = 0, g2 = 0;
        g2 = S;
        S = S + 16 | 0;
        f = g2 | 0;
        ad(a2, c2, d2, e2, f) | 0;
        S = g2;
        return (F(b[f + 4 >> 2] | 0), b[f >> 2] | 0) | 0;
      }
      function cd(a2, b2, c2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        c2 = c2 | 0;
        if ((c2 | 0) < 32) {
          F(b2 >>> c2 | 0);
          return a2 >>> c2 | (b2 & (1 << c2) - 1) << 32 - c2;
        }
        F(0);
        return b2 >>> c2 - 32 | 0;
      }
      function dd(a2, b2, c2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        c2 = c2 | 0;
        if ((c2 | 0) < 32) {
          F(b2 << c2 | (a2 & (1 << c2) - 1 << 32 - c2) >>> 32 - c2 | 0);
          return a2 << c2;
        }
        F(a2 << c2 - 32 | 0);
        return 0;
      }
      function ed(a2, b2) {
        a2 = +a2;
        b2 = +b2;
        if (a2 != a2) {
          return +b2;
        }
        if (b2 != b2) {
          return +a2;
        }
        return +C(+a2, +b2);
      }
      function fd(a2) {
        a2 = +a2;
        return a2 >= 0 ? +p(a2 + 0.5) : +A(a2 - 0.5);
      }
      function gd(c2, d2, e2) {
        c2 = c2 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        var f = 0, g2 = 0, h = 0;
        if ((e2 | 0) >= 8192) {
          K(c2 | 0, d2 | 0, e2 | 0) | 0;
          return c2 | 0;
        }
        h = c2 | 0;
        g2 = c2 + e2 | 0;
        if ((c2 & 3) == (d2 & 3)) {
          while (c2 & 3) {
            if (!e2) {
              return h | 0;
            }
            a[c2 >> 0] = a[d2 >> 0] | 0;
            c2 = c2 + 1 | 0;
            d2 = d2 + 1 | 0;
            e2 = e2 - 1 | 0;
          }
          e2 = g2 & -4 | 0;
          f = e2 - 64 | 0;
          while ((c2 | 0) <= (f | 0)) {
            b[c2 >> 2] = b[d2 >> 2];
            b[c2 + 4 >> 2] = b[d2 + 4 >> 2];
            b[c2 + 8 >> 2] = b[d2 + 8 >> 2];
            b[c2 + 12 >> 2] = b[d2 + 12 >> 2];
            b[c2 + 16 >> 2] = b[d2 + 16 >> 2];
            b[c2 + 20 >> 2] = b[d2 + 20 >> 2];
            b[c2 + 24 >> 2] = b[d2 + 24 >> 2];
            b[c2 + 28 >> 2] = b[d2 + 28 >> 2];
            b[c2 + 32 >> 2] = b[d2 + 32 >> 2];
            b[c2 + 36 >> 2] = b[d2 + 36 >> 2];
            b[c2 + 40 >> 2] = b[d2 + 40 >> 2];
            b[c2 + 44 >> 2] = b[d2 + 44 >> 2];
            b[c2 + 48 >> 2] = b[d2 + 48 >> 2];
            b[c2 + 52 >> 2] = b[d2 + 52 >> 2];
            b[c2 + 56 >> 2] = b[d2 + 56 >> 2];
            b[c2 + 60 >> 2] = b[d2 + 60 >> 2];
            c2 = c2 + 64 | 0;
            d2 = d2 + 64 | 0;
          }
          while ((c2 | 0) < (e2 | 0)) {
            b[c2 >> 2] = b[d2 >> 2];
            c2 = c2 + 4 | 0;
            d2 = d2 + 4 | 0;
          }
        } else {
          e2 = g2 - 4 | 0;
          while ((c2 | 0) < (e2 | 0)) {
            a[c2 >> 0] = a[d2 >> 0] | 0;
            a[c2 + 1 >> 0] = a[d2 + 1 >> 0] | 0;
            a[c2 + 2 >> 0] = a[d2 + 2 >> 0] | 0;
            a[c2 + 3 >> 0] = a[d2 + 3 >> 0] | 0;
            c2 = c2 + 4 | 0;
            d2 = d2 + 4 | 0;
          }
        }
        while ((c2 | 0) < (g2 | 0)) {
          a[c2 >> 0] = a[d2 >> 0] | 0;
          c2 = c2 + 1 | 0;
          d2 = d2 + 1 | 0;
        }
        return h | 0;
      }
      function hd(c2, d2, e2) {
        c2 = c2 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        var f = 0, g2 = 0, h = 0, i2 = 0;
        h = c2 + e2 | 0;
        d2 = d2 & 255;
        if ((e2 | 0) >= 67) {
          while (c2 & 3) {
            a[c2 >> 0] = d2;
            c2 = c2 + 1 | 0;
          }
          f = h & -4 | 0;
          i2 = d2 | d2 << 8 | d2 << 16 | d2 << 24;
          g2 = f - 64 | 0;
          while ((c2 | 0) <= (g2 | 0)) {
            b[c2 >> 2] = i2;
            b[c2 + 4 >> 2] = i2;
            b[c2 + 8 >> 2] = i2;
            b[c2 + 12 >> 2] = i2;
            b[c2 + 16 >> 2] = i2;
            b[c2 + 20 >> 2] = i2;
            b[c2 + 24 >> 2] = i2;
            b[c2 + 28 >> 2] = i2;
            b[c2 + 32 >> 2] = i2;
            b[c2 + 36 >> 2] = i2;
            b[c2 + 40 >> 2] = i2;
            b[c2 + 44 >> 2] = i2;
            b[c2 + 48 >> 2] = i2;
            b[c2 + 52 >> 2] = i2;
            b[c2 + 56 >> 2] = i2;
            b[c2 + 60 >> 2] = i2;
            c2 = c2 + 64 | 0;
          }
          while ((c2 | 0) < (f | 0)) {
            b[c2 >> 2] = i2;
            c2 = c2 + 4 | 0;
          }
        }
        while ((c2 | 0) < (h | 0)) {
          a[c2 >> 0] = d2;
          c2 = c2 + 1 | 0;
        }
        return h - e2 | 0;
      }
      function id(a2) {
        a2 = +a2;
        return a2 >= 0 ? +p(a2 + 0.5) : +A(a2 - 0.5);
      }
      function jd(a2) {
        a2 = a2 | 0;
        var c2 = 0, d2 = 0, e2 = 0;
        e2 = J() | 0;
        d2 = b[g >> 2] | 0;
        c2 = d2 + a2 | 0;
        if ((a2 | 0) > 0 & (c2 | 0) < (d2 | 0) | (c2 | 0) < 0) {
          M(c2 | 0) | 0;
          I(12);
          return -1;
        }
        if ((c2 | 0) > (e2 | 0)) {
          if (!(L(c2 | 0) | 0)) {
            I(12);
            return -1;
          }
        }
        b[g >> 2] = c2;
        return d2 | 0;
      }
      return {
        ___uremdi3: bd,
        _bitshift64Lshr: cd,
        _bitshift64Shl: dd,
        _calloc: Yc,
        _cellAreaKm2: ub,
        _cellAreaM2: vb,
        _cellAreaRads2: tb,
        _compact: Hb,
        _destroyLinkedPolygon: jc,
        _edgeLengthKm: pb,
        _edgeLengthM: qb,
        _emscripten_replace_memory: V,
        _exactEdgeLengthKm: xb,
        _exactEdgeLengthM: yb,
        _exactEdgeLengthRads: wb,
        _experimentalH3ToLocalIj: oc,
        _experimentalLocalIjToH3: pc,
        _free: Xc,
        _geoToH3: Sb,
        _getDestinationH3IndexFromUnidirectionalEdge: cc,
        _getH3IndexesFromUnidirectionalEdge: ec,
        _getH3UnidirectionalEdge: ac,
        _getH3UnidirectionalEdgeBoundary: gc,
        _getH3UnidirectionalEdgesFromHexagon: fc,
        _getOriginH3IndexFromUnidirectionalEdge: bc,
        _getPentagonIndexes: _b,
        _getRes0Indexes: va,
        _h3Distance: qc,
        _h3GetBaseCell: Ab,
        _h3GetFaces: Yb,
        _h3GetResolution: zb,
        _h3IndexesAreNeighbors: $b,
        _h3IsPentagon: Fb,
        _h3IsResClassIII: Kb,
        _h3IsValid: Bb,
        _h3Line: sc,
        _h3LineSize: rc,
        _h3SetToLinkedGeo: ka,
        _h3ToCenterChild: Gb,
        _h3ToChildren: Eb,
        _h3ToGeo: Vb,
        _h3ToGeoBoundary: Wb,
        _h3ToParent: Cb,
        _h3UnidirectionalEdgeIsValid: dc,
        _hexAreaKm2: nb,
        _hexAreaM2: ob,
        _hexRing: ea,
        _i64Subtract: _c,
        _kRing: $,
        _kRingDistances: aa,
        _llvm_minnum_f64: ed,
        _llvm_round_f64: fd,
        _malloc: Wc,
        _maxFaceCount: Xb,
        _maxH3ToChildrenSize: Db,
        _maxKringSize: _,
        _maxPolyfillSize: fa,
        _maxUncompactSize: Jb,
        _memcpy: gd,
        _memset: hd,
        _numHexagons: rb,
        _pentagonIndexCount: Zb,
        _pointDistKm: jb,
        _pointDistM: kb,
        _pointDistRads: ib,
        _polyfill: ga,
        _res0IndexCount: ua,
        _round: id,
        _sbrk: jd,
        _sizeOfCoordIJ: Ec,
        _sizeOfGeoBoundary: Ac,
        _sizeOfGeoCoord: zc,
        _sizeOfGeoPolygon: Cc,
        _sizeOfGeofence: Bc,
        _sizeOfH3Index: yc,
        _sizeOfLinkedGeoPolygon: Dc,
        _uncompact: Ib,
        establishStackSpace: Z,
        stackAlloc: W,
        stackRestore: Y,
        stackSave: X
      };
    }(
      // EMSCRIPTEN_END_ASM
      asmGlobalArg,
      asmLibraryArg,
      buffer
    )
  );
  var ___uremdi3 = Module["___uremdi3"] = asm["___uremdi3"];
  var _bitshift64Lshr = Module["_bitshift64Lshr"] = asm["_bitshift64Lshr"];
  var _bitshift64Shl = Module["_bitshift64Shl"] = asm["_bitshift64Shl"];
  var _calloc = Module["_calloc"] = asm["_calloc"];
  var _cellAreaKm2 = Module["_cellAreaKm2"] = asm["_cellAreaKm2"];
  var _cellAreaM2 = Module["_cellAreaM2"] = asm["_cellAreaM2"];
  var _cellAreaRads2 = Module["_cellAreaRads2"] = asm["_cellAreaRads2"];
  var _compact = Module["_compact"] = asm["_compact"];
  var _destroyLinkedPolygon = Module["_destroyLinkedPolygon"] = asm["_destroyLinkedPolygon"];
  var _edgeLengthKm = Module["_edgeLengthKm"] = asm["_edgeLengthKm"];
  var _edgeLengthM = Module["_edgeLengthM"] = asm["_edgeLengthM"];
  var _emscripten_replace_memory = Module["_emscripten_replace_memory"] = asm["_emscripten_replace_memory"];
  var _exactEdgeLengthKm = Module["_exactEdgeLengthKm"] = asm["_exactEdgeLengthKm"];
  var _exactEdgeLengthM = Module["_exactEdgeLengthM"] = asm["_exactEdgeLengthM"];
  var _exactEdgeLengthRads = Module["_exactEdgeLengthRads"] = asm["_exactEdgeLengthRads"];
  var _experimentalH3ToLocalIj = Module["_experimentalH3ToLocalIj"] = asm["_experimentalH3ToLocalIj"];
  var _experimentalLocalIjToH3 = Module["_experimentalLocalIjToH3"] = asm["_experimentalLocalIjToH3"];
  var _free = Module["_free"] = asm["_free"];
  var _geoToH3 = Module["_geoToH3"] = asm["_geoToH3"];
  var _getDestinationH3IndexFromUnidirectionalEdge = Module["_getDestinationH3IndexFromUnidirectionalEdge"] = asm["_getDestinationH3IndexFromUnidirectionalEdge"];
  var _getH3IndexesFromUnidirectionalEdge = Module["_getH3IndexesFromUnidirectionalEdge"] = asm["_getH3IndexesFromUnidirectionalEdge"];
  var _getH3UnidirectionalEdge = Module["_getH3UnidirectionalEdge"] = asm["_getH3UnidirectionalEdge"];
  var _getH3UnidirectionalEdgeBoundary = Module["_getH3UnidirectionalEdgeBoundary"] = asm["_getH3UnidirectionalEdgeBoundary"];
  var _getH3UnidirectionalEdgesFromHexagon = Module["_getH3UnidirectionalEdgesFromHexagon"] = asm["_getH3UnidirectionalEdgesFromHexagon"];
  var _getOriginH3IndexFromUnidirectionalEdge = Module["_getOriginH3IndexFromUnidirectionalEdge"] = asm["_getOriginH3IndexFromUnidirectionalEdge"];
  var _getPentagonIndexes = Module["_getPentagonIndexes"] = asm["_getPentagonIndexes"];
  var _getRes0Indexes = Module["_getRes0Indexes"] = asm["_getRes0Indexes"];
  var _h3Distance = Module["_h3Distance"] = asm["_h3Distance"];
  var _h3GetBaseCell = Module["_h3GetBaseCell"] = asm["_h3GetBaseCell"];
  var _h3GetFaces = Module["_h3GetFaces"] = asm["_h3GetFaces"];
  var _h3GetResolution = Module["_h3GetResolution"] = asm["_h3GetResolution"];
  var _h3IndexesAreNeighbors = Module["_h3IndexesAreNeighbors"] = asm["_h3IndexesAreNeighbors"];
  var _h3IsPentagon = Module["_h3IsPentagon"] = asm["_h3IsPentagon"];
  var _h3IsResClassIII = Module["_h3IsResClassIII"] = asm["_h3IsResClassIII"];
  var _h3IsValid = Module["_h3IsValid"] = asm["_h3IsValid"];
  var _h3Line = Module["_h3Line"] = asm["_h3Line"];
  var _h3LineSize = Module["_h3LineSize"] = asm["_h3LineSize"];
  var _h3SetToLinkedGeo = Module["_h3SetToLinkedGeo"] = asm["_h3SetToLinkedGeo"];
  var _h3ToCenterChild = Module["_h3ToCenterChild"] = asm["_h3ToCenterChild"];
  var _h3ToChildren = Module["_h3ToChildren"] = asm["_h3ToChildren"];
  var _h3ToGeo = Module["_h3ToGeo"] = asm["_h3ToGeo"];
  var _h3ToGeoBoundary = Module["_h3ToGeoBoundary"] = asm["_h3ToGeoBoundary"];
  var _h3ToParent = Module["_h3ToParent"] = asm["_h3ToParent"];
  var _h3UnidirectionalEdgeIsValid = Module["_h3UnidirectionalEdgeIsValid"] = asm["_h3UnidirectionalEdgeIsValid"];
  var _hexAreaKm2 = Module["_hexAreaKm2"] = asm["_hexAreaKm2"];
  var _hexAreaM2 = Module["_hexAreaM2"] = asm["_hexAreaM2"];
  var _hexRing = Module["_hexRing"] = asm["_hexRing"];
  var _i64Subtract = Module["_i64Subtract"] = asm["_i64Subtract"];
  var _kRing = Module["_kRing"] = asm["_kRing"];
  var _kRingDistances = Module["_kRingDistances"] = asm["_kRingDistances"];
  var _llvm_minnum_f64 = Module["_llvm_minnum_f64"] = asm["_llvm_minnum_f64"];
  var _llvm_round_f64 = Module["_llvm_round_f64"] = asm["_llvm_round_f64"];
  var _malloc = Module["_malloc"] = asm["_malloc"];
  var _maxFaceCount = Module["_maxFaceCount"] = asm["_maxFaceCount"];
  var _maxH3ToChildrenSize = Module["_maxH3ToChildrenSize"] = asm["_maxH3ToChildrenSize"];
  var _maxKringSize = Module["_maxKringSize"] = asm["_maxKringSize"];
  var _maxPolyfillSize = Module["_maxPolyfillSize"] = asm["_maxPolyfillSize"];
  var _maxUncompactSize = Module["_maxUncompactSize"] = asm["_maxUncompactSize"];
  var _memcpy = Module["_memcpy"] = asm["_memcpy"];
  var _memset = Module["_memset"] = asm["_memset"];
  var _numHexagons = Module["_numHexagons"] = asm["_numHexagons"];
  var _pentagonIndexCount = Module["_pentagonIndexCount"] = asm["_pentagonIndexCount"];
  var _pointDistKm = Module["_pointDistKm"] = asm["_pointDistKm"];
  var _pointDistM = Module["_pointDistM"] = asm["_pointDistM"];
  var _pointDistRads = Module["_pointDistRads"] = asm["_pointDistRads"];
  var _polyfill = Module["_polyfill"] = asm["_polyfill"];
  var _res0IndexCount = Module["_res0IndexCount"] = asm["_res0IndexCount"];
  var _round = Module["_round"] = asm["_round"];
  var _sbrk = Module["_sbrk"] = asm["_sbrk"];
  var _sizeOfCoordIJ = Module["_sizeOfCoordIJ"] = asm["_sizeOfCoordIJ"];
  var _sizeOfGeoBoundary = Module["_sizeOfGeoBoundary"] = asm["_sizeOfGeoBoundary"];
  var _sizeOfGeoCoord = Module["_sizeOfGeoCoord"] = asm["_sizeOfGeoCoord"];
  var _sizeOfGeoPolygon = Module["_sizeOfGeoPolygon"] = asm["_sizeOfGeoPolygon"];
  var _sizeOfGeofence = Module["_sizeOfGeofence"] = asm["_sizeOfGeofence"];
  var _sizeOfH3Index = Module["_sizeOfH3Index"] = asm["_sizeOfH3Index"];
  var _sizeOfLinkedGeoPolygon = Module["_sizeOfLinkedGeoPolygon"] = asm["_sizeOfLinkedGeoPolygon"];
  var _uncompact = Module["_uncompact"] = asm["_uncompact"];
  var establishStackSpace = Module["establishStackSpace"] = asm["establishStackSpace"];
  var stackAlloc = Module["stackAlloc"] = asm["stackAlloc"];
  var stackRestore = Module["stackRestore"] = asm["stackRestore"];
  var stackSave = Module["stackSave"] = asm["stackSave"];
  Module["asm"] = asm;
  Module["cwrap"] = cwrap;
  Module["setValue"] = setValue;
  Module["getValue"] = getValue;
  Module["getTempRet0"] = getTempRet0;
  if (memoryInitializer) {
    if (!isDataURI(memoryInitializer)) {
      memoryInitializer = locateFile(memoryInitializer);
    }
    {
      addRunDependency("memory initializer");
      var applyMemoryInitializer = function(data) {
        if (data.byteLength) {
          data = new Uint8Array(data);
        }
        HEAPU8.set(data, GLOBAL_BASE);
        if (Module["memoryInitializerRequest"]) {
          delete Module["memoryInitializerRequest"].response;
        }
        removeRunDependency("memory initializer");
      };
      var doBrowserLoad = function() {
        readAsync(memoryInitializer, applyMemoryInitializer, function() {
          throw "could not load memory initializer " + memoryInitializer;
        });
      };
      var memoryInitializerBytes = tryParseAsDataURI(memoryInitializer);
      if (memoryInitializerBytes) {
        applyMemoryInitializer(memoryInitializerBytes.buffer);
      } else if (Module["memoryInitializerRequest"]) {
        var useRequest = function() {
          var request = Module["memoryInitializerRequest"];
          var response = request.response;
          if (request.status !== 200 && request.status !== 0) {
            var data = tryParseAsDataURI(Module["memoryInitializerRequestURL"]);
            if (data) {
              response = data.buffer;
            } else {
              console.warn("a problem seems to have happened with Module.memoryInitializerRequest, status: " + request.status + ", retrying " + memoryInitializer);
              doBrowserLoad();
              return;
            }
          }
          applyMemoryInitializer(response);
        };
        if (Module["memoryInitializerRequest"].response) {
          setTimeout(useRequest, 0);
        } else {
          Module["memoryInitializerRequest"].addEventListener("load", useRequest);
        }
      } else {
        doBrowserLoad();
      }
    }
  }
  var calledRun;
  dependenciesFulfilled = function runCaller() {
    if (!calledRun) {
      run();
    }
    if (!calledRun) {
      dependenciesFulfilled = runCaller;
    }
  };
  function run(args) {
    args = args || arguments_;
    if (runDependencies > 0) {
      return;
    }
    preRun();
    if (runDependencies > 0) {
      return;
    }
    function doRun() {
      if (calledRun) {
        return;
      }
      calledRun = true;
      if (ABORT) {
        return;
      }
      initRuntime();
      preMain();
      if (Module["onRuntimeInitialized"]) {
        Module["onRuntimeInitialized"]();
      }
      postRun();
    }
    if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(function() {
        setTimeout(function() {
          Module["setStatus"]("");
        }, 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  Module["run"] = run;
  function abort(what) {
    if (Module["onAbort"]) {
      Module["onAbort"](what);
    }
    what += "";
    out(what);
    err(what);
    ABORT = true;
    throw "abort(" + what + "). Build with -s ASSERTIONS=1 for more info.";
  }
  Module["abort"] = abort;
  if (Module["preInit"]) {
    if (typeof Module["preInit"] == "function") {
      Module["preInit"] = [Module["preInit"]];
    }
    while (Module["preInit"].length > 0) {
      Module["preInit"].pop()();
    }
  }
  run();
  return libh32;
}(typeof libh3 === "object" ? libh3 : {});
var NUMBER = "number";
var BOOLEAN = NUMBER;
var H3_LOWER = NUMBER;
var H3_UPPER = NUMBER;
var RESOLUTION = NUMBER;
var POINTER = NUMBER;
var BINDINGS = [
  // The size functions are inserted via build/sizes.h
  ["sizeOfH3Index", NUMBER],
  ["sizeOfGeoCoord", NUMBER],
  ["sizeOfGeoBoundary", NUMBER],
  ["sizeOfGeoPolygon", NUMBER],
  ["sizeOfGeofence", NUMBER],
  ["sizeOfLinkedGeoPolygon", NUMBER],
  ["sizeOfCoordIJ", NUMBER],
  // The remaining functions are defined in the core lib in h3Api.h
  ["h3IsValid", BOOLEAN, [H3_LOWER, H3_UPPER]],
  ["geoToH3", H3_LOWER, [NUMBER, NUMBER, RESOLUTION]],
  ["h3ToGeo", null, [H3_LOWER, H3_UPPER, POINTER]],
  ["h3ToGeoBoundary", null, [H3_LOWER, H3_UPPER, POINTER]],
  ["maxKringSize", NUMBER, [NUMBER]],
  ["kRing", null, [H3_LOWER, H3_UPPER, NUMBER, POINTER]],
  ["kRingDistances", null, [H3_LOWER, H3_UPPER, NUMBER, POINTER, POINTER]],
  ["hexRing", null, [H3_LOWER, H3_UPPER, NUMBER, POINTER]],
  ["maxPolyfillSize", NUMBER, [POINTER, RESOLUTION]],
  ["polyfill", null, [POINTER, RESOLUTION, POINTER]],
  ["h3SetToLinkedGeo", null, [POINTER, NUMBER, POINTER]],
  ["destroyLinkedPolygon", null, [POINTER]],
  ["compact", NUMBER, [POINTER, POINTER, NUMBER]],
  ["uncompact", NUMBER, [POINTER, NUMBER, POINTER, NUMBER, RESOLUTION]],
  ["maxUncompactSize", NUMBER, [POINTER, NUMBER, RESOLUTION]],
  ["h3IsPentagon", BOOLEAN, [H3_LOWER, H3_UPPER]],
  ["h3IsResClassIII", BOOLEAN, [H3_LOWER, H3_UPPER]],
  ["h3GetBaseCell", NUMBER, [H3_LOWER, H3_UPPER]],
  ["h3GetResolution", NUMBER, [H3_LOWER, H3_UPPER]],
  ["maxFaceCount", NUMBER, [H3_LOWER, H3_UPPER]],
  ["h3GetFaces", null, [H3_LOWER, H3_UPPER, POINTER]],
  ["h3ToParent", H3_LOWER, [H3_LOWER, H3_UPPER, RESOLUTION]],
  ["h3ToChildren", null, [H3_LOWER, H3_UPPER, RESOLUTION, POINTER]],
  ["h3ToCenterChild", H3_LOWER, [H3_LOWER, H3_UPPER, RESOLUTION]],
  ["maxH3ToChildrenSize", NUMBER, [H3_LOWER, H3_UPPER, RESOLUTION]],
  ["h3IndexesAreNeighbors", BOOLEAN, [H3_LOWER, H3_UPPER, H3_LOWER, H3_UPPER]],
  ["getH3UnidirectionalEdge", H3_LOWER, [H3_LOWER, H3_UPPER, H3_LOWER, H3_UPPER]],
  ["getOriginH3IndexFromUnidirectionalEdge", H3_LOWER, [H3_LOWER, H3_UPPER]],
  ["getDestinationH3IndexFromUnidirectionalEdge", H3_LOWER, [H3_LOWER, H3_UPPER]],
  ["h3UnidirectionalEdgeIsValid", BOOLEAN, [H3_LOWER, H3_UPPER]],
  ["getH3IndexesFromUnidirectionalEdge", null, [H3_LOWER, H3_UPPER, POINTER]],
  ["getH3UnidirectionalEdgesFromHexagon", null, [H3_LOWER, H3_UPPER, POINTER]],
  ["getH3UnidirectionalEdgeBoundary", null, [H3_LOWER, H3_UPPER, POINTER]],
  ["h3Distance", NUMBER, [H3_LOWER, H3_UPPER, H3_LOWER, H3_UPPER]],
  ["h3Line", NUMBER, [H3_LOWER, H3_UPPER, H3_LOWER, H3_UPPER, POINTER]],
  ["h3LineSize", NUMBER, [H3_LOWER, H3_UPPER, H3_LOWER, H3_UPPER]],
  ["experimentalH3ToLocalIj", NUMBER, [H3_LOWER, H3_UPPER, H3_LOWER, H3_UPPER, POINTER]],
  ["experimentalLocalIjToH3", NUMBER, [H3_LOWER, H3_UPPER, POINTER, POINTER]],
  ["hexAreaM2", NUMBER, [RESOLUTION]],
  ["hexAreaKm2", NUMBER, [RESOLUTION]],
  ["edgeLengthM", NUMBER, [RESOLUTION]],
  ["edgeLengthKm", NUMBER, [RESOLUTION]],
  ["pointDistM", NUMBER, [POINTER, POINTER]],
  ["pointDistKm", NUMBER, [POINTER, POINTER]],
  ["pointDistRads", NUMBER, [POINTER, POINTER]],
  ["cellAreaM2", NUMBER, [H3_LOWER, H3_UPPER]],
  ["cellAreaKm2", NUMBER, [H3_LOWER, H3_UPPER]],
  ["cellAreaRads2", NUMBER, [H3_LOWER, H3_UPPER]],
  ["exactEdgeLengthM", NUMBER, [H3_LOWER, H3_UPPER]],
  ["exactEdgeLengthKm", NUMBER, [H3_LOWER, H3_UPPER]],
  ["exactEdgeLengthRads", NUMBER, [H3_LOWER, H3_UPPER]],
  ["numHexagons", NUMBER, [RESOLUTION]],
  ["getRes0Indexes", null, [POINTER]],
  ["res0IndexCount", NUMBER],
  ["getPentagonIndexes", null, [NUMBER, POINTER]],
  ["pentagonIndexCount", NUMBER]
];
var H3 = {};
BINDINGS.forEach(function bind(def) {
  H3[def[0]] = libh3.cwrap.apply(libh3, def);
});
var BASE_16 = 16;
var SZ_INT = 4;
var SZ_PTR = 4;
var SZ_DBL = 8;
var SZ_H3INDEX = H3.sizeOfH3Index();
var SZ_GEOCOORD = H3.sizeOfGeoCoord();
var SZ_GEOBOUNDARY = H3.sizeOfGeoBoundary();
var SZ_GEOPOLYGON = H3.sizeOfGeoPolygon();
var SZ_GEOFENCE = H3.sizeOfGeofence();
var SZ_LINKED_GEOPOLYGON = H3.sizeOfLinkedGeoPolygon();
var SZ_COORDIJ = H3.sizeOfCoordIJ();
var UNITS = {
  m: "m",
  m2: "m2",
  km: "km",
  km2: "km2",
  rads: "rads",
  rads2: "rads2"
};
function validateRes(res) {
  if (typeof res !== "number" || res < 0 || res > 15 || Math.floor(res) !== res) {
    throw new Error("Invalid resolution: " + res);
  }
}
var INVALID_HEXIDECIMAL_CHAR = /[^0-9a-fA-F]/;
function h3IndexToSplitLong(h3Index) {
  if (Array.isArray(h3Index) && h3Index.length === 2 && Number.isInteger(h3Index[0]) && Number.isInteger(h3Index[1])) {
    return h3Index;
  }
  if (typeof h3Index !== "string" || INVALID_HEXIDECIMAL_CHAR.test(h3Index)) {
    return [0, 0];
  }
  var upper = parseInt(h3Index.substring(0, h3Index.length - 8), BASE_16);
  var lower = parseInt(h3Index.substring(h3Index.length - 8), BASE_16);
  return [lower, upper];
}
function hexFrom32Bit(num) {
  if (num >= 0) {
    return num.toString(BASE_16);
  }
  num = num & 2147483647;
  var tempStr = zeroPad(8, num.toString(BASE_16));
  var topNum = (parseInt(tempStr[0], BASE_16) + 8).toString(BASE_16);
  tempStr = topNum + tempStr.substring(1);
  return tempStr;
}
function splitLongToh3Index(lower, upper) {
  return hexFrom32Bit(upper) + zeroPad(8, hexFrom32Bit(lower));
}
function zeroPad(fullLen, numStr) {
  var numZeroes = fullLen - numStr.length;
  var outStr = "";
  for (var i2 = 0; i2 < numZeroes; i2++) {
    outStr += "0";
  }
  outStr = outStr + numStr;
  return outStr;
}
function readLong(invocation) {
  var upper = libh3.getTempRet0();
  return [invocation, upper];
}
function readH3Index(invocation) {
  var ref = readLong(invocation);
  var lower = ref[0];
  var upper = ref[1];
  return upper ? splitLongToh3Index(lower, upper) : null;
}
function storeH3Index(h3Index, cAddress, offset) {
  libh3.HEAPU32.set(h3IndexToSplitLong(h3Index), cAddress / SZ_INT + 2 * offset);
}
function storeArrayOfHexagons(cAddress, hexagons) {
  var count = hexagons.length;
  for (var i2 = 0; i2 < count; i2++) {
    storeH3Index(hexagons[i2], cAddress, i2);
  }
}
function readSingleCoord(cAddress) {
  return radsToDegs(libh3.getValue(cAddress, "double"));
}
function readGeoCoord(cAddress) {
  return [readSingleCoord(cAddress), readSingleCoord(cAddress + SZ_DBL)];
}
function readGeoCoordGeoJson(cAddress) {
  return [readSingleCoord(cAddress + SZ_DBL), readSingleCoord(cAddress)];
}
function readGeoBoundary(geoBoundary, geoJsonCoords, closedLoop) {
  var numVerts = libh3.getValue(geoBoundary, "i32");
  var vertsPos = geoBoundary + SZ_DBL;
  var out = [];
  var readCoord = geoJsonCoords ? readGeoCoordGeoJson : readGeoCoord;
  for (var i2 = 0; i2 < numVerts * 2; i2 += 2) {
    out.push(readCoord(vertsPos + SZ_DBL * i2));
  }
  if (closedLoop) {
    out.push(out[0]);
  }
  return out;
}
function readMultiPolygon(polygon, formatAsGeoJson) {
  var output = [];
  var readCoord = formatAsGeoJson ? readGeoCoordGeoJson : readGeoCoord;
  var loops;
  var loop;
  var coords;
  var coord;
  while (polygon) {
    output.push(loops = []);
    loop = libh3.getValue(polygon, "i8*");
    while (loop) {
      loops.push(coords = []);
      coord = libh3.getValue(loop, "i8*");
      while (coord) {
        coords.push(readCoord(coord));
        coord = libh3.getValue(coord + SZ_DBL * 2, "i8*");
      }
      if (formatAsGeoJson) {
        coords.push(coords[0]);
      }
      loop = libh3.getValue(loop + SZ_PTR * 2, "i8*");
    }
    polygon = libh3.getValue(polygon + SZ_PTR * 2, "i8*");
  }
  return output;
}
function h3IsPentagon(h3Index) {
  var ref = h3IndexToSplitLong(h3Index);
  var lower = ref[0];
  var upper = ref[1];
  return Boolean(H3.h3IsPentagon(lower, upper));
}
function h3GetResolution(h3Index) {
  var ref = h3IndexToSplitLong(h3Index);
  var lower = ref[0];
  var upper = ref[1];
  if (!H3.h3IsValid(lower, upper)) {
    return -1;
  }
  return H3.h3GetResolution(lower, upper);
}
function geoToH3(lat, lng, res) {
  var latlng = libh3._malloc(SZ_GEOCOORD);
  libh3.HEAPF64.set([lat, lng].map(degsToRads), latlng / SZ_DBL);
  var h3Index = readH3Index(H3.geoToH3(latlng, res));
  libh3._free(latlng);
  return h3Index;
}
function h3ToGeo(h3Index) {
  var latlng = libh3._malloc(SZ_GEOCOORD);
  var ref = h3IndexToSplitLong(h3Index);
  var lower = ref[0];
  var upper = ref[1];
  H3.h3ToGeo(lower, upper, latlng);
  var out = readGeoCoord(latlng);
  libh3._free(latlng);
  return out;
}
function h3ToGeoBoundary(h3Index, formatAsGeoJson) {
  var geoBoundary = libh3._malloc(SZ_GEOBOUNDARY);
  var ref = h3IndexToSplitLong(h3Index);
  var lower = ref[0];
  var upper = ref[1];
  H3.h3ToGeoBoundary(lower, upper, geoBoundary);
  var out = readGeoBoundary(geoBoundary, formatAsGeoJson, formatAsGeoJson);
  libh3._free(geoBoundary);
  return out;
}
function h3SetToMultiPolygon(h3Indexes, formatAsGeoJson) {
  if (!h3Indexes || !h3Indexes.length) {
    return [];
  }
  var indexCount = h3Indexes.length;
  var set = libh3._calloc(indexCount, SZ_H3INDEX);
  storeArrayOfHexagons(set, h3Indexes);
  var polygon = libh3._calloc(SZ_LINKED_GEOPOLYGON);
  var originalPolygon = polygon;
  H3.h3SetToLinkedGeo(set, indexCount, polygon);
  var multiPolygon = readMultiPolygon(polygon, formatAsGeoJson);
  H3.destroyLinkedPolygon(originalPolygon);
  libh3._free(originalPolygon);
  libh3._free(set);
  return multiPolygon;
}
function h3Distance(origin, destination) {
  var ref = h3IndexToSplitLong(origin);
  var oLower = ref[0];
  var oUpper = ref[1];
  var ref$1 = h3IndexToSplitLong(destination);
  var dLower = ref$1[0];
  var dUpper = ref$1[1];
  return H3.h3Distance(oLower, oUpper, dLower, dUpper);
}
function edgeLength(res, unit) {
  validateRes(res);
  switch (unit) {
    case UNITS.m:
      return H3.edgeLengthM(res);
    case UNITS.km:
      return H3.edgeLengthKm(res);
    default:
      throw new Error("Unknown unit: " + unit);
  }
}
function degsToRads(deg) {
  return deg * Math.PI / 180;
}
function radsToDegs(rad) {
  return rad * 180 / Math.PI;
}

// node_modules/@deck.gl/geo-layers/dist/esm/h3-layers/h3-hexagon-layer.js
var UPDATE_THRESHOLD_KM = 10;
function normalizeLongitudes(vertices, refLng) {
  refLng = refLng === void 0 ? vertices[0][0] : refLng;
  for (const pt of vertices) {
    const deltaLng = pt[0] - refLng;
    if (deltaLng > 180) {
      pt[0] -= 360;
    } else if (deltaLng < -180) {
      pt[0] += 360;
    }
  }
}
function scalePolygon(hexId, vertices, factor) {
  const [lat, lng] = h3ToGeo(hexId);
  const actualCount = vertices.length;
  normalizeLongitudes(vertices, lng);
  const vertexCount = vertices[0] === vertices[actualCount - 1] ? actualCount - 1 : actualCount;
  for (let i2 = 0; i2 < vertexCount; i2++) {
    vertices[i2][0] = lerp(lng, vertices[i2][0], factor);
    vertices[i2][1] = lerp(lat, vertices[i2][1], factor);
  }
}
function getHexagonCentroid(getHexagon, object, objectInfo) {
  const hexagonId = getHexagon(object, objectInfo);
  const [lat, lng] = h3ToGeo(hexagonId);
  return [lng, lat];
}
function h3ToPolygon(hexId, coverage = 1) {
  const vertices = h3ToGeoBoundary(hexId, true);
  if (coverage !== 1) {
    scalePolygon(hexId, vertices, coverage);
  } else {
    normalizeLongitudes(vertices);
  }
  return vertices;
}
function flattenPolygon(vertices) {
  const positions = new Float64Array(vertices.length * 2);
  let i2 = 0;
  for (const pt of vertices) {
    positions[i2++] = pt[0];
    positions[i2++] = pt[1];
  }
  return positions;
}
function mergeTriggers(getHexagon, coverage) {
  let trigger;
  if (getHexagon === void 0 || getHexagon === null) {
    trigger = coverage;
  } else if (typeof getHexagon === "object") {
    trigger = {
      ...getHexagon,
      coverage
    };
  } else {
    trigger = {
      getHexagon,
      coverage
    };
  }
  return trigger;
}
var defaultProps8 = {
  ...PolygonLayer.defaultProps,
  highPrecision: "auto",
  coverage: {
    type: "number",
    min: 0,
    max: 1,
    value: 1
  },
  centerHexagon: null,
  getHexagon: {
    type: "accessor",
    value: (x2) => x2.hexagon
  },
  extruded: true
};
var H3HexagonLayer = class _H3HexagonLayer extends CompositeLayer {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "state", void 0);
  }
  initializeState() {
    _H3HexagonLayer._checkH3Lib();
    this.state = {
      edgeLengthKM: 0,
      resolution: -1
    };
  }
  shouldUpdateState({
    changeFlags
  }) {
    return this._shouldUseHighPrecision() ? changeFlags.propsOrDataChanged : changeFlags.somethingChanged;
  }
  updateState({
    props,
    changeFlags
  }) {
    if (props.highPrecision !== true && (changeFlags.dataChanged || changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getHexagon)) {
      const dataProps = this._calculateH3DataProps();
      this.setState(dataProps);
    }
    this._updateVertices(this.context.viewport);
  }
  _calculateH3DataProps() {
    let resolution = -1;
    let hasPentagon = false;
    let hasMultipleRes = false;
    const {
      iterable,
      objectInfo
    } = createIterable(this.props.data);
    for (const object of iterable) {
      objectInfo.index++;
      const hexId = this.props.getHexagon(object, objectInfo);
      const hexResolution = h3GetResolution(hexId);
      if (resolution < 0) {
        resolution = hexResolution;
        if (!this.props.highPrecision)
          break;
      } else if (resolution !== hexResolution) {
        hasMultipleRes = true;
        break;
      }
      if (h3IsPentagon(hexId)) {
        hasPentagon = true;
        break;
      }
    }
    return {
      resolution,
      edgeLengthKM: resolution >= 0 ? edgeLength(resolution, "km") : 0,
      hasMultipleRes,
      hasPentagon
    };
  }
  _shouldUseHighPrecision() {
    if (this.props.highPrecision === "auto") {
      const {
        resolution,
        hasPentagon,
        hasMultipleRes
      } = this.state;
      const {
        viewport
      } = this.context;
      return Boolean(viewport === null || viewport === void 0 ? void 0 : viewport.resolution) || hasMultipleRes || hasPentagon || resolution >= 0 && resolution <= 5;
    }
    return this.props.highPrecision;
  }
  _updateVertices(viewport) {
    if (this._shouldUseHighPrecision()) {
      return;
    }
    const {
      resolution,
      edgeLengthKM,
      centerHex
    } = this.state;
    if (resolution < 0) {
      return;
    }
    const hex = this.props.centerHexagon || geoToH3(viewport.latitude, viewport.longitude, resolution);
    if (centerHex === hex) {
      return;
    }
    if (centerHex) {
      const distance = h3Distance(centerHex, hex);
      if (distance >= 0 && distance * edgeLengthKM < UPDATE_THRESHOLD_KM) {
        return;
      }
    }
    const {
      unitsPerMeter
    } = viewport.distanceScales;
    let vertices = h3ToPolygon(hex);
    const [centerLat, centerLng] = h3ToGeo(hex);
    const [centerX, centerY] = viewport.projectFlat([centerLng, centerLat]);
    vertices = vertices.map((p) => {
      const worldPosition = viewport.projectFlat(p);
      return [(worldPosition[0] - centerX) / unitsPerMeter[0], (worldPosition[1] - centerY) / unitsPerMeter[1]];
    });
    this.setState({
      centerHex: hex,
      vertices
    });
  }
  renderLayers() {
    return this._shouldUseHighPrecision() ? this._renderPolygonLayer() : this._renderColumnLayer();
  }
  _getForwardProps() {
    const {
      elevationScale,
      material,
      coverage,
      extruded,
      wireframe,
      stroked,
      filled,
      lineWidthUnits,
      lineWidthScale,
      lineWidthMinPixels,
      lineWidthMaxPixels,
      getFillColor,
      getElevation,
      getLineColor,
      getLineWidth,
      transitions,
      updateTriggers
    } = this.props;
    return {
      elevationScale,
      extruded,
      coverage,
      wireframe,
      stroked,
      filled,
      lineWidthUnits,
      lineWidthScale,
      lineWidthMinPixels,
      lineWidthMaxPixels,
      material,
      getElevation,
      getFillColor,
      getLineColor,
      getLineWidth,
      transitions,
      updateTriggers: {
        getFillColor: updateTriggers.getFillColor,
        getElevation: updateTriggers.getElevation,
        getLineColor: updateTriggers.getLineColor,
        getLineWidth: updateTriggers.getLineWidth
      }
    };
  }
  _renderPolygonLayer() {
    const {
      data,
      getHexagon,
      updateTriggers,
      coverage
    } = this.props;
    const SubLayerClass = this.getSubLayerClass("hexagon-cell-hifi", PolygonLayer);
    const forwardProps = this._getForwardProps();
    forwardProps.updateTriggers.getPolygon = mergeTriggers(updateTriggers.getHexagon, coverage);
    return new SubLayerClass(forwardProps, this.getSubLayerProps({
      id: "hexagon-cell-hifi",
      updateTriggers: forwardProps.updateTriggers
    }), {
      data,
      _normalize: false,
      _windingOrder: "CCW",
      positionFormat: "XY",
      getPolygon: (object, objectInfo) => {
        const hexagonId = getHexagon(object, objectInfo);
        return flattenPolygon(h3ToPolygon(hexagonId, coverage));
      }
    });
  }
  _renderColumnLayer() {
    const {
      data,
      getHexagon,
      updateTriggers
    } = this.props;
    const SubLayerClass = this.getSubLayerClass("hexagon-cell", ColumnLayer);
    const forwardProps = this._getForwardProps();
    forwardProps.updateTriggers.getPosition = updateTriggers.getHexagon;
    return new SubLayerClass(forwardProps, this.getSubLayerProps({
      id: "hexagon-cell",
      flatShading: true,
      updateTriggers: forwardProps.updateTriggers
    }), {
      data,
      diskResolution: 6,
      radius: 1,
      vertices: this.state.vertices,
      getPosition: getHexagonCentroid.bind(null, getHexagon)
    });
  }
};
_defineProperty(H3HexagonLayer, "defaultProps", defaultProps8);
_defineProperty(H3HexagonLayer, "layerName", "H3HexagonLayer");
_defineProperty(H3HexagonLayer, "_checkH3Lib", () => {
});

// node_modules/@deck.gl/geo-layers/dist/esm/h3-layers/h3-cluster-layer.js
var defaultProps9 = {
  getHexagons: {
    type: "accessor",
    value: (d) => d.hexagons
  }
};
var H3ClusterLayer = class extends GeoCellLayer {
  initializeState() {
    H3HexagonLayer._checkH3Lib();
  }
  updateState({
    props,
    changeFlags
  }) {
    if (changeFlags.dataChanged || changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getHexagons) {
      const {
        data,
        getHexagons
      } = props;
      const polygons = [];
      const {
        iterable,
        objectInfo
      } = createIterable(data);
      for (const object of iterable) {
        objectInfo.index++;
        const hexagons = getHexagons(object, objectInfo);
        const multiPolygon = h3SetToMultiPolygon(hexagons, true);
        for (const polygon of multiPolygon) {
          polygons.push(this.getSubLayerRow({
            polygon
          }, object, objectInfo.index));
        }
      }
      this.setState({
        polygons
      });
    }
  }
  indexToBounds() {
    const {
      getElevation,
      getFillColor,
      getLineColor,
      getLineWidth
    } = this.props;
    return {
      data: this.state.polygons,
      getPolygon: (d) => d.polygon,
      getElevation: this.getSubLayerAccessor(getElevation),
      getFillColor: this.getSubLayerAccessor(getFillColor),
      getLineColor: this.getSubLayerAccessor(getLineColor),
      getLineWidth: this.getSubLayerAccessor(getLineWidth)
    };
  }
};
_defineProperty(H3ClusterLayer, "layerName", "H3ClusterLayer");
_defineProperty(H3ClusterLayer, "defaultProps", defaultProps9);

// node_modules/@deck.gl/mesh-layers/dist/esm/utils/matrix.js
var RADIAN_PER_DEGREE = Math.PI / 180;
var modelMatrix = new Float32Array(16);
var valueArray = new Float32Array(12);
function calculateTransformMatrix(targetMatrix, orientation, scale) {
  const pitch = orientation[0] * RADIAN_PER_DEGREE;
  const yaw = orientation[1] * RADIAN_PER_DEGREE;
  const roll = orientation[2] * RADIAN_PER_DEGREE;
  const sr = Math.sin(roll);
  const sp = Math.sin(pitch);
  const sw = Math.sin(yaw);
  const cr = Math.cos(roll);
  const cp = Math.cos(pitch);
  const cw = Math.cos(yaw);
  const scx = scale[0];
  const scy = scale[1];
  const scz = scale[2];
  targetMatrix[0] = scx * cw * cp;
  targetMatrix[1] = scx * sw * cp;
  targetMatrix[2] = scx * -sp;
  targetMatrix[3] = scy * (-sw * cr + cw * sp * sr);
  targetMatrix[4] = scy * (cw * cr + sw * sp * sr);
  targetMatrix[5] = scy * cp * sr;
  targetMatrix[6] = scz * (sw * sr + cw * sp * cr);
  targetMatrix[7] = scz * (-cw * sr + sw * sp * cr);
  targetMatrix[8] = scz * cp * cr;
}
function getExtendedMat3FromMat4(mat4) {
  mat4[0] = mat4[0];
  mat4[1] = mat4[1];
  mat4[2] = mat4[2];
  mat4[3] = mat4[4];
  mat4[4] = mat4[5];
  mat4[5] = mat4[6];
  mat4[6] = mat4[8];
  mat4[7] = mat4[9];
  mat4[8] = mat4[10];
  mat4[9] = mat4[12];
  mat4[10] = mat4[13];
  mat4[11] = mat4[14];
  return mat4.subarray(0, 12);
}
var MATRIX_ATTRIBUTES = {
  size: 12,
  accessor: ["getOrientation", "getScale", "getTranslation", "getTransformMatrix"],
  shaderAttributes: {
    instanceModelMatrix__LOCATION_0: {
      size: 3,
      elementOffset: 0
    },
    instanceModelMatrix__LOCATION_1: {
      size: 3,
      elementOffset: 3
    },
    instanceModelMatrix__LOCATION_2: {
      size: 3,
      elementOffset: 6
    },
    instanceTranslation: {
      size: 3,
      elementOffset: 9
    }
  },
  update(attribute, {
    startRow,
    endRow
  }) {
    const {
      data,
      getOrientation,
      getScale: getScale2,
      getTranslation,
      getTransformMatrix
    } = this.props;
    const arrayMatrix = Array.isArray(getTransformMatrix);
    const constantMatrix = arrayMatrix && getTransformMatrix.length === 16;
    const constantScale = Array.isArray(getScale2);
    const constantOrientation = Array.isArray(getOrientation);
    const constantTranslation = Array.isArray(getTranslation);
    const hasMatrix = constantMatrix || !arrayMatrix && Boolean(getTransformMatrix(data[0]));
    if (hasMatrix) {
      attribute.constant = constantMatrix;
    } else {
      attribute.constant = constantOrientation && constantScale && constantTranslation;
    }
    const instanceModelMatrixData = attribute.value;
    if (attribute.constant) {
      let matrix;
      if (hasMatrix) {
        modelMatrix.set(getTransformMatrix);
        matrix = getExtendedMat3FromMat4(modelMatrix);
      } else {
        matrix = valueArray;
        const orientation = getOrientation;
        const scale = getScale2;
        calculateTransformMatrix(matrix, orientation, scale);
        matrix.set(getTranslation, 9);
      }
      attribute.value = new Float32Array(matrix);
    } else {
      let i2 = startRow * attribute.size;
      const {
        iterable,
        objectInfo
      } = createIterable(data, startRow, endRow);
      for (const object of iterable) {
        objectInfo.index++;
        let matrix;
        if (hasMatrix) {
          modelMatrix.set(constantMatrix ? getTransformMatrix : getTransformMatrix(object, objectInfo));
          matrix = getExtendedMat3FromMat4(modelMatrix);
        } else {
          matrix = valueArray;
          const orientation = constantOrientation ? getOrientation : getOrientation(object, objectInfo);
          const scale = constantScale ? getScale2 : getScale2(object, objectInfo);
          calculateTransformMatrix(matrix, orientation, scale);
          matrix.set(constantTranslation ? getTranslation : getTranslation(object, objectInfo), 9);
        }
        instanceModelMatrixData[i2++] = matrix[0];
        instanceModelMatrixData[i2++] = matrix[1];
        instanceModelMatrixData[i2++] = matrix[2];
        instanceModelMatrixData[i2++] = matrix[3];
        instanceModelMatrixData[i2++] = matrix[4];
        instanceModelMatrixData[i2++] = matrix[5];
        instanceModelMatrixData[i2++] = matrix[6];
        instanceModelMatrixData[i2++] = matrix[7];
        instanceModelMatrixData[i2++] = matrix[8];
        instanceModelMatrixData[i2++] = matrix[9];
        instanceModelMatrixData[i2++] = matrix[10];
        instanceModelMatrixData[i2++] = matrix[11];
      }
    }
  }
};
function shouldComposeModelMatrix(viewport, coordinateSystem) {
  return coordinateSystem === COORDINATE_SYSTEM.CARTESIAN || coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS || coordinateSystem === COORDINATE_SYSTEM.DEFAULT && !viewport.isGeospatial;
}

// node_modules/@deck.gl/mesh-layers/dist/esm/simple-mesh-layer/simple-mesh-layer-vertex.glsl.js
var simple_mesh_layer_vertex_glsl_default = "#version 300 es\n#define SHADER_NAME simple-mesh-layer-vs\nuniform float sizeScale;\nuniform bool composeModelMatrix;\nin vec3 positions;\nin vec3 normals;\nin vec3 colors;\nin vec2 texCoords;\nin vec3 instancePositions;\nin vec3 instancePositions64Low;\nin vec4 instanceColors;\nin vec3 instancePickingColors;\nin mat3 instanceModelMatrix;\nin vec3 instanceTranslation;\nout vec2 vTexCoord;\nout vec3 cameraPosition;\nout vec3 normals_commonspace;\nout vec4 position_commonspace;\nout vec4 vColor;\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = texCoords;\n  geometry.pickingColor = instancePickingColors;\n\n  vTexCoord = texCoords;\n  cameraPosition = project_uCameraPosition;\n  vColor = vec4(colors * instanceColors.rgb, instanceColors.a);\n\n  vec3 pos = (instanceModelMatrix * positions) * sizeScale + instanceTranslation;\n\n  if (composeModelMatrix) {\n    DECKGL_FILTER_SIZE(pos, geometry);\n    normals_commonspace = project_normal(instanceModelMatrix * normals);\n    geometry.worldPosition += pos;\n    gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), position_commonspace);\n    geometry.position = position_commonspace;\n  }\n  else {\n    pos = project_size(pos);\n    DECKGL_FILTER_SIZE(pos, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, position_commonspace);\n    geometry.position = position_commonspace;\n    normals_commonspace = project_normal(instanceModelMatrix * normals);\n  }\n\n  geometry.normal = normals_commonspace;\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";

// node_modules/@deck.gl/mesh-layers/dist/esm/simple-mesh-layer/simple-mesh-layer-fragment.glsl.js
var simple_mesh_layer_fragment_glsl_default = "#version 300 es\n#define SHADER_NAME simple-mesh-layer-fs\n\nprecision highp float;\n\nuniform bool hasTexture;\nuniform sampler2D sampler;\nuniform bool flatShading;\nuniform float opacity;\n\nin vec2 vTexCoord;\nin vec3 cameraPosition;\nin vec3 normals_commonspace;\nin vec4 position_commonspace;\nin vec4 vColor;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  geometry.uv = vTexCoord;\n\n  vec3 normal;\n  if (flatShading) {\n#ifdef DERIVATIVES_AVAILABLE\n    normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));\n#else\n    normal = vec3(0.0, 0.0, 1.0);\n#endif\n  } else {\n    normal = normals_commonspace;\n  }\n\n  vec4 color = hasTexture ? texture(sampler, vTexCoord) : vColor;\n  DECKGL_FILTER_COLOR(color, geometry);\n\n  vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);\n  fragColor = vec4(lightColor, color.a * opacity);\n}\n";

// node_modules/@deck.gl/mesh-layers/dist/esm/simple-mesh-layer/simple-mesh-layer.js
function validateGeometryAttributes(attributes, useMeshColors) {
  const hasColorAttribute = attributes.COLOR_0 || attributes.colors;
  const useColorAttribute = hasColorAttribute && useMeshColors;
  if (!useColorAttribute) {
    attributes.colors = {
      constant: true,
      value: new Float32Array([1, 1, 1])
    };
  }
  log_default.assert(attributes.positions || attributes.POSITION, 'no "postions" or "POSITION" attribute in mesh');
}
function getGeometry(data, useMeshColors) {
  if (data.attributes) {
    validateGeometryAttributes(data.attributes, useMeshColors);
    if (data instanceof Geometry) {
      return data;
    } else {
      return new Geometry(data);
    }
  } else if (data.positions || data.POSITION) {
    validateGeometryAttributes(data, useMeshColors);
    return new Geometry({
      attributes: data
    });
  }
  throw Error("Invalid mesh");
}
var DEFAULT_COLOR = [0, 0, 0, 255];
var defaultProps10 = {
  mesh: {
    type: "object",
    value: null,
    async: true
  },
  texture: {
    type: "image",
    value: null,
    async: true
  },
  sizeScale: {
    type: "number",
    value: 1,
    min: 0
  },
  _useMeshColors: {
    type: "boolean",
    value: false
  },
  _instanced: true,
  wireframe: false,
  material: true,
  getPosition: {
    type: "accessor",
    value: (x2) => x2.position
  },
  getColor: {
    type: "accessor",
    value: DEFAULT_COLOR
  },
  getOrientation: {
    type: "accessor",
    value: [0, 0, 0]
  },
  getScale: {
    type: "accessor",
    value: [1, 1, 1]
  },
  getTranslation: {
    type: "accessor",
    value: [0, 0, 0]
  },
  getTransformMatrix: {
    type: "accessor",
    value: []
  },
  textureParameters: {
    type: "object",
    ignore: true
  }
};
var SimpleMeshLayer = class extends Layer {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "state", void 0);
  }
  getShaders() {
    const transpileToGLSL100 = !isWebGL2(this.context.gl);
    const defines = {};
    if (hasFeature(this.context.gl, FEATURES.GLSL_DERIVATIVES)) {
      defines.DERIVATIVES_AVAILABLE = 1;
    }
    return super.getShaders({
      vs: simple_mesh_layer_vertex_glsl_default,
      fs: simple_mesh_layer_fragment_glsl_default,
      modules: [project32_default, phongLighting, picking_default],
      transpileToGLSL100,
      defines
    });
  }
  getBounds() {
    var _mesh$header;
    if (this.props._instanced) {
      return super.getBounds();
    }
    let result = this.state.positionBounds;
    if (result) {
      return result;
    }
    const {
      mesh
    } = this.props;
    if (!mesh) {
      return null;
    }
    result = (_mesh$header = mesh.header) === null || _mesh$header === void 0 ? void 0 : _mesh$header.boundingBox;
    if (!result) {
      const {
        attributes
      } = getGeometry(mesh, this.props._useMeshColors);
      attributes.POSITION = attributes.POSITION || attributes.positions;
      result = getMeshBoundingBox(attributes);
    }
    this.state.positionBounds = result;
    return result;
  }
  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instancePositions: {
        transition: true,
        type: 5130,
        fp64: this.use64bitPositions(),
        size: 3,
        accessor: "getPosition"
      },
      instanceColors: {
        type: 5121,
        transition: true,
        size: this.props.colorFormat.length,
        normalized: true,
        accessor: "getColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceModelMatrix: MATRIX_ATTRIBUTES
    });
    this.setState({
      emptyTexture: new Texture2D(this.context.gl, {
        data: new Uint8Array(4),
        width: 1,
        height: 1
      })
    });
  }
  updateState(params) {
    super.updateState(params);
    const {
      props,
      oldProps,
      changeFlags
    } = params;
    if (props.mesh !== oldProps.mesh || changeFlags.extensionsChanged) {
      var _this$state$model;
      this.state.positionBounds = null;
      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
      if (props.mesh) {
        this.state.model = this.getModel(props.mesh);
        const attributes = props.mesh.attributes || props.mesh;
        this.setState({
          hasNormals: Boolean(attributes.NORMAL || attributes.normals)
        });
      }
      this.getAttributeManager().invalidateAll();
    }
    if (props.texture !== oldProps.texture) {
      this.setTexture(props.texture);
    }
    if (this.state.model) {
      this.state.model.setDrawMode(this.props.wireframe ? 3 : 4);
    }
  }
  finalizeState(context) {
    super.finalizeState(context);
    this.state.emptyTexture.delete();
  }
  draw({
    uniforms
  }) {
    if (!this.state.model) {
      return;
    }
    const {
      viewport
    } = this.context;
    const {
      sizeScale,
      coordinateSystem,
      _instanced
    } = this.props;
    this.state.model.setUniforms(uniforms).setUniforms({
      sizeScale,
      composeModelMatrix: !_instanced || shouldComposeModelMatrix(viewport, coordinateSystem),
      flatShading: !this.state.hasNormals
    }).draw();
  }
  getModel(mesh) {
    const model = new Model(this.context.gl, {
      ...this.getShaders(),
      id: this.props.id,
      geometry: getGeometry(mesh, this.props._useMeshColors),
      isInstanced: true
    });
    const {
      texture
    } = this.props;
    const {
      emptyTexture
    } = this.state;
    model.setUniforms({
      sampler: texture || emptyTexture,
      hasTexture: Boolean(texture)
    });
    return model;
  }
  setTexture(texture) {
    const {
      emptyTexture,
      model
    } = this.state;
    if (model) {
      model.setUniforms({
        sampler: texture || emptyTexture,
        hasTexture: Boolean(texture)
      });
    }
  }
};
_defineProperty(SimpleMeshLayer, "defaultProps", defaultProps10);
_defineProperty(SimpleMeshLayer, "layerName", "SimpleMeshLayer");

// node_modules/@luma.gl/experimental/dist/esm/scenegraph/scenegraph-node.js
var ScenegraphNode = class {
  constructor() {
    let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      id
    } = props;
    this.id = id || uid(this.constructor.name);
    this.display = true;
    this.position = new Vector3();
    this.rotation = new Vector3();
    this.scale = new Vector3(1, 1, 1);
    this.matrix = new Matrix4();
    this.userData = {};
    this.props = {};
    this._setScenegraphNodeProps(props);
  }
  delete() {
  }
  setProps(props) {
    this._setScenegraphNodeProps(props);
    return this;
  }
  toString() {
    return "{type: ScenegraphNode, id: ".concat(this.id, ")}");
  }
  getBounds() {
    return null;
  }
  setPosition(position) {
    assert(position.length === 3, "setPosition requires vector argument");
    this.position = position;
    return this;
  }
  setRotation(rotation) {
    assert(rotation.length === 3, "setRotation requires vector argument");
    this.rotation = rotation;
    return this;
  }
  setScale(scale) {
    assert(scale.length === 3, "setScale requires vector argument");
    this.scale = scale;
    return this;
  }
  setMatrix(matrix) {
    let copyMatrix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    if (copyMatrix) {
      this.matrix.copy(matrix);
    } else {
      this.matrix = matrix;
    }
  }
  setMatrixComponents(_ref) {
    let {
      position,
      rotation,
      scale,
      update = true
    } = _ref;
    if (position) {
      this.setPosition(position);
    }
    if (rotation) {
      this.setRotation(rotation);
    }
    if (scale) {
      this.setScale(scale);
    }
    if (update) {
      this.updateMatrix();
    }
    return this;
  }
  updateMatrix() {
    const pos = this.position;
    const rot = this.rotation;
    const scale = this.scale;
    this.matrix.identity();
    this.matrix.translate(pos);
    this.matrix.rotateXYZ(rot);
    this.matrix.scale(scale);
    return this;
  }
  update() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      position,
      rotation,
      scale
    } = options;
    if (position) {
      this.setPosition(position);
    }
    if (rotation) {
      this.setRotation(rotation);
    }
    if (scale) {
      this.setScale(scale);
    }
    this.updateMatrix();
    return this;
  }
  getCoordinateUniforms(viewMatrix, modelMatrix2) {
    assert(viewMatrix);
    modelMatrix2 = modelMatrix2 || this.matrix;
    const worldMatrix = new Matrix4(viewMatrix).multiplyRight(modelMatrix2);
    const worldInverse = worldMatrix.invert();
    const worldInverseTranspose = worldInverse.transpose();
    return {
      viewMatrix,
      modelMatrix: modelMatrix2,
      objectMatrix: modelMatrix2,
      worldMatrix,
      worldInverseMatrix: worldInverse,
      worldInverseTransposeMatrix: worldInverseTranspose
    };
  }
  _setScenegraphNodeProps(props) {
    if ("display" in props) {
      this.display = props.display;
    }
    if ("position" in props) {
      this.setPosition(props.position);
    }
    if ("rotation" in props) {
      this.setRotation(props.rotation);
    }
    if ("scale" in props) {
      this.setScale(props.scale);
    }
    if ("matrix" in props) {
      this.setMatrix(props.matrix);
    }
    Object.assign(this.props, props);
  }
};

// node_modules/@luma.gl/experimental/dist/esm/scenegraph/group-node.js
var GroupNode = class _GroupNode extends ScenegraphNode {
  constructor() {
    let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    props = Array.isArray(props) ? {
      children: props
    } : props;
    const {
      children = []
    } = props;
    log.assert(children.every((child) => child instanceof ScenegraphNode), "every child must an instance of ScenegraphNode");
    super(props);
    this.children = children;
  }
  add() {
    for (var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++) {
      children[_key] = arguments[_key];
    }
    for (const child of children) {
      if (Array.isArray(child)) {
        this.add(...child);
      } else {
        this.children.push(child);
      }
    }
    return this;
  }
  remove(child) {
    const children = this.children;
    const indexOf = children.indexOf(child);
    if (indexOf > -1) {
      children.splice(indexOf, 1);
    }
    return this;
  }
  removeAll() {
    this.children = [];
    return this;
  }
  delete() {
    this.children.forEach((child) => child.delete());
    this.removeAll();
    super.delete();
  }
  getBounds() {
    const result = [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]];
    this.traverse((node, _ref) => {
      let {
        worldMatrix
      } = _ref;
      const bounds = node.getBounds();
      if (!bounds) {
        return;
      }
      const [min, max] = bounds;
      const center = new Vector3(min).add(max).divide([2, 2, 2]);
      worldMatrix.transformAsPoint(center, center);
      const halfSize = new Vector3(max).subtract(min).divide([2, 2, 2]);
      worldMatrix.transformAsVector(halfSize, halfSize);
      for (let v = 0; v < 8; v++) {
        const position = new Vector3(v & 1 ? -1 : 1, v & 2 ? -1 : 1, v & 4 ? -1 : 1).multiply(halfSize).add(center);
        for (let i2 = 0; i2 < 3; i2++) {
          result[0][i2] = Math.min(result[0][i2], position[i2]);
          result[1][i2] = Math.max(result[1][i2], position[i2]);
        }
      }
    });
    if (!Number.isFinite(result[0][0])) {
      return null;
    }
    return result;
  }
  traverse(visitor) {
    let {
      worldMatrix = new Matrix4()
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const modelMatrix2 = new Matrix4(worldMatrix).multiplyRight(this.matrix);
    for (const child of this.children) {
      if (child instanceof _GroupNode) {
        child.traverse(visitor, {
          worldMatrix: modelMatrix2
        });
      } else {
        visitor(child, {
          worldMatrix: modelMatrix2
        });
      }
    }
  }
};

// node_modules/@luma.gl/experimental/dist/esm/gltf/gltf-animator.js
var ATTRIBUTE_TYPE_TO_COMPONENTS = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
var ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
function accessorToJsArray(accessor) {
  if (!accessor._animation) {
    const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];
    const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];
    const length2 = components * accessor.count;
    const {
      buffer,
      byteOffset
    } = accessor.bufferView.data;
    const array = new ArrayType(buffer, byteOffset + (accessor.byteOffset || 0), length2);
    if (components === 1) {
      accessor._animation = Array.from(array);
    } else {
      const slicedArray = [];
      for (let i2 = 0; i2 < array.length; i2 += components) {
        slicedArray.push(Array.from(array.slice(i2, i2 + components)));
      }
      accessor._animation = slicedArray;
    }
  }
  return accessor._animation;
}
var helperMatrix = new Matrix4();
function applyTranslationRotationScale(gltfNode, node) {
  node.matrix.identity();
  if (gltfNode.translation) {
    node.matrix.translate(gltfNode.translation);
  }
  if (gltfNode.rotation) {
    const rotationMatrix = helperMatrix.fromQuaternion(gltfNode.rotation);
    node.matrix.multiplyRight(rotationMatrix);
  }
  if (gltfNode.scale) {
    node.matrix.scale(gltfNode.scale);
  }
}
var quaternion = new Quaternion();
function linearInterpolate(target, path, start, stop, ratio) {
  if (path === "rotation") {
    quaternion.slerp({
      start,
      target: stop,
      ratio
    });
    for (let i2 = 0; i2 < quaternion.length; i2++) {
      target[path][i2] = quaternion[i2];
    }
  } else {
    for (let i2 = 0; i2 < start.length; i2++) {
      target[path][i2] = ratio * stop[i2] + (1 - ratio) * start[i2];
    }
  }
}
function cubicsplineInterpolate(target, path, _ref) {
  let {
    p0,
    outTangent0,
    inTangent1,
    p1,
    tDiff,
    ratio: t
  } = _ref;
  for (let i2 = 0; i2 < target[path].length; i2++) {
    const m0 = outTangent0[i2] * tDiff;
    const m1 = inTangent1[i2] * tDiff;
    target[path][i2] = (2 * Math.pow(t, 3) - 3 * Math.pow(t, 2) + 1) * p0[i2] + (Math.pow(t, 3) - 2 * Math.pow(t, 2) + t) * m0 + (-2 * Math.pow(t, 3) + 3 * Math.pow(t, 2)) * p1[i2] + (Math.pow(t, 3) - Math.pow(t, 2)) * m1;
  }
}
function stepInterpolate(target, path, value) {
  for (let i2 = 0; i2 < value.length; i2++) {
    target[path][i2] = value[i2];
  }
}
function interpolate(time, _ref2, target, path) {
  let {
    input,
    interpolation,
    output
  } = _ref2;
  const maxTime = input[input.length - 1];
  const animationTime = time % maxTime;
  const nextIndex = input.findIndex((t) => t >= animationTime);
  const previousIndex = Math.max(0, nextIndex - 1);
  if (!Array.isArray(target[path])) {
    switch (path) {
      case "translation":
        target[path] = [0, 0, 0];
        break;
      case "rotation":
        target[path] = [0, 0, 0, 1];
        break;
      case "scale":
        target[path] = [1, 1, 1];
        break;
      default:
        log.warn("Bad animation path ".concat(path))();
    }
  }
  assert(target[path].length === output[previousIndex].length);
  const previousTime = input[previousIndex];
  const nextTime = input[nextIndex];
  switch (interpolation) {
    case "STEP":
      stepInterpolate(target, path, output[previousIndex]);
      break;
    case "LINEAR":
      if (nextTime > previousTime) {
        const ratio = (animationTime - previousTime) / (nextTime - previousTime);
        linearInterpolate(target, path, output[previousIndex], output[nextIndex], ratio);
      }
      break;
    case "CUBICSPLINE":
      if (nextTime > previousTime) {
        const ratio = (animationTime - previousTime) / (nextTime - previousTime);
        const tDiff = nextTime - previousTime;
        const p0 = output[3 * previousIndex + 1];
        const outTangent0 = output[3 * previousIndex + 2];
        const inTangent1 = output[3 * nextIndex + 0];
        const p1 = output[3 * nextIndex + 1];
        cubicsplineInterpolate(target, path, {
          p0,
          outTangent0,
          inTangent1,
          p1,
          tDiff,
          ratio
        });
      }
      break;
    default:
      log.warn("Interpolation ".concat(interpolation, " not supported"))();
      break;
  }
}
var GLTFAnimation = class {
  constructor(props) {
    this.startTime = 0;
    this.playing = true;
    this.speed = 1;
    this.channels = [];
    Object.assign(this, props);
  }
  animate(timeMs) {
    if (!this.playing) {
      return;
    }
    const absTime = timeMs / 1e3;
    const time = (absTime - this.startTime) * this.speed;
    this.channels.forEach((_ref3) => {
      let {
        sampler,
        target,
        path
      } = _ref3;
      interpolate(time, sampler, target, path);
      applyTranslationRotationScale(target, target._node);
    });
  }
};
var GLTFAnimator = class {
  constructor(gltf) {
    this.animations = gltf.animations.map((animation, index) => {
      const name = animation.name || "Animation-".concat(index);
      const samplers = animation.samplers.map((_ref4) => {
        let {
          input,
          interpolation = "LINEAR",
          output
        } = _ref4;
        return {
          input: accessorToJsArray(gltf.accessors[input]),
          interpolation,
          output: accessorToJsArray(gltf.accessors[output])
        };
      });
      const channels = animation.channels.map((_ref5) => {
        let {
          sampler,
          target
        } = _ref5;
        return {
          sampler: samplers[sampler],
          target: gltf.nodes[target.node],
          path: target.path
        };
      });
      return new GLTFAnimation({
        name,
        channels
      });
    });
  }
  animate(time) {
    this.setTime(time);
  }
  setTime(time) {
    this.animations.forEach((animation) => animation.animate(time));
  }
  getAnimations() {
    return this.animations;
  }
};

// node_modules/@luma.gl/experimental/dist/esm/scenegraph/model-node.js
var ModelNode = class extends ScenegraphNode {
  constructor(gl) {
    let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(props);
    this.onBeforeRender = null;
    this.AfterRender = null;
    if (gl instanceof Model) {
      this.model = gl;
      this._setModelNodeProps(props);
    } else {
      this.model = new Model(gl, props);
    }
    this.bounds = null;
    this.managedResources = props.managedResources || [];
  }
  setProps(props) {
    super.setProps(props);
    this._setModelNodeProps(props);
    return this;
  }
  getBounds() {
    return this.bounds;
  }
  delete() {
    if (this.model) {
      this.model.delete();
      this.model = null;
    }
    this.managedResources.forEach((resource) => resource.delete());
    this.managedResources = [];
  }
  draw() {
    return this.model.draw(...arguments);
  }
  setUniforms() {
    this.model.setUniforms(...arguments);
    return this;
  }
  setAttributes() {
    this.model.setAttributes(...arguments);
    return this;
  }
  updateModuleSettings() {
    this.model.updateModuleSettings(...arguments);
    return this;
  }
  _setModelNodeProps(props) {
    this.model.setProps(props);
  }
};

// node_modules/@luma.gl/experimental/dist/esm/gltf/gltf-material-parser.js
var GLTFMaterialParser = class {
  constructor(gl, _ref) {
    let {
      attributes,
      material,
      pbrDebug,
      imageBasedLightingEnvironment,
      lights,
      useTangents
    } = _ref;
    this.gl = gl;
    this.defines = {
      MANUAL_SRGB: 1,
      SRGB_FAST_APPROXIMATION: 1
    };
    if (hasFeature(gl, FEATURES.GLSL_TEXTURE_LOD)) {
      this.defines.USE_TEX_LOD = 1;
    }
    this.uniforms = {
      u_Camera: [0, 0, 0],
      u_MetallicRoughnessValues: [1, 1]
    };
    this.parameters = {};
    this.generatedTextures = [];
    if (imageBasedLightingEnvironment) {
      this.uniforms.u_DiffuseEnvSampler = imageBasedLightingEnvironment.getDiffuseEnvSampler();
      this.uniforms.u_SpecularEnvSampler = imageBasedLightingEnvironment.getSpecularEnvSampler();
      this.uniforms.u_brdfLUT = imageBasedLightingEnvironment.getBrdfTexture();
      this.uniforms.u_ScaleIBLAmbient = [1, 1];
    }
    if (pbrDebug) {
      this.uniforms.u_ScaleDiffBaseMR = [0, 0, 0, 0];
      this.uniforms.u_ScaleFGDSpec = [0, 0, 0, 0];
    }
    this.defineIfPresent(attributes.NORMAL, "HAS_NORMALS");
    this.defineIfPresent(attributes.TANGENT && useTangents, "HAS_TANGENTS");
    this.defineIfPresent(attributes.TEXCOORD_0, "HAS_UV");
    this.defineIfPresent(imageBasedLightingEnvironment, "USE_IBL");
    this.defineIfPresent(lights, "USE_LIGHTS");
    this.defineIfPresent(pbrDebug, "PBR_DEBUG");
    if (material) {
      this.parseMaterial(material);
    }
  }
  defineIfPresent(value, name) {
    if (value) {
      this.defines[name] = 1;
    }
  }
  parseTexture(gltfTexture, name) {
    let define2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
    const parameters2 = gltfTexture.texture && gltfTexture.texture.sampler && gltfTexture.texture.sampler.parameters || {};
    const image = gltfTexture.texture.source.image;
    let textureOptions;
    let specialTextureParameters = {};
    if (image.compressed) {
      textureOptions = image;
      specialTextureParameters = {
        [this.gl.TEXTURE_MIN_FILTER]: image.data.length > 1 ? this.gl.LINEAR_MIPMAP_NEAREST : this.gl.LINEAR
      };
    } else {
      textureOptions = {
        data: image
      };
    }
    const texture = new Texture2D(this.gl, {
      id: gltfTexture.name || gltfTexture.id,
      parameters: {
        ...parameters2,
        ...specialTextureParameters
      },
      pixelStore: {
        [this.gl.UNPACK_FLIP_Y_WEBGL]: false
      },
      ...textureOptions
    });
    this.uniforms[name] = texture;
    this.defineIfPresent(define2, define2);
    this.generatedTextures.push(texture);
  }
  parsePbrMetallicRoughness(pbrMetallicRoughness) {
    if (pbrMetallicRoughness.baseColorTexture) {
      this.parseTexture(pbrMetallicRoughness.baseColorTexture, "u_BaseColorSampler", "HAS_BASECOLORMAP");
    }
    this.uniforms.u_BaseColorFactor = pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1];
    if (pbrMetallicRoughness.metallicRoughnessTexture) {
      this.parseTexture(pbrMetallicRoughness.metallicRoughnessTexture, "u_MetallicRoughnessSampler", "HAS_METALROUGHNESSMAP");
    }
    const {
      metallicFactor = 1,
      roughnessFactor = 1
    } = pbrMetallicRoughness;
    this.uniforms.u_MetallicRoughnessValues = [metallicFactor, roughnessFactor];
  }
  parseMaterial(material) {
    this.uniforms.pbr_uUnlit = Boolean(material.unlit);
    if (material.pbrMetallicRoughness) {
      this.parsePbrMetallicRoughness(material.pbrMetallicRoughness);
    }
    if (material.normalTexture) {
      this.parseTexture(material.normalTexture, "u_NormalSampler", "HAS_NORMALMAP");
      const {
        scale = 1
      } = material.normalTexture;
      this.uniforms.u_NormalScale = scale;
    }
    if (material.occlusionTexture) {
      this.parseTexture(material.occlusionTexture, "u_OcclusionSampler", "HAS_OCCLUSIONMAP");
      const {
        strength = 1
      } = material.occlusionTexture;
      this.uniforms.u_OcclusionStrength = strength;
    }
    if (material.emissiveTexture) {
      this.parseTexture(material.emissiveTexture, "u_EmissiveSampler", "HAS_EMISSIVEMAP");
      this.uniforms.u_EmissiveFactor = material.emissiveFactor || [0, 0, 0];
    }
    if (material.alphaMode === "MASK") {
      const {
        alphaCutoff = 0.5
      } = material;
      this.defines.ALPHA_CUTOFF = 1;
      this.uniforms.u_AlphaCutoff = alphaCutoff;
    } else if (material.alphaMode === "BLEND") {
      log.warn("BLEND alphaMode might not work well because it requires mesh sorting")();
      Object.assign(this.parameters, {
        blend: true,
        blendEquation: this.gl.FUNC_ADD,
        blendFunc: [this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA, this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA]
      });
    }
  }
  delete() {
    this.generatedTextures.forEach((texture) => texture.delete());
  }
};

// node_modules/@luma.gl/experimental/dist/esm/gltf/create-gltf-model.js
var vs = "\n#if (__VERSION__ < 300)\n  #define _attr attribute\n#else\n  #define _attr in\n#endif\n\n  _attr vec4 POSITION;\n\n  #ifdef HAS_NORMALS\n    _attr vec4 NORMAL;\n  #endif\n\n  #ifdef HAS_TANGENTS\n    _attr vec4 TANGENT;\n  #endif\n\n  #ifdef HAS_UV\n    _attr vec2 TEXCOORD_0;\n  #endif\n\n  void main(void) {\n    vec4 _NORMAL = vec4(0.);\n    vec4 _TANGENT = vec4(0.);\n    vec2 _TEXCOORD_0 = vec2(0.);\n\n    #ifdef HAS_NORMALS\n      _NORMAL = NORMAL;\n    #endif\n\n    #ifdef HAS_TANGENTS\n      _TANGENT = TANGENT;\n    #endif\n\n    #ifdef HAS_UV\n      _TEXCOORD_0 = TEXCOORD_0;\n    #endif\n\n    pbr_setPositionNormalTangentUV(POSITION, _NORMAL, _TANGENT, _TEXCOORD_0);\n    gl_Position = u_MVPMatrix * POSITION;\n  }\n";
var fs = "\n#if (__VERSION__ < 300)\n  #define fragmentColor gl_FragColor\n#else\n  out vec4 fragmentColor;\n#endif\n\n  void main(void) {\n    fragmentColor = pbr_filterColor(vec4(0));\n  }\n";
function addVersionToShader(gl, source) {
  if (isWebGL2(gl)) {
    return "#version 300 es\n".concat(source);
  }
  return source;
}
function createGLTFModel(gl, options) {
  const {
    id,
    drawMode,
    vertexCount,
    attributes,
    modelOptions
  } = options;
  const materialParser = new GLTFMaterialParser(gl, options);
  log.info(4, "createGLTFModel defines: ", materialParser.defines)();
  const managedResources = [];
  managedResources.push(...materialParser.generatedTextures);
  managedResources.push(...Object.values(attributes).map((attribute) => attribute.buffer));
  const model = new ModelNode(gl, Object.assign({
    id,
    drawMode,
    vertexCount,
    modules: [pbr],
    defines: materialParser.defines,
    parameters: materialParser.parameters,
    vs: addVersionToShader(gl, vs),
    fs: addVersionToShader(gl, fs),
    managedResources
  }, modelOptions));
  model.setProps({
    attributes
  });
  model.setUniforms(materialParser.uniforms);
  return model;
}

// node_modules/@luma.gl/experimental/dist/esm/gltf/gltf-instantiator.js
var ATTRIBUTE_TYPE_TO_COMPONENTS2 = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
var DEFAULT_OPTIONS = {
  modelOptions: {},
  pbrDebug: false,
  imageBasedLightingEnvironment: null,
  lights: true,
  useTangents: false
};
var GLTFInstantiator = class {
  constructor(gl) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.gl = gl;
    this.options = Object.assign({}, DEFAULT_OPTIONS, options);
  }
  instantiate(gltf) {
    this.gltf = gltf;
    const scenes = (gltf.scenes || []).map((scene) => this.createScene(scene));
    return scenes;
  }
  createAnimator() {
    if (Array.isArray(this.gltf.animations)) {
      return new GLTFAnimator(this.gltf);
    }
    return null;
  }
  createScene(gltfScene) {
    const gltfNodes = gltfScene.nodes || [];
    const nodes = gltfNodes.map((node) => this.createNode(node));
    const scene = new GroupNode({
      id: gltfScene.name || gltfScene.id,
      children: nodes
    });
    return scene;
  }
  createNode(gltfNode) {
    if (!gltfNode._node) {
      const gltfChildren = gltfNode.children || [];
      const children = gltfChildren.map((child) => this.createNode(child));
      if (gltfNode.mesh) {
        children.push(this.createMesh(gltfNode.mesh));
      }
      const node = new GroupNode({
        id: gltfNode.name || gltfNode.id,
        children
      });
      if (gltfNode.matrix) {
        node.setMatrix(gltfNode.matrix);
      } else {
        node.matrix.identity();
        if (gltfNode.translation) {
          node.matrix.translate(gltfNode.translation);
        }
        if (gltfNode.rotation) {
          const rotationMatrix = new Matrix4().fromQuaternion(gltfNode.rotation);
          node.matrix.multiplyRight(rotationMatrix);
        }
        if (gltfNode.scale) {
          node.matrix.scale(gltfNode.scale);
        }
      }
      gltfNode._node = node;
    }
    return gltfNode._node;
  }
  createMesh(gltfMesh) {
    if (!gltfMesh._mesh) {
      const gltfPrimitives = gltfMesh.primitives || [];
      const primitives = gltfPrimitives.map((gltfPrimitive, i2) => this.createPrimitive(gltfPrimitive, i2, gltfMesh));
      const mesh = new GroupNode({
        id: gltfMesh.name || gltfMesh.id,
        children: primitives
      });
      gltfMesh._mesh = mesh;
    }
    return gltfMesh._mesh;
  }
  getVertexCount(attributes) {
    log.warn("getVertexCount() not found")();
  }
  createPrimitive(gltfPrimitive, i2, gltfMesh) {
    const model = createGLTFModel(this.gl, Object.assign({
      id: gltfPrimitive.name || "".concat(gltfMesh.name || gltfMesh.id, "-primitive-").concat(i2),
      drawMode: gltfPrimitive.mode || 4,
      vertexCount: gltfPrimitive.indices ? gltfPrimitive.indices.count : this.getVertexCount(gltfPrimitive.attributes),
      attributes: this.createAttributes(gltfPrimitive.attributes, gltfPrimitive.indices),
      material: gltfPrimitive.material
    }, this.options));
    model.bounds = [gltfPrimitive.attributes.POSITION.min, gltfPrimitive.attributes.POSITION.max];
    return model;
  }
  createAttributes(attributes, indices) {
    const loadedAttributes = {};
    Object.keys(attributes).forEach((attrName) => {
      loadedAttributes[attrName] = this.createAccessor(attributes[attrName], this.createBuffer(attributes[attrName], this.gl.ARRAY_BUFFER));
    });
    if (indices) {
      loadedAttributes.indices = this.createAccessor(indices, this.createBuffer(indices, this.gl.ELEMENT_ARRAY_BUFFER));
    }
    log.info(4, "glTF Attributes", {
      attributes,
      indices,
      generated: loadedAttributes
    })();
    return loadedAttributes;
  }
  createBuffer(attribute, target) {
    if (!attribute.bufferView) {
      attribute.bufferView = {};
    }
    const {
      bufferView
    } = attribute;
    if (!bufferView.lumaBuffers) {
      bufferView.lumaBuffers = {};
    }
    if (!bufferView.lumaBuffers[target]) {
      bufferView.lumaBuffers[target] = new Buffer(this.gl, {
        id: "from-".concat(bufferView.id),
        data: bufferView.data || attribute.value,
        target
      });
    }
    return bufferView.lumaBuffers[target];
  }
  createAccessor(accessor, buffer) {
    return new Accessor({
      buffer,
      offset: accessor.byteOffset || 0,
      stride: accessor.bufferView.byteStride || 0,
      type: accessor.componentType,
      size: ATTRIBUTE_TYPE_TO_COMPONENTS2[accessor.type]
    });
  }
  createSampler(gltfSampler) {
    return gltfSampler;
  }
  needsPOT() {
    return false;
  }
};

// node_modules/@luma.gl/experimental/dist/esm/gltf/create-gltf-objects.js
function createGLTFObjects(gl, gltf, options) {
  const instantiator = new GLTFInstantiator(gl, options);
  const scenes = instantiator.instantiate(gltf);
  const animator = instantiator.createAnimator();
  return {
    scenes,
    animator
  };
}

// node_modules/@luma.gl/experimental/dist/esm/gpgpu/point-in-polygon/polygon.js
var import_earcut = __toESM(require_earcut());
var PI_4 = Math.PI / 4;
var DEGREES_TO_RADIANS_HALF = Math.PI / 360;

// node_modules/@deck.gl/mesh-layers/dist/esm/scenegraph-layer/gltf-utils.js
async function waitForGLTFAssets(gltfObjects) {
  const remaining = [];
  gltfObjects.scenes.forEach((scene) => {
    scene.traverse((model) => {
      Object.values(model.model.getUniforms()).forEach((uniform) => {
        if (uniform.loaded === false) {
          remaining.push(uniform);
        }
      });
    });
  });
  return await waitWhileCondition(() => remaining.some((uniform) => !uniform.loaded));
}
async function waitWhileCondition(condition) {
  while (condition()) {
    await new Promise((resolve) => requestAnimationFrame(resolve));
  }
}

// node_modules/@deck.gl/mesh-layers/dist/esm/scenegraph-layer/scenegraph-layer-vertex.glsl.js
var scenegraph_layer_vertex_glsl_default = "#version 300 es\nin vec3 instancePositions;\nin vec3 instancePositions64Low;\nin vec4 instanceColors;\nin vec3 instancePickingColors;\nin mat3 instanceModelMatrix;\nin vec3 instanceTranslation;\nuniform float sizeScale;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform mat4 sceneModelMatrix;\nuniform bool composeModelMatrix;\nin vec4 POSITION;\n\n#ifdef HAS_UV\n  in vec2 TEXCOORD_0;\n#endif\n\n#ifdef MODULE_PBR\n  #ifdef HAS_NORMALS\n    in vec4 NORMAL;\n  #endif\n#endif\nout vec4 vColor;\n#ifndef MODULE_PBR\n  #ifdef HAS_UV\n    out vec2 vTEXCOORD_0;\n  #endif\n#endif\nvoid main(void) {\n  #if defined(HAS_UV) && !defined(MODULE_PBR)\n    vTEXCOORD_0 = TEXCOORD_0;\n    geometry.uv = vTEXCOORD_0;\n  #endif\n\n  geometry.worldPosition = instancePositions;\n  geometry.pickingColor = instancePickingColors;\n\n  vec3 normal = vec3(0.0, 0.0, 1.0);\n  #ifdef MODULE_PBR\n    #ifdef HAS_NORMALS\n      normal = instanceModelMatrix * (sceneModelMatrix * vec4(NORMAL.xyz, 0.0)).xyz;\n    #endif\n  #endif\n\n  float originalSize = project_size_to_pixel(sizeScale);\n  float clampedSize = clamp(originalSize, sizeMinPixels, sizeMaxPixels);\n\n  vec3 pos = (instanceModelMatrix * (sceneModelMatrix * POSITION).xyz) * sizeScale * (clampedSize / originalSize) + instanceTranslation;\n  if(composeModelMatrix) {\n    DECKGL_FILTER_SIZE(pos, geometry);\n    geometry.normal = project_normal(normal);\n    geometry.worldPosition += pos;\n    gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n  }\n  else {\n    pos = project_size(pos);\n    DECKGL_FILTER_SIZE(pos, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, geometry.position);\n    geometry.normal = project_normal(normal);\n  }\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  #ifdef MODULE_PBR\n    pbr_vPosition = geometry.position.xyz;\n    #ifdef HAS_NORMALS\n      pbr_vNormal = geometry.normal;\n    #endif\n\n    #ifdef HAS_UV\n      pbr_vUV = TEXCOORD_0;\n    #else\n      pbr_vUV = vec2(0., 0.);\n    #endif\n    geometry.uv = pbr_vUV;\n  #endif\n\n  vColor = instanceColors;\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";

// node_modules/@deck.gl/mesh-layers/dist/esm/scenegraph-layer/scenegraph-layer-fragment.glsl.js
var scenegraph_layer_fragment_glsl_default = "#version 300 es\nuniform float opacity;\nin vec4 vColor;\n\nout vec4 fragmentColor;\n#ifndef MODULE_PBR\n  #if defined(HAS_UV) && defined(HAS_BASECOLORMAP)\n    in vec2 vTEXCOORD_0;\n    uniform sampler2D u_BaseColorSampler;\n  #endif\n#endif\n\nvoid main(void) {\n  #ifdef MODULE_PBR\n    fragmentColor = vColor * pbr_filterColor(vec4(0));\n    geometry.uv = pbr_vUV;\n  #else\n    #if defined(HAS_UV) && defined(HAS_BASECOLORMAP)\n      fragmentColor = vColor * texture2D(u_BaseColorSampler, vTEXCOORD_0);\n      geometry.uv = vTEXCOORD_0;\n    #else\n      fragmentColor = vColor;\n    #endif\n  #endif\n\n  fragmentColor.a *= opacity;\n  DECKGL_FILTER_COLOR(fragmentColor, geometry);\n}\n";

// node_modules/@deck.gl/mesh-layers/dist/esm/scenegraph-layer/scenegraph-layer.js
var DEFAULT_COLOR2 = [255, 255, 255, 255];
var defaultProps11 = {
  scenegraph: {
    type: "object",
    value: null,
    async: true
  },
  getScene: (gltf) => {
    if (gltf && gltf.scenes) {
      return typeof gltf.scene === "object" ? gltf.scene : gltf.scenes[gltf.scene || 0];
    }
    return gltf;
  },
  getAnimator: (scenegraph) => scenegraph && scenegraph.animator,
  _animations: null,
  sizeScale: {
    type: "number",
    value: 1,
    min: 0
  },
  sizeMinPixels: {
    type: "number",
    min: 0,
    value: 0
  },
  sizeMaxPixels: {
    type: "number",
    min: 0,
    value: Number.MAX_SAFE_INTEGER
  },
  getPosition: {
    type: "accessor",
    value: (x2) => x2.position
  },
  getColor: {
    type: "accessor",
    value: DEFAULT_COLOR2
  },
  _lighting: "flat",
  _imageBasedLightingEnvironment: null,
  getOrientation: {
    type: "accessor",
    value: [0, 0, 0]
  },
  getScale: {
    type: "accessor",
    value: [1, 1, 1]
  },
  getTranslation: {
    type: "accessor",
    value: [0, 0, 0]
  },
  getTransformMatrix: {
    type: "accessor",
    value: []
  },
  loaders: [GLTFLoader]
};
var ScenegraphLayer = class extends Layer {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "state", void 0);
  }
  getShaders() {
    const modules = [project32_default, picking_default];
    if (this.props._lighting === "pbr") {
      modules.push(pbr);
    }
    return super.getShaders({
      vs: scenegraph_layer_vertex_glsl_default,
      fs: scenegraph_layer_fragment_glsl_default,
      modules
    });
  }
  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instancePositions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        accessor: "getPosition",
        transition: true
      },
      instanceColors: {
        type: 5121,
        size: this.props.colorFormat.length,
        accessor: "getColor",
        normalized: true,
        defaultValue: DEFAULT_COLOR2,
        transition: true
      },
      instanceModelMatrix: MATRIX_ATTRIBUTES
    });
  }
  updateState(params) {
    super.updateState(params);
    const {
      props,
      oldProps
    } = params;
    if (props.scenegraph !== oldProps.scenegraph) {
      this._updateScenegraph();
    } else if (props._animations !== oldProps._animations) {
      this._applyAnimationsProp(this.state.scenegraph, this.state.animator, props._animations);
    }
  }
  finalizeState(context) {
    super.finalizeState(context);
    this._deleteScenegraph();
  }
  _updateScenegraph() {
    const props = this.props;
    const {
      gl
    } = this.context;
    let scenegraphData = null;
    if (props.scenegraph instanceof ScenegraphNode) {
      scenegraphData = {
        scenes: [props.scenegraph]
      };
    } else if (props.scenegraph && !props.scenegraph.gltf) {
      const gltf = props.scenegraph;
      const gltfObjects = createGLTFObjects(gl, gltf, this._getModelOptions());
      scenegraphData = {
        gltf,
        ...gltfObjects
      };
      waitForGLTFAssets(gltfObjects).then(() => this.setNeedsRedraw());
    } else if (props.scenegraph) {
      log_default.deprecated("ScenegraphLayer.props.scenegraph", "Use GLTFLoader instead of GLTFScenegraphLoader")();
      scenegraphData = props.scenegraph;
    }
    const options = {
      layer: this,
      gl
    };
    const scenegraph = props.getScene(scenegraphData, options);
    const animator = props.getAnimator(scenegraphData, options);
    if (scenegraph instanceof ScenegraphNode) {
      this._deleteScenegraph();
      this._applyAllAttributes(scenegraph);
      this._applyAnimationsProp(scenegraph, animator, props._animations);
      this.setState({
        scenegraph,
        animator
      });
    } else if (scenegraph !== null) {
      log_default.warn("invalid scenegraph:", scenegraph)();
    }
  }
  _applyAllAttributes(scenegraph) {
    if (this.state.attributesAvailable) {
      const allAttributes = this.getAttributeManager().getAttributes();
      scenegraph.traverse((model) => {
        this._setModelAttributes(model.model, allAttributes);
      });
    }
  }
  _applyAnimationsProp(scenegraph, animator, animationsProp) {
    if (!scenegraph || !animator || !animationsProp) {
      return;
    }
    const animations = animator.getAnimations();
    Object.keys(animationsProp).sort().forEach((key) => {
      const value = animationsProp[key];
      if (key === "*") {
        animations.forEach((animation) => {
          Object.assign(animation, value);
        });
      } else if (Number.isFinite(Number(key))) {
        const number = Number(key);
        if (number >= 0 && number < animations.length) {
          Object.assign(animations[number], value);
        } else {
          log_default.warn("animation ".concat(key, " not found"))();
        }
      } else {
        const findResult = animations.find(({
          name
        }) => name === key);
        if (findResult) {
          Object.assign(findResult, value);
        } else {
          log_default.warn("animation ".concat(key, " not found"))();
        }
      }
    });
  }
  _deleteScenegraph() {
    const {
      scenegraph
    } = this.state;
    if (scenegraph instanceof ScenegraphNode) {
      scenegraph.delete();
    }
  }
  _getModelOptions() {
    const {
      _imageBasedLightingEnvironment
    } = this.props;
    let env = null;
    if (_imageBasedLightingEnvironment) {
      if (typeof _imageBasedLightingEnvironment === "function") {
        env = _imageBasedLightingEnvironment({
          gl: this.context.gl,
          layer: this
        });
      } else {
        env = _imageBasedLightingEnvironment;
      }
    }
    return {
      gl: this.context.gl,
      waitForFullLoad: true,
      imageBasedLightingEnvironment: env,
      modelOptions: {
        isInstanced: true,
        transpileToGLSL100: !isWebGL2(this.context.gl),
        ...this.getShaders()
      },
      useTangents: false
    };
  }
  updateAttributes(changedAttributes) {
    this.setState({
      attributesAvailable: true
    });
    if (!this.state.scenegraph)
      return;
    this.state.scenegraph.traverse((model) => {
      this._setModelAttributes(model.model, changedAttributes);
    });
  }
  draw({
    moduleParameters = null,
    parameters: parameters2 = {},
    context
  }) {
    if (!this.state.scenegraph)
      return;
    if (this.props._animations && this.state.animator) {
      this.state.animator.animate(context.timeline.getTime());
      this.setNeedsRedraw();
    }
    const {
      viewport
    } = this.context;
    const {
      sizeScale,
      sizeMinPixels,
      sizeMaxPixels,
      opacity,
      coordinateSystem
    } = this.props;
    const numInstances = this.getNumInstances();
    this.state.scenegraph.traverse((model, {
      worldMatrix
    }) => {
      model.model.setInstanceCount(numInstances);
      model.updateModuleSettings(moduleParameters);
      model.draw({
        parameters: parameters2,
        uniforms: {
          sizeScale,
          opacity,
          sizeMinPixels,
          sizeMaxPixels,
          composeModelMatrix: shouldComposeModelMatrix(viewport, coordinateSystem),
          sceneModelMatrix: worldMatrix,
          u_Camera: model.model.getUniforms().project_uCameraPosition
        }
      });
    });
  }
};
_defineProperty(ScenegraphLayer, "defaultProps", defaultProps11);
_defineProperty(ScenegraphLayer, "layerName", "ScenegraphLayer");

// node_modules/@deck.gl/geo-layers/dist/esm/mesh-layer/mesh-layer-vertex.glsl.js
var mesh_layer_vertex_glsl_default = "#version 300 es\n#define SHADER_NAME simple-mesh-layer-vs\nuniform float sizeScale;\nuniform bool composeModelMatrix;\nuniform bool pickFeatureIds;\nin vec3 positions;\nin vec3 normals;\nin vec3 colors;\nin vec2 texCoords;\nin vec4 uvRegions;\nin vec3 featureIdsPickingColors;\nin vec4 instanceColors;\nin vec3 instancePickingColors;\nin mat3 instanceModelMatrix;\nout vec2 vTexCoord;\nout vec3 cameraPosition;\nout vec3 normals_commonspace;\nout vec4 position_commonspace;\nout vec4 vColor;\n\nvec2 applyUVRegion(vec2 uv) {\n  #ifdef HAS_UV_REGIONS\n    return fract(uv) * (uvRegions.zw - uvRegions.xy) + uvRegions.xy;\n  #else\n    return uv;\n  #endif\n}\n\nvoid main(void) {\n  vec2 uv = applyUVRegion(texCoords);\n  geometry.uv = uv;\n\n  if (pickFeatureIds) {\n    geometry.pickingColor = featureIdsPickingColors;\n  } else {\n    geometry.pickingColor = instancePickingColors;\n  }\n\n  vTexCoord = uv;\n  cameraPosition = project_uCameraPosition;\n  vColor = vec4(colors * instanceColors.rgb, instanceColors.a);\n\n  vec3 pos = (instanceModelMatrix * positions) * sizeScale;\n  vec3 projectedPosition = project_position(positions);\n  position_commonspace = vec4(projectedPosition, 1.0);\n  gl_Position = project_common_position_to_clipspace(position_commonspace);\n\n  geometry.position = position_commonspace;\n  normals_commonspace = project_normal(instanceModelMatrix * normals);\n  geometry.normal = normals_commonspace;\n\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  #ifdef MODULE_PBR\n    pbr_vPosition = geometry.position.xyz;\n    #ifdef HAS_NORMALS\n      pbr_vNormal = geometry.normal;\n    #endif\n\n    #ifdef HAS_UV\n      pbr_vUV = uv;\n    #else\n      pbr_vUV = vec2(0., 0.);\n    #endif\n    geometry.uv = pbr_vUV;\n  #endif\n\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";

// node_modules/@deck.gl/geo-layers/dist/esm/mesh-layer/mesh-layer-fragment.glsl.js
var mesh_layer_fragment_glsl_default = "#version 300 es\n#define SHADER_NAME simple-mesh-layer-fs\n\nprecision highp float;\n\nuniform bool hasTexture;\nuniform sampler2D sampler;\nuniform bool flatShading;\nuniform float opacity;\n\nin vec2 vTexCoord;\nin vec3 cameraPosition;\nin vec3 normals_commonspace;\nin vec4 position_commonspace;\nin vec4 vColor;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  \n#ifdef MODULE_PBR\n\n  fragColor = vColor * pbr_filterColor(vec4(0));\n  geometry.uv = pbr_vUV;\n  fragColor.a *= opacity;\n\n#else\n\n  geometry.uv = vTexCoord;\n\n  vec3 normal;\n  if (flatShading) {\n#ifdef DERIVATIVES_AVAILABLE\n    normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));\n#else\n    normal = vec3(0.0, 0.0, 1.0);\n#endif\n  } else {\n    normal = normals_commonspace;\n  }\n\n  vec4 color = hasTexture ? texture(sampler, vTexCoord) : vColor;\n  vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);\n  fragColor = vec4(lightColor, color.a * opacity);\n\n#endif\n\n  DECKGL_FILTER_COLOR(fragColor, geometry);\n}\n";

// node_modules/@deck.gl/geo-layers/dist/esm/mesh-layer/mesh-layer.js
function validateGeometryAttributes2(attributes) {
  const hasColorAttribute = attributes.COLOR_0 || attributes.colors;
  if (!hasColorAttribute) {
    attributes.colors = {
      constant: true,
      value: new Float32Array([1, 1, 1])
    };
  }
}
var defaultProps12 = {
  pbrMaterial: {
    type: "object",
    value: null
  },
  featureIds: {
    type: "array",
    value: null,
    optional: true
  }
};
var MeshLayer = class extends SimpleMeshLayer {
  getShaders() {
    const shaders = super.getShaders();
    const modules = shaders.modules;
    modules.push(pbr);
    return {
      ...shaders,
      vs: mesh_layer_vertex_glsl_default,
      fs: mesh_layer_fragment_glsl_default
    };
  }
  initializeState() {
    const {
      featureIds
    } = this.props;
    super.initializeState();
    const attributeManager = this.getAttributeManager();
    if (featureIds) {
      attributeManager.add({
        featureIdsPickingColors: {
          type: 5121,
          size: 3,
          noAlloc: true,
          update: this.calculateFeatureIdsPickingColors
        }
      });
    }
  }
  updateState(params) {
    super.updateState(params);
    const {
      props,
      oldProps
    } = params;
    if (props.pbrMaterial !== oldProps.pbrMaterial) {
      this.updatePbrMaterialUniforms(props.pbrMaterial);
    }
  }
  draw(opts) {
    const {
      featureIds
    } = this.props;
    if (!this.state.model) {
      return;
    }
    this.state.model.setUniforms({
      u_Camera: this.state.model.getUniforms().project_uCameraPosition,
      pickFeatureIds: Boolean(featureIds)
    });
    super.draw(opts);
  }
  getModel(mesh) {
    const {
      id,
      pbrMaterial
    } = this.props;
    const materialParser = this.parseMaterial(pbrMaterial, mesh);
    this.setState({
      materialParser
    });
    const shaders = this.getShaders();
    validateGeometryAttributes2(mesh.attributes);
    const model = new Model(this.context.gl, {
      ...this.getShaders(),
      id,
      geometry: mesh,
      defines: {
        ...shaders.defines,
        ...materialParser === null || materialParser === void 0 ? void 0 : materialParser.defines,
        HAS_UV_REGIONS: mesh.attributes.uvRegions
      },
      parameters: materialParser === null || materialParser === void 0 ? void 0 : materialParser.parameters,
      isInstanced: true
    });
    return model;
  }
  updatePbrMaterialUniforms(pbrMaterial) {
    const {
      model
    } = this.state;
    if (model) {
      const {
        mesh
      } = this.props;
      const materialParser = this.parseMaterial(pbrMaterial, mesh);
      this.setState({
        materialParser
      });
      model.setUniforms(materialParser.uniforms);
    }
  }
  parseMaterial(pbrMaterial, mesh) {
    var _this$state$materialP;
    const unlit = Boolean(pbrMaterial.pbrMetallicRoughness && pbrMaterial.pbrMetallicRoughness.baseColorTexture);
    (_this$state$materialP = this.state.materialParser) === null || _this$state$materialP === void 0 ? void 0 : _this$state$materialP.delete();
    return new GLTFMaterialParser(this.context.gl, {
      attributes: {
        NORMAL: mesh.attributes.normals,
        TEXCOORD_0: mesh.attributes.texCoords
      },
      material: {
        unlit,
        ...pbrMaterial
      },
      pbrDebug: false,
      imageBasedLightingEnvironment: null,
      lights: true,
      useTangents: false
    });
  }
  calculateFeatureIdsPickingColors(attribute) {
    const featureIds = this.props.featureIds;
    const value = new Uint8ClampedArray(featureIds.length * attribute.size);
    const pickingColor = [];
    for (let index = 0; index < featureIds.length; index++) {
      this.encodePickingColor(featureIds[index], pickingColor);
      value[index * 3] = pickingColor[0];
      value[index * 3 + 1] = pickingColor[1];
      value[index * 3 + 2] = pickingColor[2];
    }
    attribute.value = value;
  }
  finalizeState(context) {
    var _this$state$materialP2;
    super.finalizeState(context);
    (_this$state$materialP2 = this.state.materialParser) === null || _this$state$materialP2 === void 0 ? void 0 : _this$state$materialP2.delete();
    this.setState({
      materialParser: null
    });
  }
};
_defineProperty(MeshLayer, "layerName", "MeshLayer");
_defineProperty(MeshLayer, "defaultProps", defaultProps12);

// node_modules/@deck.gl/geo-layers/dist/esm/tile-3d-layer/tile-3d-layer.js
var SINGLE_DATA = [0];
var defaultProps13 = {
  getPointColor: {
    type: "accessor",
    value: [0, 0, 0, 255]
  },
  pointSize: 1,
  data: "",
  loader: Tiles3DLoader,
  onTilesetLoad: {
    type: "function",
    value: (tileset3d) => {
    }
  },
  onTileLoad: {
    type: "function",
    value: (tileHeader) => {
    }
  },
  onTileUnload: {
    type: "function",
    value: (tileHeader) => {
    }
  },
  onTileError: {
    type: "function",
    value: (tile, message, url) => {
    }
  },
  _getMeshColor: {
    type: "function",
    value: (tileHeader) => [255, 255, 255]
  }
};
var Tile3DLayer = class extends CompositeLayer {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "state", void 0);
  }
  initializeState() {
    if ("onTileLoadFail" in this.props) {
      log_default.removed("onTileLoadFail", "onTileError")();
    }
    this.state = {
      layerMap: {},
      tileset3d: null,
      activeViewports: {},
      lastUpdatedViewports: null
    };
  }
  get isLoaded() {
    const {
      tileset3d
    } = this.state;
    return tileset3d !== null && tileset3d.isLoaded();
  }
  shouldUpdateState({
    changeFlags
  }) {
    return changeFlags.somethingChanged;
  }
  updateState({
    props,
    oldProps,
    changeFlags
  }) {
    if (props.data && props.data !== oldProps.data) {
      this._loadTileset(props.data);
    }
    if (changeFlags.viewportChanged) {
      const {
        activeViewports
      } = this.state;
      const viewportsNumber = Object.keys(activeViewports).length;
      if (viewportsNumber) {
        this._updateTileset(activeViewports);
        this.state.lastUpdatedViewports = activeViewports;
        this.state.activeViewports = {};
      }
    }
    if (changeFlags.propsChanged) {
      const {
        layerMap
      } = this.state;
      for (const key in layerMap) {
        layerMap[key].needsUpdate = true;
      }
    }
  }
  activateViewport(viewport) {
    const {
      activeViewports,
      lastUpdatedViewports
    } = this.state;
    this.internalState.viewport = viewport;
    activeViewports[viewport.id] = viewport;
    const lastViewport = lastUpdatedViewports === null || lastUpdatedViewports === void 0 ? void 0 : lastUpdatedViewports[viewport.id];
    if (!lastViewport || !viewport.equals(lastViewport)) {
      this.setChangeFlags({
        viewportChanged: true
      });
      this.setNeedsUpdate();
    }
  }
  getPickingInfo({
    info,
    sourceLayer
  }) {
    const sourceTile = sourceLayer && sourceLayer.props.tile;
    if (info.picked) {
      info.object = sourceTile;
    }
    info.sourceTile = sourceTile;
    return info;
  }
  filterSubLayer({
    layer,
    viewport
  }) {
    const {
      tile
    } = layer.props;
    const {
      id: viewportId
    } = viewport;
    return tile.selected && tile.viewportIds.includes(viewportId);
  }
  _updateAutoHighlight(info) {
    const sourceTile = info.sourceTile;
    const layerCache = this.state.layerMap[sourceTile === null || sourceTile === void 0 ? void 0 : sourceTile.id];
    if (layerCache && layerCache.layer) {
      layerCache.layer.updateAutoHighlight(info);
    }
  }
  async _loadTileset(tilesetUrl) {
    const {
      loadOptions = {}
    } = this.props;
    let loader = this.props.loader || this.props.loaders;
    if (Array.isArray(loader)) {
      loader = loader[0];
    }
    const options = {
      loadOptions: {
        ...loadOptions
      }
    };
    let actualTilesetUrl = tilesetUrl;
    if (loader.preload) {
      const preloadOptions = await loader.preload(tilesetUrl, loadOptions);
      if (preloadOptions.url) {
        actualTilesetUrl = preloadOptions.url;
      }
      if (preloadOptions.headers) {
        options.loadOptions.fetch = {
          ...options.loadOptions.fetch,
          headers: preloadOptions.headers
        };
      }
      Object.assign(options, preloadOptions);
    }
    const tilesetJson = await load(actualTilesetUrl, loader, options.loadOptions);
    const tileset3d = new Tileset3D(tilesetJson, {
      onTileLoad: this._onTileLoad.bind(this),
      onTileUnload: this._onTileUnload.bind(this),
      onTileError: this.props.onTileError,
      ...options
    });
    this.setState({
      tileset3d,
      layerMap: {}
    });
    this._updateTileset(this.state.activeViewports);
    this.props.onTilesetLoad(tileset3d);
  }
  _onTileLoad(tileHeader) {
    const {
      lastUpdatedViewports
    } = this.state;
    this.props.onTileLoad(tileHeader);
    this._updateTileset(lastUpdatedViewports);
    this.setNeedsUpdate();
  }
  _onTileUnload(tileHeader) {
    delete this.state.layerMap[tileHeader.id];
    this.props.onTileUnload(tileHeader);
  }
  _updateTileset(viewports) {
    if (!viewports) {
      return;
    }
    const {
      tileset3d
    } = this.state;
    const {
      timeline
    } = this.context;
    const viewportsNumber = Object.keys(viewports).length;
    if (!timeline || !viewportsNumber || !tileset3d) {
      return;
    }
    tileset3d.selectTiles(Object.values(viewports)).then((frameNumber) => {
      const tilesetChanged = this.state.frameNumber !== frameNumber;
      if (tilesetChanged) {
        this.setState({
          frameNumber
        });
      }
    });
  }
  _getSubLayer(tileHeader, oldLayer) {
    if (!tileHeader.content) {
      return null;
    }
    switch (tileHeader.type) {
      case TILE_TYPE.POINTCLOUD:
        return this._makePointCloudLayer(tileHeader, oldLayer);
      case TILE_TYPE.SCENEGRAPH:
        return this._make3DModelLayer(tileHeader);
      case TILE_TYPE.MESH:
        return this._makeSimpleMeshLayer(tileHeader, oldLayer);
      default:
        throw new Error("Tile3DLayer: Failed to render layer of type ".concat(tileHeader.content.type));
    }
  }
  _makePointCloudLayer(tileHeader, oldLayer) {
    const {
      attributes,
      pointCount,
      constantRGBA,
      cartographicOrigin,
      modelMatrix: modelMatrix2
    } = tileHeader.content;
    const {
      positions,
      normals,
      colors
    } = attributes;
    if (!positions) {
      return null;
    }
    const data = oldLayer && oldLayer.props.data || {
      header: {
        vertexCount: pointCount
      },
      attributes: {
        POSITION: positions,
        NORMAL: normals,
        COLOR_0: colors
      }
    };
    const {
      pointSize,
      getPointColor
    } = this.props;
    const SubLayerClass = this.getSubLayerClass("pointcloud", PointCloudLayer);
    return new SubLayerClass({
      pointSize
    }, this.getSubLayerProps({
      id: "pointcloud"
    }), {
      id: "".concat(this.id, "-pointcloud-").concat(tileHeader.id),
      tile: tileHeader,
      data,
      coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,
      coordinateOrigin: cartographicOrigin,
      modelMatrix: modelMatrix2,
      getColor: constantRGBA || getPointColor,
      _offset: 0
    });
  }
  _make3DModelLayer(tileHeader) {
    const {
      gltf,
      instances,
      cartographicOrigin,
      modelMatrix: modelMatrix2
    } = tileHeader.content;
    const SubLayerClass = this.getSubLayerClass("scenegraph", ScenegraphLayer);
    return new SubLayerClass({
      _lighting: "pbr"
    }, this.getSubLayerProps({
      id: "scenegraph"
    }), {
      id: "".concat(this.id, "-scenegraph-").concat(tileHeader.id),
      tile: tileHeader,
      data: instances || SINGLE_DATA,
      scenegraph: gltf,
      coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,
      coordinateOrigin: cartographicOrigin,
      modelMatrix: modelMatrix2,
      getTransformMatrix: (instance) => instance.modelMatrix,
      getPosition: [0, 0, 0],
      _offset: 0
    });
  }
  _makeSimpleMeshLayer(tileHeader, oldLayer) {
    const content = tileHeader.content;
    const {
      attributes,
      indices,
      modelMatrix: modelMatrix2,
      cartographicOrigin,
      coordinateSystem = COORDINATE_SYSTEM.METER_OFFSETS,
      material,
      featureIds
    } = content;
    const {
      _getMeshColor
    } = this.props;
    const geometry = oldLayer && oldLayer.props.mesh || new Geometry({
      drawMode: 4,
      attributes: getMeshGeometry(attributes),
      indices
    });
    const SubLayerClass = this.getSubLayerClass("mesh", MeshLayer);
    return new SubLayerClass(this.getSubLayerProps({
      id: "mesh"
    }), {
      id: "".concat(this.id, "-mesh-").concat(tileHeader.id),
      tile: tileHeader,
      mesh: geometry,
      data: SINGLE_DATA,
      getColor: _getMeshColor(tileHeader),
      pbrMaterial: material,
      modelMatrix: modelMatrix2,
      coordinateOrigin: cartographicOrigin,
      coordinateSystem,
      featureIds,
      _offset: 0
    });
  }
  renderLayers() {
    const {
      tileset3d,
      layerMap
    } = this.state;
    if (!tileset3d) {
      return null;
    }
    return tileset3d.tiles.map((tile) => {
      const layerCache = layerMap[tile.id] = layerMap[tile.id] || {
        tile
      };
      let {
        layer
      } = layerCache;
      if (tile.selected) {
        if (!layer) {
          layer = this._getSubLayer(tile);
        } else if (layerCache.needsUpdate) {
          layer = this._getSubLayer(tile, layer);
          layerCache.needsUpdate = false;
        }
      }
      layerCache.layer = layer;
      return layer;
    }).filter(Boolean);
  }
};
_defineProperty(Tile3DLayer, "defaultProps", defaultProps13);
_defineProperty(Tile3DLayer, "layerName", "Tile3DLayer");
function getMeshGeometry(contentAttributes) {
  const attributes = {};
  attributes.positions = {
    ...contentAttributes.positions,
    value: new Float32Array(contentAttributes.positions.value)
  };
  if (contentAttributes.normals) {
    attributes.normals = contentAttributes.normals;
  }
  if (contentAttributes.texCoords) {
    attributes.texCoords = contentAttributes.texCoords;
  }
  if (contentAttributes.colors) {
    attributes.colors = contentAttributes.colors;
  }
  if (contentAttributes.uvRegions) {
    attributes.uvRegions = contentAttributes.uvRegions;
  }
  return attributes;
}

// node_modules/@loaders.gl/terrain/dist/esm/lib/decode-quantized-mesh.js
var QUANTIZED_MESH_HEADER = /* @__PURE__ */ new Map([["centerX", Float64Array.BYTES_PER_ELEMENT], ["centerY", Float64Array.BYTES_PER_ELEMENT], ["centerZ", Float64Array.BYTES_PER_ELEMENT], ["minHeight", Float32Array.BYTES_PER_ELEMENT], ["maxHeight", Float32Array.BYTES_PER_ELEMENT], ["boundingSphereCenterX", Float64Array.BYTES_PER_ELEMENT], ["boundingSphereCenterY", Float64Array.BYTES_PER_ELEMENT], ["boundingSphereCenterZ", Float64Array.BYTES_PER_ELEMENT], ["boundingSphereRadius", Float64Array.BYTES_PER_ELEMENT], ["horizonOcclusionPointX", Float64Array.BYTES_PER_ELEMENT], ["horizonOcclusionPointY", Float64Array.BYTES_PER_ELEMENT], ["horizonOcclusionPointZ", Float64Array.BYTES_PER_ELEMENT]]);
function decodeZigZag(value) {
  return value >> 1 ^ -(value & 1);
}
function decodeHeader(dataView) {
  let position = 0;
  const header = {};
  for (const [key, bytesCount] of QUANTIZED_MESH_HEADER) {
    const getter = bytesCount === 8 ? dataView.getFloat64 : dataView.getFloat32;
    header[key] = getter.call(dataView, position, true);
    position += bytesCount;
  }
  return {
    header,
    headerEndPosition: position
  };
}
function decodeVertexData(dataView, headerEndPosition) {
  let position = headerEndPosition;
  const elementsPerVertex = 3;
  const vertexCount = dataView.getUint32(position, true);
  const vertexData = new Uint16Array(vertexCount * elementsPerVertex);
  position += Uint32Array.BYTES_PER_ELEMENT;
  const bytesPerArrayElement = Uint16Array.BYTES_PER_ELEMENT;
  const elementArrayLength = vertexCount * bytesPerArrayElement;
  const uArrayStartPosition = position;
  const vArrayStartPosition = uArrayStartPosition + elementArrayLength;
  const heightArrayStartPosition = vArrayStartPosition + elementArrayLength;
  let u = 0;
  let v = 0;
  let height = 0;
  for (let i2 = 0; i2 < vertexCount; i2++) {
    u += decodeZigZag(dataView.getUint16(uArrayStartPosition + bytesPerArrayElement * i2, true));
    v += decodeZigZag(dataView.getUint16(vArrayStartPosition + bytesPerArrayElement * i2, true));
    height += decodeZigZag(dataView.getUint16(heightArrayStartPosition + bytesPerArrayElement * i2, true));
    vertexData[i2] = u;
    vertexData[i2 + vertexCount] = v;
    vertexData[i2 + vertexCount * 2] = height;
  }
  position += elementArrayLength * 3;
  return {
    vertexData,
    vertexDataEndPosition: position
  };
}
function decodeIndex(buffer, position, indicesCount, bytesPerIndex) {
  let encoded = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
  let indices;
  if (bytesPerIndex === 2) {
    indices = new Uint16Array(buffer, position, indicesCount);
  } else {
    indices = new Uint32Array(buffer, position, indicesCount);
  }
  if (!encoded) {
    return indices;
  }
  let highest = 0;
  for (let i2 = 0; i2 < indices.length; ++i2) {
    const code = indices[i2];
    indices[i2] = highest - code;
    if (code === 0) {
      ++highest;
    }
  }
  return indices;
}
function decodeTriangleIndices(dataView, vertexData, vertexDataEndPosition) {
  let position = vertexDataEndPosition;
  const elementsPerVertex = 3;
  const vertexCount = vertexData.length / elementsPerVertex;
  const bytesPerIndex = vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;
  if (position % bytesPerIndex !== 0) {
    position += bytesPerIndex - position % bytesPerIndex;
  }
  const triangleCount = dataView.getUint32(position, true);
  position += Uint32Array.BYTES_PER_ELEMENT;
  const triangleIndicesCount = triangleCount * 3;
  const triangleIndices = decodeIndex(dataView.buffer, position, triangleIndicesCount, bytesPerIndex);
  position += triangleIndicesCount * bytesPerIndex;
  return {
    triangleIndicesEndPosition: position,
    triangleIndices
  };
}
function decodeEdgeIndices(dataView, vertexData, triangleIndicesEndPosition) {
  let position = triangleIndicesEndPosition;
  const elementsPerVertex = 3;
  const vertexCount = vertexData.length / elementsPerVertex;
  const bytesPerIndex = vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;
  const westVertexCount = dataView.getUint32(position, true);
  position += Uint32Array.BYTES_PER_ELEMENT;
  const westIndices = decodeIndex(dataView.buffer, position, westVertexCount, bytesPerIndex, false);
  position += westVertexCount * bytesPerIndex;
  const southVertexCount = dataView.getUint32(position, true);
  position += Uint32Array.BYTES_PER_ELEMENT;
  const southIndices = decodeIndex(dataView.buffer, position, southVertexCount, bytesPerIndex, false);
  position += southVertexCount * bytesPerIndex;
  const eastVertexCount = dataView.getUint32(position, true);
  position += Uint32Array.BYTES_PER_ELEMENT;
  const eastIndices = decodeIndex(dataView.buffer, position, eastVertexCount, bytesPerIndex, false);
  position += eastVertexCount * bytesPerIndex;
  const northVertexCount = dataView.getUint32(position, true);
  position += Uint32Array.BYTES_PER_ELEMENT;
  const northIndices = decodeIndex(dataView.buffer, position, northVertexCount, bytesPerIndex, false);
  position += northVertexCount * bytesPerIndex;
  return {
    edgeIndicesEndPosition: position,
    westIndices,
    southIndices,
    eastIndices,
    northIndices
  };
}
function decodeVertexNormalsExtension(extensionDataView) {
  return new Uint8Array(extensionDataView.buffer, extensionDataView.byteOffset, extensionDataView.byteLength);
}
function decodeWaterMaskExtension(extensionDataView) {
  return extensionDataView.buffer.slice(extensionDataView.byteOffset, extensionDataView.byteOffset + extensionDataView.byteLength);
}
function decodeExtensions(dataView, indicesEndPosition) {
  const extensions = {};
  if (dataView.byteLength <= indicesEndPosition) {
    return {
      extensions,
      extensionsEndPosition: indicesEndPosition
    };
  }
  let position = indicesEndPosition;
  while (position < dataView.byteLength) {
    const extensionId = dataView.getUint8(position, true);
    position += Uint8Array.BYTES_PER_ELEMENT;
    const extensionLength = dataView.getUint32(position, true);
    position += Uint32Array.BYTES_PER_ELEMENT;
    const extensionView = new DataView(dataView.buffer, position, extensionLength);
    switch (extensionId) {
      case 1: {
        extensions.vertexNormals = decodeVertexNormalsExtension(extensionView);
        break;
      }
      case 2: {
        extensions.waterMask = decodeWaterMaskExtension(extensionView);
        break;
      }
      default: {
      }
    }
    position += extensionLength;
  }
  return {
    extensions,
    extensionsEndPosition: position
  };
}
var DECODING_STEPS = {
  header: 0,
  vertices: 1,
  triangleIndices: 2,
  edgeIndices: 3,
  extensions: 4
};
var DEFAULT_OPTIONS2 = {
  maxDecodingStep: DECODING_STEPS.extensions
};
function decode(data, userOptions) {
  const options = Object.assign({}, DEFAULT_OPTIONS2, userOptions);
  const view = new DataView(data);
  const {
    header,
    headerEndPosition
  } = decodeHeader(view);
  if (options.maxDecodingStep < DECODING_STEPS.vertices) {
    return {
      header
    };
  }
  const {
    vertexData,
    vertexDataEndPosition
  } = decodeVertexData(view, headerEndPosition);
  if (options.maxDecodingStep < DECODING_STEPS.triangleIndices) {
    return {
      header,
      vertexData
    };
  }
  const {
    triangleIndices,
    triangleIndicesEndPosition
  } = decodeTriangleIndices(view, vertexData, vertexDataEndPosition);
  if (options.maxDecodingStep < DECODING_STEPS.edgeIndices) {
    return {
      header,
      vertexData,
      triangleIndices
    };
  }
  const {
    westIndices,
    southIndices,
    eastIndices,
    northIndices,
    edgeIndicesEndPosition
  } = decodeEdgeIndices(view, vertexData, triangleIndicesEndPosition);
  if (options.maxDecodingStep < DECODING_STEPS.extensions) {
    return {
      header,
      vertexData,
      triangleIndices,
      westIndices,
      northIndices,
      eastIndices,
      southIndices
    };
  }
  const {
    extensions
  } = decodeExtensions(view, edgeIndicesEndPosition);
  return {
    header,
    vertexData,
    triangleIndices,
    westIndices,
    northIndices,
    eastIndices,
    southIndices,
    extensions
  };
}

// node_modules/@loaders.gl/terrain/dist/esm/lib/helpers/skirt.js
function addSkirt(attributes, triangles, skirtHeight, outsideIndices) {
  const outsideEdges = outsideIndices ? getOutsideEdgesFromIndices(outsideIndices, attributes.POSITION.value) : getOutsideEdgesFromTriangles(triangles);
  const newPosition = new attributes.POSITION.value.constructor(outsideEdges.length * 6);
  const newTexcoord0 = new attributes.TEXCOORD_0.value.constructor(outsideEdges.length * 4);
  const newTriangles = new triangles.constructor(outsideEdges.length * 6);
  for (let i2 = 0; i2 < outsideEdges.length; i2++) {
    const edge = outsideEdges[i2];
    updateAttributesForNewEdge({
      edge,
      edgeIndex: i2,
      attributes,
      skirtHeight,
      newPosition,
      newTexcoord0,
      newTriangles
    });
  }
  attributes.POSITION.value = concatenateTypedArrays(attributes.POSITION.value, newPosition);
  attributes.TEXCOORD_0.value = concatenateTypedArrays(attributes.TEXCOORD_0.value, newTexcoord0);
  const resultTriangles = triangles instanceof Array ? triangles.concat(newTriangles) : concatenateTypedArrays(triangles, newTriangles);
  return {
    attributes,
    triangles: resultTriangles
  };
}
function getOutsideEdgesFromTriangles(triangles) {
  const edges = [];
  for (let i2 = 0; i2 < triangles.length; i2 += 3) {
    edges.push([triangles[i2], triangles[i2 + 1]]);
    edges.push([triangles[i2 + 1], triangles[i2 + 2]]);
    edges.push([triangles[i2 + 2], triangles[i2]]);
  }
  edges.sort((a, b) => Math.min(...a) - Math.min(...b) || Math.max(...a) - Math.max(...b));
  const outsideEdges = [];
  let index = 0;
  while (index < edges.length) {
    var _edges, _edges2;
    if (edges[index][0] === ((_edges = edges[index + 1]) === null || _edges === void 0 ? void 0 : _edges[1]) && edges[index][1] === ((_edges2 = edges[index + 1]) === null || _edges2 === void 0 ? void 0 : _edges2[0])) {
      index += 2;
    } else {
      outsideEdges.push(edges[index]);
      index++;
    }
  }
  return outsideEdges;
}
function getOutsideEdgesFromIndices(indices, position) {
  indices.westIndices.sort((a, b) => position[3 * a + 1] - position[3 * b + 1]);
  indices.eastIndices.sort((a, b) => position[3 * b + 1] - position[3 * a + 1]);
  indices.southIndices.sort((a, b) => position[3 * b] - position[3 * a]);
  indices.northIndices.sort((a, b) => position[3 * a] - position[3 * b]);
  const edges = [];
  for (const index in indices) {
    const indexGroup = indices[index];
    for (let i2 = 0; i2 < indexGroup.length - 1; i2++) {
      edges.push([indexGroup[i2], indexGroup[i2 + 1]]);
    }
  }
  return edges;
}
function updateAttributesForNewEdge(_ref) {
  let {
    edge,
    edgeIndex,
    attributes,
    skirtHeight,
    newPosition,
    newTexcoord0,
    newTriangles
  } = _ref;
  const positionsLength = attributes.POSITION.value.length;
  const vertex1Offset = edgeIndex * 2;
  const vertex2Offset = edgeIndex * 2 + 1;
  newPosition.set(attributes.POSITION.value.subarray(edge[0] * 3, edge[0] * 3 + 3), vertex1Offset * 3);
  newPosition[vertex1Offset * 3 + 2] = newPosition[vertex1Offset * 3 + 2] - skirtHeight;
  newPosition.set(attributes.POSITION.value.subarray(edge[1] * 3, edge[1] * 3 + 3), vertex2Offset * 3);
  newPosition[vertex2Offset * 3 + 2] = newPosition[vertex2Offset * 3 + 2] - skirtHeight;
  newTexcoord0.set(attributes.TEXCOORD_0.value.subarray(edge[0] * 2, edge[0] * 2 + 2), vertex1Offset * 2);
  newTexcoord0.set(attributes.TEXCOORD_0.value.subarray(edge[1] * 2, edge[1] * 2 + 2), vertex2Offset * 2);
  const triangle1Offset = edgeIndex * 2 * 3;
  newTriangles[triangle1Offset] = edge[0];
  newTriangles[triangle1Offset + 1] = positionsLength / 3 + vertex2Offset;
  newTriangles[triangle1Offset + 2] = edge[1];
  newTriangles[triangle1Offset + 3] = positionsLength / 3 + vertex2Offset;
  newTriangles[triangle1Offset + 4] = edge[0];
  newTriangles[triangle1Offset + 5] = positionsLength / 3 + vertex1Offset;
}

// node_modules/@loaders.gl/terrain/dist/esm/lib/parse-quantized-mesh.js
function getMeshAttributes(vertexData, header, bounds) {
  const {
    minHeight,
    maxHeight
  } = header;
  const [minX, minY, maxX, maxY] = bounds || [0, 0, 1, 1];
  const xScale = maxX - minX;
  const yScale = maxY - minY;
  const zScale = maxHeight - minHeight;
  const nCoords = vertexData.length / 3;
  const positions = new Float32Array(nCoords * 3);
  const texCoords = new Float32Array(nCoords * 2);
  for (let i2 = 0; i2 < nCoords; i2++) {
    const x2 = vertexData[i2] / 32767;
    const y2 = vertexData[i2 + nCoords] / 32767;
    const z = vertexData[i2 + nCoords * 2] / 32767;
    positions[3 * i2 + 0] = x2 * xScale + minX;
    positions[3 * i2 + 1] = y2 * yScale + minY;
    positions[3 * i2 + 2] = z * zScale + minHeight;
    texCoords[2 * i2 + 0] = x2;
    texCoords[2 * i2 + 1] = y2;
  }
  return {
    POSITION: {
      value: positions,
      size: 3
    },
    TEXCOORD_0: {
      value: texCoords,
      size: 2
    }
  };
}
function getTileMesh(arrayBuffer, options) {
  if (!arrayBuffer) {
    return null;
  }
  const {
    bounds
  } = options;
  const {
    header,
    vertexData,
    triangleIndices: originalTriangleIndices,
    westIndices,
    northIndices,
    eastIndices,
    southIndices
  } = decode(arrayBuffer, DECODING_STEPS.triangleIndices);
  let triangleIndices = originalTriangleIndices;
  let attributes = getMeshAttributes(vertexData, header, bounds);
  const boundingBox = getMeshBoundingBox(attributes);
  if (options.skirtHeight) {
    const {
      attributes: newAttributes,
      triangles: newTriangles
    } = addSkirt(attributes, triangleIndices, options.skirtHeight, {
      westIndices,
      northIndices,
      eastIndices,
      southIndices
    });
    attributes = newAttributes;
    triangleIndices = newTriangles;
  }
  return {
    loaderData: {
      header: {}
    },
    header: {
      vertexCount: triangleIndices.length,
      boundingBox
    },
    mode: 4,
    indices: {
      value: triangleIndices,
      size: 1
    },
    attributes
  };
}
function loadQuantizedMesh(arrayBuffer, options) {
  return getTileMesh(arrayBuffer, options["quantized-mesh"]);
}

// node_modules/@mapbox/martini/index.js
var Martini = class {
  constructor(gridSize = 257) {
    this.gridSize = gridSize;
    const tileSize = gridSize - 1;
    if (tileSize & tileSize - 1)
      throw new Error(
        `Expected grid size to be 2^n+1, got ${gridSize}.`
      );
    this.numTriangles = tileSize * tileSize * 2 - 2;
    this.numParentTriangles = this.numTriangles - tileSize * tileSize;
    this.indices = new Uint32Array(this.gridSize * this.gridSize);
    this.coords = new Uint16Array(this.numTriangles * 4);
    for (let i2 = 0; i2 < this.numTriangles; i2++) {
      let id = i2 + 2;
      let ax = 0, ay = 0, bx = 0, by = 0, cx = 0, cy = 0;
      if (id & 1) {
        bx = by = cx = tileSize;
      } else {
        ax = ay = cy = tileSize;
      }
      while ((id >>= 1) > 1) {
        const mx = ax + bx >> 1;
        const my = ay + by >> 1;
        if (id & 1) {
          bx = ax;
          by = ay;
          ax = cx;
          ay = cy;
        } else {
          ax = bx;
          ay = by;
          bx = cx;
          by = cy;
        }
        cx = mx;
        cy = my;
      }
      const k = i2 * 4;
      this.coords[k + 0] = ax;
      this.coords[k + 1] = ay;
      this.coords[k + 2] = bx;
      this.coords[k + 3] = by;
    }
  }
  createTile(terrain) {
    return new Tile(terrain, this);
  }
};
var Tile = class {
  constructor(terrain, martini) {
    const size = martini.gridSize;
    if (terrain.length !== size * size)
      throw new Error(
        `Expected terrain data of length ${size * size} (${size} x ${size}), got ${terrain.length}.`
      );
    this.terrain = terrain;
    this.martini = martini;
    this.errors = new Float32Array(terrain.length);
    this.update();
  }
  update() {
    const { numTriangles, numParentTriangles, coords, gridSize: size } = this.martini;
    const { terrain, errors } = this;
    for (let i2 = numTriangles - 1; i2 >= 0; i2--) {
      const k = i2 * 4;
      const ax = coords[k + 0];
      const ay = coords[k + 1];
      const bx = coords[k + 2];
      const by = coords[k + 3];
      const mx = ax + bx >> 1;
      const my = ay + by >> 1;
      const cx = mx + my - ay;
      const cy = my + ax - mx;
      const interpolatedHeight = (terrain[ay * size + ax] + terrain[by * size + bx]) / 2;
      const middleIndex = my * size + mx;
      const middleError = Math.abs(interpolatedHeight - terrain[middleIndex]);
      errors[middleIndex] = Math.max(errors[middleIndex], middleError);
      if (i2 < numParentTriangles) {
        const leftChildIndex = (ay + cy >> 1) * size + (ax + cx >> 1);
        const rightChildIndex = (by + cy >> 1) * size + (bx + cx >> 1);
        errors[middleIndex] = Math.max(errors[middleIndex], errors[leftChildIndex], errors[rightChildIndex]);
      }
    }
  }
  getMesh(maxError = 0) {
    const { gridSize: size, indices } = this.martini;
    const { errors } = this;
    let numVertices = 0;
    let numTriangles = 0;
    const max = size - 1;
    indices.fill(0);
    function countElements(ax, ay, bx, by, cx, cy) {
      const mx = ax + bx >> 1;
      const my = ay + by >> 1;
      if (Math.abs(ax - cx) + Math.abs(ay - cy) > 1 && errors[my * size + mx] > maxError) {
        countElements(cx, cy, ax, ay, mx, my);
        countElements(bx, by, cx, cy, mx, my);
      } else {
        indices[ay * size + ax] = indices[ay * size + ax] || ++numVertices;
        indices[by * size + bx] = indices[by * size + bx] || ++numVertices;
        indices[cy * size + cx] = indices[cy * size + cx] || ++numVertices;
        numTriangles++;
      }
    }
    countElements(0, 0, max, max, max, 0);
    countElements(max, max, 0, 0, 0, max);
    const vertices = new Uint16Array(numVertices * 2);
    const triangles = new Uint32Array(numTriangles * 3);
    let triIndex = 0;
    function processTriangle(ax, ay, bx, by, cx, cy) {
      const mx = ax + bx >> 1;
      const my = ay + by >> 1;
      if (Math.abs(ax - cx) + Math.abs(ay - cy) > 1 && errors[my * size + mx] > maxError) {
        processTriangle(cx, cy, ax, ay, mx, my);
        processTriangle(bx, by, cx, cy, mx, my);
      } else {
        const a = indices[ay * size + ax] - 1;
        const b = indices[by * size + bx] - 1;
        const c = indices[cy * size + cx] - 1;
        vertices[2 * a] = ax;
        vertices[2 * a + 1] = ay;
        vertices[2 * b] = bx;
        vertices[2 * b + 1] = by;
        vertices[2 * c] = cx;
        vertices[2 * c + 1] = cy;
        triangles[triIndex++] = a;
        triangles[triIndex++] = b;
        triangles[triIndex++] = c;
      }
    }
    processTriangle(0, 0, max, max, max, 0);
    processTriangle(max, max, 0, 0, 0, max);
    return { vertices, triangles };
  }
};

// node_modules/@loaders.gl/terrain/dist/esm/lib/delatin/index.js
var Delatin = class {
  constructor(data, width) {
    let height = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : width;
    this.data = data;
    this.width = width;
    this.height = height;
    this.coords = [];
    this.triangles = [];
    this._halfedges = [];
    this._candidates = [];
    this._queueIndices = [];
    this._queue = [];
    this._errors = [];
    this._rms = [];
    this._pending = [];
    this._pendingLen = 0;
    this._rmsSum = 0;
    const x1 = width - 1;
    const y1 = height - 1;
    const p0 = this._addPoint(0, 0);
    const p1 = this._addPoint(x1, 0);
    const p2 = this._addPoint(0, y1);
    const p3 = this._addPoint(x1, y1);
    const t0 = this._addTriangle(p3, p0, p2, -1, -1, -1);
    this._addTriangle(p0, p3, p1, t0, -1, -1);
    this._flush();
  }
  run() {
    let maxError = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
    while (this.getMaxError() > maxError) {
      this.refine();
    }
  }
  refine() {
    this._step();
    this._flush();
  }
  getMaxError() {
    return this._errors[0];
  }
  getRMSD() {
    return this._rmsSum > 0 ? Math.sqrt(this._rmsSum / (this.width * this.height)) : 0;
  }
  heightAt(x2, y2) {
    return this.data[this.width * y2 + x2];
  }
  _flush() {
    const coords = this.coords;
    for (let i2 = 0; i2 < this._pendingLen; i2++) {
      const t = this._pending[i2];
      const a = 2 * this.triangles[t * 3 + 0];
      const b = 2 * this.triangles[t * 3 + 1];
      const c = 2 * this.triangles[t * 3 + 2];
      this._findCandidate(coords[a], coords[a + 1], coords[b], coords[b + 1], coords[c], coords[c + 1], t);
    }
    this._pendingLen = 0;
  }
  _findCandidate(p0x, p0y, p1x, p1y, p2x, p2y, t) {
    const minX = Math.min(p0x, p1x, p2x);
    const minY = Math.min(p0y, p1y, p2y);
    const maxX = Math.max(p0x, p1x, p2x);
    const maxY = Math.max(p0y, p1y, p2y);
    let w00 = orient(p1x, p1y, p2x, p2y, minX, minY);
    let w01 = orient(p2x, p2y, p0x, p0y, minX, minY);
    let w02 = orient(p0x, p0y, p1x, p1y, minX, minY);
    const a01 = p1y - p0y;
    const b01 = p0x - p1x;
    const a12 = p2y - p1y;
    const b12 = p1x - p2x;
    const a20 = p0y - p2y;
    const b20 = p2x - p0x;
    const a = orient(p0x, p0y, p1x, p1y, p2x, p2y);
    const z0 = this.heightAt(p0x, p0y) / a;
    const z1 = this.heightAt(p1x, p1y) / a;
    const z2 = this.heightAt(p2x, p2y) / a;
    let maxError = 0;
    let mx = 0;
    let my = 0;
    let rms = 0;
    for (let y2 = minY; y2 <= maxY; y2++) {
      let dx = 0;
      if (w00 < 0 && a12 !== 0) {
        dx = Math.max(dx, Math.floor(-w00 / a12));
      }
      if (w01 < 0 && a20 !== 0) {
        dx = Math.max(dx, Math.floor(-w01 / a20));
      }
      if (w02 < 0 && a01 !== 0) {
        dx = Math.max(dx, Math.floor(-w02 / a01));
      }
      let w0 = w00 + a12 * dx;
      let w1 = w01 + a20 * dx;
      let w2 = w02 + a01 * dx;
      let wasInside = false;
      for (let x2 = minX + dx; x2 <= maxX; x2++) {
        if (w0 >= 0 && w1 >= 0 && w2 >= 0) {
          wasInside = true;
          const z = z0 * w0 + z1 * w1 + z2 * w2;
          const dz = Math.abs(z - this.heightAt(x2, y2));
          rms += dz * dz;
          if (dz > maxError) {
            maxError = dz;
            mx = x2;
            my = y2;
          }
        } else if (wasInside) {
          break;
        }
        w0 += a12;
        w1 += a20;
        w2 += a01;
      }
      w00 += b12;
      w01 += b20;
      w02 += b01;
    }
    if (mx === p0x && my === p0y || mx === p1x && my === p1y || mx === p2x && my === p2y) {
      maxError = 0;
    }
    this._candidates[2 * t] = mx;
    this._candidates[2 * t + 1] = my;
    this._rms[t] = rms;
    this._queuePush(t, maxError, rms);
  }
  _step() {
    const t = this._queuePop();
    const e0 = t * 3 + 0;
    const e1 = t * 3 + 1;
    const e2 = t * 3 + 2;
    const p0 = this.triangles[e0];
    const p1 = this.triangles[e1];
    const p2 = this.triangles[e2];
    const ax = this.coords[2 * p0];
    const ay = this.coords[2 * p0 + 1];
    const bx = this.coords[2 * p1];
    const by = this.coords[2 * p1 + 1];
    const cx = this.coords[2 * p2];
    const cy = this.coords[2 * p2 + 1];
    const px = this._candidates[2 * t];
    const py = this._candidates[2 * t + 1];
    const pn = this._addPoint(px, py);
    if (orient(ax, ay, bx, by, px, py) === 0) {
      this._handleCollinear(pn, e0);
    } else if (orient(bx, by, cx, cy, px, py) === 0) {
      this._handleCollinear(pn, e1);
    } else if (orient(cx, cy, ax, ay, px, py) === 0) {
      this._handleCollinear(pn, e2);
    } else {
      const h0 = this._halfedges[e0];
      const h1 = this._halfedges[e1];
      const h2 = this._halfedges[e2];
      const t0 = this._addTriangle(p0, p1, pn, h0, -1, -1, e0);
      const t1 = this._addTriangle(p1, p2, pn, h1, -1, t0 + 1);
      const t2 = this._addTriangle(p2, p0, pn, h2, t0 + 2, t1 + 1);
      this._legalize(t0);
      this._legalize(t1);
      this._legalize(t2);
    }
  }
  _addPoint(x2, y2) {
    const i2 = this.coords.length >> 1;
    this.coords.push(x2, y2);
    return i2;
  }
  _addTriangle(a, b, c, ab, bc, ca) {
    let e = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : this.triangles.length;
    const t = e / 3;
    this.triangles[e + 0] = a;
    this.triangles[e + 1] = b;
    this.triangles[e + 2] = c;
    this._halfedges[e + 0] = ab;
    this._halfedges[e + 1] = bc;
    this._halfedges[e + 2] = ca;
    if (ab >= 0) {
      this._halfedges[ab] = e + 0;
    }
    if (bc >= 0) {
      this._halfedges[bc] = e + 1;
    }
    if (ca >= 0) {
      this._halfedges[ca] = e + 2;
    }
    this._candidates[2 * t + 0] = 0;
    this._candidates[2 * t + 1] = 0;
    this._queueIndices[t] = -1;
    this._rms[t] = 0;
    this._pending[this._pendingLen++] = t;
    return e;
  }
  _legalize(a) {
    const b = this._halfedges[a];
    if (b < 0) {
      return;
    }
    const a0 = a - a % 3;
    const b0 = b - b % 3;
    const al = a0 + (a + 1) % 3;
    const ar = a0 + (a + 2) % 3;
    const bl = b0 + (b + 2) % 3;
    const br = b0 + (b + 1) % 3;
    const p0 = this.triangles[ar];
    const pr = this.triangles[a];
    const pl = this.triangles[al];
    const p1 = this.triangles[bl];
    const coords = this.coords;
    if (!inCircle(coords[2 * p0], coords[2 * p0 + 1], coords[2 * pr], coords[2 * pr + 1], coords[2 * pl], coords[2 * pl + 1], coords[2 * p1], coords[2 * p1 + 1])) {
      return;
    }
    const hal = this._halfedges[al];
    const har = this._halfedges[ar];
    const hbl = this._halfedges[bl];
    const hbr = this._halfedges[br];
    this._queueRemove(a0 / 3);
    this._queueRemove(b0 / 3);
    const t0 = this._addTriangle(p0, p1, pl, -1, hbl, hal, a0);
    const t1 = this._addTriangle(p1, p0, pr, t0, har, hbr, b0);
    this._legalize(t0 + 1);
    this._legalize(t1 + 2);
  }
  _handleCollinear(pn, a) {
    const a0 = a - a % 3;
    const al = a0 + (a + 1) % 3;
    const ar = a0 + (a + 2) % 3;
    const p0 = this.triangles[ar];
    const pr = this.triangles[a];
    const pl = this.triangles[al];
    const hal = this._halfedges[al];
    const har = this._halfedges[ar];
    const b = this._halfedges[a];
    if (b < 0) {
      const t02 = this._addTriangle(pn, p0, pr, -1, har, -1, a0);
      const t12 = this._addTriangle(p0, pn, pl, t02, -1, hal);
      this._legalize(t02 + 1);
      this._legalize(t12 + 2);
      return;
    }
    const b0 = b - b % 3;
    const bl = b0 + (b + 2) % 3;
    const br = b0 + (b + 1) % 3;
    const p1 = this.triangles[bl];
    const hbl = this._halfedges[bl];
    const hbr = this._halfedges[br];
    this._queueRemove(b0 / 3);
    const t0 = this._addTriangle(p0, pr, pn, har, -1, -1, a0);
    const t1 = this._addTriangle(pr, p1, pn, hbr, -1, t0 + 1, b0);
    const t2 = this._addTriangle(p1, pl, pn, hbl, -1, t1 + 1);
    const t3 = this._addTriangle(pl, p0, pn, hal, t0 + 2, t2 + 1);
    this._legalize(t0);
    this._legalize(t1);
    this._legalize(t2);
    this._legalize(t3);
  }
  _queuePush(t, error, rms) {
    const i2 = this._queue.length;
    this._queueIndices[t] = i2;
    this._queue.push(t);
    this._errors.push(error);
    this._rmsSum += rms;
    this._queueUp(i2);
  }
  _queuePop() {
    const n = this._queue.length - 1;
    this._queueSwap(0, n);
    this._queueDown(0, n);
    return this._queuePopBack();
  }
  _queuePopBack() {
    const t = this._queue.pop();
    this._errors.pop();
    this._rmsSum -= this._rms[t];
    this._queueIndices[t] = -1;
    return t;
  }
  _queueRemove(t) {
    const i2 = this._queueIndices[t];
    if (i2 < 0) {
      const it = this._pending.indexOf(t);
      if (it !== -1) {
        this._pending[it] = this._pending[--this._pendingLen];
      } else {
        throw new Error("Broken triangulation (something went wrong).");
      }
      return;
    }
    const n = this._queue.length - 1;
    if (n !== i2) {
      this._queueSwap(i2, n);
      if (!this._queueDown(i2, n)) {
        this._queueUp(i2);
      }
    }
    this._queuePopBack();
  }
  _queueLess(i2, j) {
    return this._errors[i2] > this._errors[j];
  }
  _queueSwap(i2, j) {
    const pi = this._queue[i2];
    const pj = this._queue[j];
    this._queue[i2] = pj;
    this._queue[j] = pi;
    this._queueIndices[pi] = j;
    this._queueIndices[pj] = i2;
    const e = this._errors[i2];
    this._errors[i2] = this._errors[j];
    this._errors[j] = e;
  }
  _queueUp(j0) {
    let j = j0;
    while (true) {
      const i2 = j - 1 >> 1;
      if (i2 === j || !this._queueLess(j, i2)) {
        break;
      }
      this._queueSwap(i2, j);
      j = i2;
    }
  }
  _queueDown(i0, n) {
    let i2 = i0;
    while (true) {
      const j1 = 2 * i2 + 1;
      if (j1 >= n || j1 < 0) {
        break;
      }
      const j2 = j1 + 1;
      let j = j1;
      if (j2 < n && this._queueLess(j2, j1)) {
        j = j2;
      }
      if (!this._queueLess(j, i2)) {
        break;
      }
      this._queueSwap(i2, j);
      i2 = j;
    }
    return i2 > i0;
  }
};
function orient(ax, ay, bx, by, cx, cy) {
  return (bx - cx) * (ay - cy) - (by - cy) * (ax - cx);
}
function inCircle(ax, ay, bx, by, cx, cy, px, py) {
  const dx = ax - px;
  const dy = ay - py;
  const ex = bx - px;
  const ey = by - py;
  const fx = cx - px;
  const fy = cy - py;
  const ap = dx * dx + dy * dy;
  const bp = ex * ex + ey * ey;
  const cp = fx * fx + fy * fy;
  return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0;
}

// node_modules/@loaders.gl/terrain/dist/esm/lib/parse-terrain.js
function getTerrain(imageData, width, height, elevationDecoder, tesselator) {
  const {
    rScaler,
    bScaler,
    gScaler,
    offset
  } = elevationDecoder;
  const terrain = new Float32Array((width + 1) * (height + 1));
  for (let i2 = 0, y2 = 0; y2 < height; y2++) {
    for (let x2 = 0; x2 < width; x2++, i2++) {
      const k = i2 * 4;
      const r = imageData[k + 0];
      const g = imageData[k + 1];
      const b = imageData[k + 2];
      terrain[i2 + y2] = r * rScaler + g * gScaler + b * bScaler + offset;
    }
  }
  if (tesselator === "martini") {
    for (let i2 = (width + 1) * width, x2 = 0; x2 < width; x2++, i2++) {
      terrain[i2] = terrain[i2 - width - 1];
    }
    for (let i2 = height, y2 = 0; y2 < height + 1; y2++, i2 += height + 1) {
      terrain[i2] = terrain[i2 - 1];
    }
  }
  return terrain;
}
function getMeshAttributes2(vertices, terrain, width, height, bounds) {
  const gridSize = width + 1;
  const numOfVerticies = vertices.length / 2;
  const positions = new Float32Array(numOfVerticies * 3);
  const texCoords = new Float32Array(numOfVerticies * 2);
  const [minX, minY, maxX, maxY] = bounds || [0, 0, width, height];
  const xScale = (maxX - minX) / width;
  const yScale = (maxY - minY) / height;
  for (let i2 = 0; i2 < numOfVerticies; i2++) {
    const x2 = vertices[i2 * 2];
    const y2 = vertices[i2 * 2 + 1];
    const pixelIdx = y2 * gridSize + x2;
    positions[3 * i2 + 0] = x2 * xScale + minX;
    positions[3 * i2 + 1] = -y2 * yScale + maxY;
    positions[3 * i2 + 2] = terrain[pixelIdx];
    texCoords[2 * i2 + 0] = x2 / width;
    texCoords[2 * i2 + 1] = y2 / height;
  }
  return {
    POSITION: {
      value: positions,
      size: 3
    },
    TEXCOORD_0: {
      value: texCoords,
      size: 2
    }
  };
}
function getMesh(terrainImage, terrainOptions) {
  if (terrainImage === null) {
    return null;
  }
  const {
    meshMaxError,
    bounds,
    elevationDecoder
  } = terrainOptions;
  const {
    data,
    width,
    height
  } = terrainImage;
  let terrain;
  let mesh;
  switch (terrainOptions.tesselator) {
    case "martini":
      terrain = getTerrain(data, width, height, elevationDecoder, terrainOptions.tesselator);
      mesh = getMartiniTileMesh(meshMaxError, width, terrain);
      break;
    case "delatin":
      terrain = getTerrain(data, width, height, elevationDecoder, terrainOptions.tesselator);
      mesh = getDelatinTileMesh(meshMaxError, width, height, terrain);
      break;
    default:
      if (width === height && !(height & width - 1)) {
        terrain = getTerrain(data, width, height, elevationDecoder, "martini");
        mesh = getMartiniTileMesh(meshMaxError, width, terrain);
      } else {
        terrain = getTerrain(data, width, height, elevationDecoder, "delatin");
        mesh = getDelatinTileMesh(meshMaxError, width, height, terrain);
      }
      break;
  }
  const {
    vertices
  } = mesh;
  let {
    triangles
  } = mesh;
  let attributes = getMeshAttributes2(vertices, terrain, width, height, bounds);
  const boundingBox = getMeshBoundingBox(attributes);
  if (terrainOptions.skirtHeight) {
    const {
      attributes: newAttributes,
      triangles: newTriangles
    } = addSkirt(attributes, triangles, terrainOptions.skirtHeight);
    attributes = newAttributes;
    triangles = newTriangles;
  }
  return {
    loaderData: {
      header: {}
    },
    header: {
      vertexCount: triangles.length,
      boundingBox
    },
    mode: 4,
    indices: {
      value: Uint32Array.from(triangles),
      size: 1
    },
    attributes
  };
}
function getMartiniTileMesh(meshMaxError, width, terrain) {
  const gridSize = width + 1;
  const martini = new Martini(gridSize);
  const tile = martini.createTile(terrain);
  const {
    vertices,
    triangles
  } = tile.getMesh(meshMaxError);
  return {
    vertices,
    triangles
  };
}
function getDelatinTileMesh(meshMaxError, width, height, terrain) {
  const tin = new Delatin(terrain, width + 1, height + 1);
  tin.run(meshMaxError);
  const {
    coords,
    triangles
  } = tin;
  const vertices = coords;
  return {
    vertices,
    triangles
  };
}
async function loadTerrain(arrayBuffer, options, context) {
  const loadImageOptions = {
    ...options,
    mimeType: "application/x.image",
    image: {
      ...options.image,
      type: "data"
    }
  };
  const image = await context.parse(arrayBuffer, loadImageOptions);
  return getMesh(image, options.terrain);
}

// node_modules/@loaders.gl/terrain/dist/esm/lib/utils/version.js
var VERSION7 = true ? "3.4.9" : "latest";

// node_modules/@loaders.gl/terrain/dist/esm/terrain-loader.js
var TerrainLoader = {
  name: "Terrain",
  id: "terrain",
  module: "terrain",
  version: VERSION7,
  worker: true,
  extensions: ["png", "pngraw", "jpg", "jpeg", "gif", "webp", "bmp"],
  mimeTypes: ["image/png", "image/jpeg", "image/gif", "image/webp", "image/bmp"],
  options: {
    terrain: {
      tesselator: "auto",
      bounds: null,
      meshMaxError: 10,
      elevationDecoder: {
        rScaler: 1,
        gScaler: 0,
        bScaler: 0,
        offset: 0
      },
      skirtHeight: null
    }
  }
};

// node_modules/@loaders.gl/terrain/dist/esm/quantized-mesh-loader.js
var QuantizedMeshLoader = {
  name: "Quantized Mesh",
  id: "quantized-mesh",
  module: "terrain",
  version: VERSION7,
  worker: true,
  extensions: ["terrain"],
  mimeTypes: ["application/vnd.quantized-mesh"],
  options: {
    "quantized-mesh": {
      bounds: [0, 0, 1, 1],
      skirtHeight: null
    }
  }
};

// node_modules/@loaders.gl/terrain/dist/esm/index.js
var TerrainLoader2 = {
  ...TerrainLoader,
  parse: loadTerrain
};
var QuantizedMeshLoader2 = {
  ...QuantizedMeshLoader,
  parseSync: loadQuantizedMesh,
  parse: async (arrayBuffer, options) => loadQuantizedMesh(arrayBuffer, options)
};

// node_modules/@deck.gl/geo-layers/dist/esm/terrain-layer/terrain-layer.js
var DUMMY_DATA = [1];
var defaultProps14 = {
  ...TileLayer.defaultProps,
  elevationData: urlType,
  texture: {
    ...urlType,
    optional: true
  },
  meshMaxError: {
    type: "number",
    value: 4
  },
  bounds: {
    type: "array",
    value: null,
    optional: true,
    compare: true
  },
  color: {
    type: "color",
    value: [255, 255, 255]
  },
  elevationDecoder: {
    type: "object",
    value: {
      rScaler: 1,
      gScaler: 0,
      bScaler: 0,
      offset: 0
    }
  },
  workerUrl: "",
  wireframe: false,
  material: true,
  loaders: [TerrainLoader]
};
function urlTemplateToUpdateTrigger(template) {
  if (Array.isArray(template)) {
    return template.join(";");
  }
  return template || "";
}
var TerrainLayer = class extends CompositeLayer {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "state", void 0);
  }
  updateState({
    props,
    oldProps
  }) {
    const elevationDataChanged = props.elevationData !== oldProps.elevationData;
    if (elevationDataChanged) {
      const {
        elevationData
      } = props;
      const isTiled = elevationData && (Array.isArray(elevationData) || elevationData.includes("{x}") && elevationData.includes("{y}"));
      this.setState({
        isTiled
      });
    }
    const shouldReload = elevationDataChanged || props.meshMaxError !== oldProps.meshMaxError || props.elevationDecoder !== oldProps.elevationDecoder || props.bounds !== oldProps.bounds;
    if (!this.state.isTiled && shouldReload) {
      const terrain = this.loadTerrain(props);
      this.setState({
        terrain
      });
    }
    if (props.workerUrl) {
      log_default.removed("workerUrl", "loadOptions.terrain.workerUrl")();
    }
  }
  loadTerrain({
    elevationData,
    bounds,
    elevationDecoder,
    meshMaxError,
    signal
  }) {
    var _loadOptions;
    if (!elevationData) {
      return null;
    }
    let loadOptions = this.getLoadOptions();
    loadOptions = {
      ...loadOptions,
      terrain: {
        skirtHeight: this.state.isTiled ? meshMaxError * 2 : 0,
        ...(_loadOptions = loadOptions) === null || _loadOptions === void 0 ? void 0 : _loadOptions.terrain,
        bounds,
        meshMaxError,
        elevationDecoder
      }
    };
    const {
      fetch: fetch2
    } = this.props;
    return fetch2(elevationData, {
      propName: "elevationData",
      layer: this,
      loadOptions,
      signal
    });
  }
  getTiledTerrainData(tile) {
    const {
      elevationData,
      fetch: fetch2,
      texture,
      elevationDecoder,
      meshMaxError
    } = this.props;
    const {
      viewport
    } = this.context;
    const dataUrl = getURLFromTemplate(elevationData, tile);
    const textureUrl = texture && getURLFromTemplate(texture, tile);
    const {
      signal
    } = tile;
    let bottomLeft = [0, 0];
    let topRight = [0, 0];
    if (viewport.isGeospatial) {
      const bbox = tile.bbox;
      bottomLeft = viewport.projectFlat([bbox.west, bbox.south]);
      topRight = viewport.projectFlat([bbox.east, bbox.north]);
    } else {
      const bbox = tile.bbox;
      bottomLeft = [bbox.left, bbox.bottom];
      topRight = [bbox.right, bbox.top];
    }
    const bounds = [bottomLeft[0], bottomLeft[1], topRight[0], topRight[1]];
    const terrain = this.loadTerrain({
      elevationData: dataUrl,
      bounds,
      elevationDecoder,
      meshMaxError,
      signal
    });
    const surface = textureUrl ? fetch2(textureUrl, {
      propName: "texture",
      layer: this,
      loaders: [],
      signal
    }).catch((_) => null) : Promise.resolve(null);
    return Promise.all([terrain, surface]);
  }
  renderSubLayers(props) {
    const SubLayerClass = this.getSubLayerClass("mesh", SimpleMeshLayer);
    const {
      color,
      wireframe,
      material
    } = this.props;
    const {
      data
    } = props;
    if (!data) {
      return null;
    }
    const [mesh, texture] = data;
    return new SubLayerClass(props, {
      data: DUMMY_DATA,
      mesh,
      texture,
      _instanced: false,
      coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,
      getPosition: (d) => [0, 0, 0],
      getColor: color,
      wireframe,
      material
    });
  }
  onViewportLoad(tiles) {
    if (!tiles) {
      return;
    }
    const {
      zRange
    } = this.state;
    const ranges = tiles.map((tile) => tile.content).filter(Boolean).map((arr) => {
      const bounds = arr[0].header.boundingBox;
      return bounds.map((bound) => bound[2]);
    });
    if (ranges.length === 0) {
      return;
    }
    const minZ = Math.min(...ranges.map((x2) => x2[0]));
    const maxZ = Math.max(...ranges.map((x2) => x2[1]));
    if (!zRange || minZ < zRange[0] || maxZ > zRange[1]) {
      this.setState({
        zRange: [minZ, maxZ]
      });
    }
  }
  renderLayers() {
    const {
      color,
      material,
      elevationData,
      texture,
      wireframe,
      meshMaxError,
      elevationDecoder,
      tileSize,
      maxZoom,
      minZoom,
      extent,
      maxRequests,
      onTileLoad,
      onTileUnload,
      onTileError,
      maxCacheSize,
      maxCacheByteSize,
      refinementStrategy
    } = this.props;
    if (this.state.isTiled) {
      return new TileLayer(this.getSubLayerProps({
        id: "tiles"
      }), {
        getTileData: this.getTiledTerrainData.bind(this),
        renderSubLayers: this.renderSubLayers.bind(this),
        updateTriggers: {
          getTileData: {
            elevationData: urlTemplateToUpdateTrigger(elevationData),
            texture: urlTemplateToUpdateTrigger(texture),
            meshMaxError,
            elevationDecoder
          }
        },
        onViewportLoad: this.onViewportLoad.bind(this),
        zRange: this.state.zRange || null,
        tileSize,
        maxZoom,
        minZoom,
        extent,
        maxRequests,
        onTileLoad,
        onTileUnload,
        onTileError,
        maxCacheSize,
        maxCacheByteSize,
        refinementStrategy
      });
    }
    const SubLayerClass = this.getSubLayerClass("mesh", SimpleMeshLayer);
    return new SubLayerClass(this.getSubLayerProps({
      id: "mesh"
    }), {
      data: DUMMY_DATA,
      mesh: this.state.terrain,
      texture,
      _instanced: false,
      getPosition: (d) => [0, 0, 0],
      getColor: color,
      material,
      wireframe
    });
  }
};
_defineProperty(TerrainLayer, "defaultProps", defaultProps14);
_defineProperty(TerrainLayer, "layerName", "TerrainLayer");

// node_modules/@deck.gl/extensions/dist/esm/brushing/shader-module.js
var vs2 = "\n  uniform bool brushing_enabled;\n  uniform int brushing_target;\n  uniform vec2 brushing_mousePos;\n  uniform float brushing_radius;\n\n  #ifdef NON_INSTANCED_MODEL\n  attribute vec2 brushingTargets;\n  #else\n  attribute vec2 instanceBrushingTargets;\n  #endif\n\n  varying float brushing_isVisible;\n\n  bool brushing_isPointInRange(vec2 position) {\n    if (!brushing_enabled) {\n      return true;\n    }\n    vec2 source_commonspace = project_position(position);\n    vec2 target_commonspace = project_position(brushing_mousePos);\n    float distance = length((target_commonspace - source_commonspace) / project_uCommonUnitsPerMeter.xy);\n\n    return distance <= brushing_radius;\n  }\n\n  bool brushing_arePointsInRange(vec2 sourcePos, vec2 targetPos) {\n    return brushing_isPointInRange(sourcePos) || brushing_isPointInRange(targetPos);\n  }\n\n  void brushing_setVisible(bool visible) {\n    brushing_isVisible = float(visible);\n  }\n";
var fs2 = "\n  uniform bool brushing_enabled;\n  varying float brushing_isVisible;\n";
var TARGET = {
  source: 0,
  target: 1,
  custom: 2,
  source_target: 3
};
var inject = {
  "vs:DECKGL_FILTER_GL_POSITION": "\n    vec2 brushingTarget;\n    vec2 brushingSource;\n    if (brushing_target == 3) {\n      brushingTarget = geometry.worldPositionAlt.xy;\n      brushingSource = geometry.worldPosition.xy;\n    } else if (brushing_target == 0) {\n      brushingTarget = geometry.worldPosition.xy;\n    } else if (brushing_target == 1) {\n      brushingTarget = geometry.worldPositionAlt.xy;\n    } else {\n      #ifdef NON_INSTANCED_MODEL\n      brushingTarget = brushingTargets;\n      #else\n      brushingTarget = instanceBrushingTargets;\n      #endif\n    }\n    bool visible;\n    if (brushing_target == 3) {\n      visible = brushing_arePointsInRange(brushingSource, brushingTarget);\n    } else {\n      visible = brushing_isPointInRange(brushingTarget);\n    }\n    brushing_setVisible(visible);\n  ",
  "fs:DECKGL_FILTER_COLOR": "\n    if (brushing_enabled && brushing_isVisible < 0.5) {\n      discard;\n    }\n  "
};
var shader_module_default = {
  name: "brushing",
  dependencies: [project_default],
  vs: vs2,
  fs: fs2,
  inject,
  getUniforms: (opts) => {
    if (!opts || !("viewport" in opts)) {
      return {};
    }
    const {
      brushingEnabled = true,
      brushingRadius = 1e4,
      brushingTarget = "source",
      mousePosition,
      viewport
    } = opts;
    return {
      brushing_enabled: Boolean(brushingEnabled && mousePosition && viewport.containsPixel(mousePosition)),
      brushing_radius: brushingRadius,
      brushing_target: TARGET[brushingTarget] || 0,
      brushing_mousePos: mousePosition ? viewport.unproject([mousePosition.x - viewport.x, mousePosition.y - viewport.y]) : [0, 0]
    };
  }
};

// node_modules/@deck.gl/extensions/dist/esm/brushing/brushing-extension.js
var defaultProps15 = {
  getBrushingTarget: {
    type: "accessor",
    value: [0, 0]
  },
  brushingTarget: "source",
  brushingEnabled: true,
  brushingRadius: 1e4
};
var BrushingExtension = class extends LayerExtension {
  getShaders() {
    return {
      modules: [shader_module_default]
    };
  }
  initializeState(context, extension) {
    const attributeManager = this.getAttributeManager();
    if (attributeManager) {
      attributeManager.add({
        brushingTargets: {
          size: 2,
          accessor: "getBrushingTarget",
          shaderAttributes: {
            brushingTargets: {
              divisor: 0
            },
            instanceBrushingTargets: {
              divisor: 1
            }
          }
        }
      });
    }
    this.state.onMouseMove = () => {
      var _this$getCurrentLayer;
      (_this$getCurrentLayer = this.getCurrentLayer()) === null || _this$getCurrentLayer === void 0 ? void 0 : _this$getCurrentLayer.setNeedsRedraw();
    };
    if (context.deck) {
      context.deck.eventManager.on({
        pointermove: this.state.onMouseMove,
        pointerleave: this.state.onMouseMove
      });
    }
  }
  finalizeState(context, extension) {
    if (context.deck) {
      context.deck.eventManager.off({
        pointermove: this.state.onMouseMove,
        pointerleave: this.state.onMouseMove
      });
    }
  }
};
_defineProperty(BrushingExtension, "defaultProps", defaultProps15);
_defineProperty(BrushingExtension, "extensionName", "BrushingExtension");

// node_modules/@deck.gl/extensions/dist/esm/data-filter/shader-module.js
var vs3 = "\nuniform DATAFILTER_TYPE filter_min;\nuniform DATAFILTER_TYPE filter_softMin;\nuniform DATAFILTER_TYPE filter_softMax;\nuniform DATAFILTER_TYPE filter_max;\nuniform bool filter_useSoftMargin;\nuniform bool filter_enabled;\nuniform bool filter_transformSize;\n\n#ifdef NON_INSTANCED_MODEL\n  #define DATAFILTER_ATTRIB filterValues\n  #define DATAFILTER_ATTRIB_64LOW filterValues64Low\n#else\n  #define DATAFILTER_ATTRIB instanceFilterValues\n  #define DATAFILTER_ATTRIB_64LOW instanceFilterValues64Low\n#endif\n\nattribute DATAFILTER_TYPE DATAFILTER_ATTRIB;\n#ifdef DATAFILTER_DOUBLE\n  attribute DATAFILTER_TYPE DATAFILTER_ATTRIB_64LOW;\n\n  uniform DATAFILTER_TYPE filter_min64High;\n  uniform DATAFILTER_TYPE filter_max64High;\n#endif\n\nvarying float dataFilter_value;\n\nfloat dataFilter_reduceValue(float value) {\n  return value;\n}\nfloat dataFilter_reduceValue(vec2 value) {\n  return min(value.x, value.y);\n}\nfloat dataFilter_reduceValue(vec3 value) {\n  return min(min(value.x, value.y), value.z);\n}\nfloat dataFilter_reduceValue(vec4 value) {\n  return min(min(value.x, value.y), min(value.z, value.w));\n}\nvoid dataFilter_setValue(DATAFILTER_TYPE valueFromMin, DATAFILTER_TYPE valueFromMax) {\n  if (filter_enabled) {\n    if (filter_useSoftMargin) {\n      dataFilter_value = dataFilter_reduceValue(\n        smoothstep(filter_min, filter_softMin, valueFromMin) *\n        (1.0 - smoothstep(filter_softMax, filter_max, valueFromMax))\n      );\n    } else {\n      dataFilter_value = dataFilter_reduceValue(\n        step(filter_min, valueFromMin) * step(valueFromMax, filter_max)\n      );\n    }\n  } else {\n    dataFilter_value = 1.0;\n  }\n}\n";
var fs3 = "\nuniform bool filter_transformColor;\nvarying float dataFilter_value;\n";
function getUniforms(opts) {
  if (!opts || !("extensions" in opts)) {
    return {};
  }
  const {
    filterRange = [-1, 1],
    filterEnabled = true,
    filterTransformSize = true,
    filterTransformColor = true
  } = opts;
  const filterSoftRange = opts.filterSoftRange || filterRange;
  return {
    ...Number.isFinite(filterRange[0]) ? {
      filter_min: filterRange[0],
      filter_softMin: filterSoftRange[0],
      filter_softMax: filterSoftRange[1],
      filter_max: filterRange[1]
    } : {
      filter_min: filterRange.map((r) => r[0]),
      filter_softMin: filterSoftRange.map((r) => r[0]),
      filter_softMax: filterSoftRange.map((r) => r[1]),
      filter_max: filterRange.map((r) => r[1])
    },
    filter_enabled: filterEnabled,
    filter_useSoftMargin: Boolean(opts.filterSoftRange),
    filter_transformSize: filterEnabled && filterTransformSize,
    filter_transformColor: filterEnabled && filterTransformColor
  };
}
function getUniforms64(opts) {
  if (!opts || !("extensions" in opts)) {
    return {};
  }
  const uniforms = getUniforms(opts);
  if (Number.isFinite(uniforms.filter_min)) {
    const min64High = Math.fround(uniforms.filter_min);
    uniforms.filter_min -= min64High;
    uniforms.filter_softMin -= min64High;
    uniforms.filter_min64High = min64High;
    const max64High = Math.fround(uniforms.filter_max);
    uniforms.filter_max -= max64High;
    uniforms.filter_softMax -= max64High;
    uniforms.filter_max64High = max64High;
  } else {
    const min64High = uniforms.filter_min.map(Math.fround);
    uniforms.filter_min = uniforms.filter_min.map((x2, i2) => x2 - min64High[i2]);
    uniforms.filter_softMin = uniforms.filter_softMin.map((x2, i2) => x2 - min64High[i2]);
    uniforms.filter_min64High = min64High;
    const max64High = uniforms.filter_max.map(Math.fround);
    uniforms.filter_max = uniforms.filter_max.map((x2, i2) => x2 - max64High[i2]);
    uniforms.filter_softMax = uniforms.filter_softMax.map((x2, i2) => x2 - max64High[i2]);
    uniforms.filter_max64High = max64High;
  }
  return uniforms;
}
var inject2 = {
  "vs:#main-start": "\n    #ifdef DATAFILTER_DOUBLE\n      dataFilter_setValue(\n        DATAFILTER_ATTRIB - filter_min64High + DATAFILTER_ATTRIB_64LOW,\n        DATAFILTER_ATTRIB - filter_max64High + DATAFILTER_ATTRIB_64LOW\n      );\n    #else\n      dataFilter_setValue(DATAFILTER_ATTRIB, DATAFILTER_ATTRIB);\n    #endif\n  ",
  "vs:#main-end": "\n    if (dataFilter_value == 0.0) {\n      gl_Position = vec4(0.);\n    }\n  ",
  "vs:DECKGL_FILTER_SIZE": "\n    if (filter_transformSize) {\n      size = size * dataFilter_value;\n    }\n  ",
  "fs:DECKGL_FILTER_COLOR": "\n    if (dataFilter_value == 0.0) discard;\n    if (filter_transformColor) {\n      color.a *= dataFilter_value;\n    }\n  "
};
var shaderModule = {
  name: "data-filter",
  vs: vs3,
  fs: fs3,
  inject: inject2,
  getUniforms
};
var shaderModule64 = {
  name: "data-filter-fp64",
  vs: vs3,
  fs: fs3,
  inject: inject2,
  getUniforms: getUniforms64
};

// node_modules/@deck.gl/extensions/dist/esm/data-filter/aggregator.js
var AGGREGATE_VS = "#define SHADER_NAME data-filter-vertex-shader\n\n#ifdef FLOAT_TARGET\n  attribute float filterIndices;\n  attribute float filterPrevIndices;\n#else\n  attribute vec2 filterIndices;\n  attribute vec2 filterPrevIndices;\n#endif\n\nvarying vec4 vColor;\nconst float component = 1.0 / 255.0;\n\nvoid main() {\n  #ifdef FLOAT_TARGET\n    dataFilter_value *= float(filterIndices != filterPrevIndices);\n    gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n    vColor = vec4(0.0, 0.0, 0.0, 1.0);\n  #else\n    // Float texture is not supported: pack result into 4 channels x 256 px x 64px\n    dataFilter_value *= float(filterIndices.x != filterPrevIndices.x);\n    float col = filterIndices.x;\n    float row = filterIndices.y * 4.0;\n    float channel = floor(row);\n    row = fract(row);\n    vColor = component * vec4(bvec4(channel == 0.0, channel == 1.0, channel == 2.0, channel == 3.0));\n    gl_Position = vec4(col * 2.0 - 1.0, row * 2.0 - 1.0, 0.0, 1.0);\n  #endif\n  gl_PointSize = 1.0;\n}\n";
var AGGREGATE_FS = "#define SHADER_NAME data-filter-fragment-shader\nprecision highp float;\n\nvarying vec4 vColor;\n\nvoid main() {\n  if (dataFilter_value < 0.5) {\n    discard;\n  }\n  gl_FragColor = vColor;\n}\n";
function supportsFloatTarget(gl) {
  return Boolean(gl.getExtension("EXT_float_blend") && (gl.getExtension("EXT_color_buffer_float") || gl.getExtension("WEBGL_color_buffer_float")));
}
function getFramebuffer(gl, useFloatTarget) {
  if (useFloatTarget) {
    return new Framebuffer(gl, {
      width: 1,
      height: 1,
      attachments: {
        [36064]: new Texture2D(gl, {
          format: isWebGL2(gl) ? 34836 : 6408,
          type: 5126,
          mipmaps: false
        })
      }
    });
  }
  return new Framebuffer(gl, {
    width: 256,
    height: 64,
    depth: false
  });
}
function getModel(gl, shaderOptions, useFloatTarget) {
  shaderOptions.defines.NON_INSTANCED_MODEL = 1;
  if (useFloatTarget) {
    shaderOptions.defines.FLOAT_TARGET = 1;
  }
  return new Model(gl, {
    id: "data-filter-aggregation-model",
    vertexCount: 1,
    isInstanced: false,
    drawMode: 0,
    vs: AGGREGATE_VS,
    fs: AGGREGATE_FS,
    ...shaderOptions
  });
}
var parameters = {
  blend: true,
  blendFunc: [1, 1, 1, 1],
  blendEquation: [32774, 32774],
  depthTest: false
};

// node_modules/@deck.gl/extensions/dist/esm/data-filter/data-filter-extension.js
var defaultProps16 = {
  getFilterValue: {
    type: "accessor",
    value: 0
  },
  onFilteredItemsChange: {
    type: "function",
    value: null,
    optional: true
  },
  filterEnabled: true,
  filterRange: [-1, 1],
  filterSoftRange: null,
  filterTransformSize: true,
  filterTransformColor: true
};
var DATA_TYPE_FROM_SIZE = {
  1: "float",
  2: "vec2",
  3: "vec3",
  4: "vec4"
};
var DataFilterExtension = class extends LayerExtension {
  constructor({
    filterSize = 1,
    fp64: fp642 = false,
    countItems = false
  } = {}) {
    if (!DATA_TYPE_FROM_SIZE[filterSize]) {
      throw new Error("filterSize out of range");
    }
    super({
      filterSize,
      fp64: fp642,
      countItems
    });
  }
  getShaders(extension) {
    const {
      filterSize,
      fp64: fp642
    } = extension.opts;
    return {
      modules: [fp642 ? shaderModule64 : shaderModule],
      defines: {
        DATAFILTER_TYPE: DATA_TYPE_FROM_SIZE[filterSize],
        DATAFILTER_DOUBLE: Boolean(fp642)
      }
    };
  }
  initializeState(context, extension) {
    const attributeManager = this.getAttributeManager();
    if (attributeManager) {
      attributeManager.add({
        filterValues: {
          size: extension.opts.filterSize,
          type: extension.opts.fp64 ? 5130 : 5126,
          accessor: "getFilterValue",
          shaderAttributes: {
            filterValues: {
              divisor: 0
            },
            instanceFilterValues: {
              divisor: 1
            }
          }
        }
      });
    }
    const {
      gl
    } = this.context;
    if (attributeManager && extension.opts.countItems) {
      const useFloatTarget = supportsFloatTarget(gl);
      attributeManager.add({
        filterIndices: {
          size: useFloatTarget ? 1 : 2,
          vertexOffset: 1,
          type: 5121,
          normalized: true,
          accessor: (object, {
            index
          }) => {
            const i2 = object && object.__source ? object.__source.index : index;
            return useFloatTarget ? (i2 + 1) % 255 : [(i2 + 1) % 255, Math.floor(i2 / 255) % 255];
          },
          shaderAttributes: {
            filterPrevIndices: {
              vertexOffset: 0
            },
            filterIndices: {
              vertexOffset: 1
            }
          }
        }
      });
      const filterFBO = getFramebuffer(gl, useFloatTarget);
      const filterModel = getModel(gl, extension.getShaders.call(this, extension), useFloatTarget);
      this.setState({
        filterFBO,
        filterModel
      });
    }
  }
  updateState({
    props,
    oldProps
  }) {
    if (this.state.filterModel) {
      const attributeManager = this.getAttributeManager();
      const filterNeedsUpdate = attributeManager.attributes.filterValues.needsUpdate() || props.filterEnabled !== oldProps.filterEnabled || props.filterRange !== oldProps.filterRange || props.filterSoftRange !== oldProps.filterSoftRange;
      if (filterNeedsUpdate) {
        this.setState({
          filterNeedsUpdate
        });
      }
    }
  }
  draw(params, extension) {
    const {
      filterFBO,
      filterModel,
      filterNeedsUpdate
    } = this.state;
    const {
      onFilteredItemsChange
    } = this.props;
    if (filterNeedsUpdate && onFilteredItemsChange && filterModel) {
      const {
        attributes: {
          filterValues,
          filterIndices
        }
      } = this.getAttributeManager();
      filterModel.setVertexCount(this.getNumInstances());
      const {
        gl
      } = this.context;
      clear(gl, {
        framebuffer: filterFBO,
        color: [0, 0, 0, 0]
      });
      filterModel.updateModuleSettings(params.moduleParameters).setAttributes({
        ...filterValues.getShaderAttributes(),
        ...filterIndices && filterIndices.getShaderAttributes()
      }).draw({
        framebuffer: filterFBO,
        parameters: {
          ...parameters,
          viewport: [0, 0, filterFBO.width, filterFBO.height]
        }
      });
      const color = readPixelsToArray(filterFBO);
      let count = 0;
      for (let i2 = 0; i2 < color.length; i2++) {
        count += color[i2];
      }
      onFilteredItemsChange({
        id: this.id,
        count
      });
      this.state.filterNeedsUpdate = false;
    }
  }
  finalizeState() {
    const {
      filterFBO,
      filterModel
    } = this.state;
    if (filterFBO) {
      filterFBO.color.delete();
      filterFBO.delete();
      filterModel.delete();
    }
  }
};
_defineProperty(DataFilterExtension, "defaultProps", defaultProps16);
_defineProperty(DataFilterExtension, "extensionName", "DataFilterExtension");

// node_modules/@deck.gl/extensions/dist/esm/fp64/project64.glsl.js
var project64_glsl_default = "\nconst vec2 WORLD_SCALE_FP64 = vec2(81.4873275756836, 0.0000032873668232014097);\n\nuniform vec2 project_uViewProjectionMatrixFP64[16];\nvoid mercatorProject_fp64(vec4 lnglat_fp64, out vec2 out_val[2]) {\n\n#if defined(NVIDIA_FP64_WORKAROUND)\n  out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64 * ONE);\n#else\n  out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64);\n#endif\n  out_val[1] = sum_fp64(PI_FP64,\n    log_fp64(tan_fp64(sum_fp64(PI_4_FP64, radians_fp64(lnglat_fp64.zw) / 2.0))));\n  return;\n}\n\nvoid project_position_fp64(vec4 position_fp64, out vec2 out_val[2]) {\n  vec2 pos_fp64[2];\n  mercatorProject_fp64(position_fp64, pos_fp64);\n  out_val[0] = mul_fp64(pos_fp64[0], WORLD_SCALE_FP64);\n  out_val[1] = mul_fp64(pos_fp64[1], WORLD_SCALE_FP64);\n\n  return;\n}\n\nvoid project_position_fp64(vec2 position, vec2 position64xyLow, out vec2 out_val[2]) {\n  vec4 position64xy = vec4(\n    position.x, position64xyLow.x,\n    position.y, position64xyLow.y);\n\n  project_position_fp64(position64xy, out_val);\n}\n\nvec4 project_common_position_to_clipspace_fp64(vec2 vertex_pos_modelspace[4]) {\n  vec2 vertex_pos_clipspace[4];\n  mat4_vec4_mul_fp64(project_uViewProjectionMatrixFP64, vertex_pos_modelspace,\n    vertex_pos_clipspace);\n  return vec4(\n    vertex_pos_clipspace[0].x,\n    vertex_pos_clipspace[1].x,\n    vertex_pos_clipspace[2].x,\n    vertex_pos_clipspace[3].x\n    );\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64xyLow, vec3 offset, out vec4 commonPosition\n) {\n  vec2 offset64[4];\n  vec4_fp64(vec4(offset, 0.0), offset64);\n\n  float z = project_size(position.z);\n  vec2 projectedPosition64xy[2];\n  project_position_fp64(position.xy, position64xyLow.xy, projectedPosition64xy);\n\n  vec2 commonPosition64[4];\n  commonPosition64[0] = sum_fp64(offset64[0], projectedPosition64xy[0]);\n  commonPosition64[1] = sum_fp64(offset64[1], projectedPosition64xy[1]);\n  commonPosition64[2] = sum_fp64(offset64[2], vec2(z, 0.0));\n  commonPosition64[3] = vec2(1.0, 0.0);\n\n  commonPosition = vec4(projectedPosition64xy[0].x, projectedPosition64xy[1].x, z, 1.0);\n\n  return project_common_position_to_clipspace_fp64(commonPosition64);\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64xyLow, vec3 offset\n) {\n  vec4 commonPosition;\n  return project_position_to_clipspace(\n    position, position64xyLow, offset, commonPosition\n  );\n}\n";

// node_modules/@deck.gl/extensions/dist/esm/fp64/project64.js
var {
  fp64ify,
  fp64ifyMatrix4
} = fp64;
var project64_default = {
  name: "project64",
  dependencies: [project_default, fp64],
  vs: project64_glsl_default,
  getUniforms: getUniforms2
};
var getMemoizedUniforms = memoize(calculateUniforms);
function getUniforms2(opts) {
  if (opts && "viewport" in opts) {
    const {
      viewProjectionMatrix,
      scale
    } = opts.viewport;
    return getMemoizedUniforms({
      viewProjectionMatrix,
      scale
    });
  }
  return {};
}
function calculateUniforms({
  viewProjectionMatrix,
  scale
}) {
  const glViewProjectionMatrixFP64 = fp64ifyMatrix4(viewProjectionMatrix);
  const scaleFP64 = fp64ify(scale);
  return {
    project_uViewProjectionMatrixFP64: glViewProjectionMatrixFP64,
    project64_uViewProjectionMatrix: glViewProjectionMatrixFP64,
    project64_uScale: scaleFP64
  };
}

// node_modules/@deck.gl/extensions/dist/esm/fp64/fp64-extension.js
var Fp64Extension = class extends LayerExtension {
  getShaders() {
    const {
      coordinateSystem
    } = this.props;
    if (coordinateSystem !== COORDINATE_SYSTEM.LNGLAT && coordinateSystem !== COORDINATE_SYSTEM.DEFAULT) {
      throw new Error("fp64: coordinateSystem must be LNGLAT");
    }
    return {
      modules: [project64_default]
    };
  }
};
_defineProperty(Fp64Extension, "extensionName", "Fp64Extension");

// node_modules/@deck.gl/extensions/dist/esm/path-style/shaders.glsl.js
var dashShaders = {
  inject: {
    "vs:#decl": "\nattribute vec2 instanceDashArrays;\nattribute float instanceDashOffsets;\nvarying vec2 vDashArray;\nvarying float vDashOffset;\n",
    "vs:#main-end": "\nvDashArray = instanceDashArrays;\nvDashOffset = instanceDashOffsets / width.x;\n",
    "fs:#decl": "\nuniform float dashAlignMode;\nuniform float capType;\nuniform bool dashGapPickable;\nvarying vec2 vDashArray;\nvarying float vDashOffset;\n\nfloat round(float x) {\n  return floor(x + 0.5);\n}\n",
    "fs:#main-start": "\n  float solidLength = vDashArray.x;\n  float gapLength = vDashArray.y;\n  float unitLength = solidLength + gapLength;\n\n  float offset;\n\n  if (unitLength > 0.0) {\n    if (dashAlignMode == 0.0) {\n      offset = vDashOffset;\n    } else {\n      unitLength = vPathLength / round(vPathLength / unitLength);\n      offset = solidLength / 2.0;\n    }\n\n    float unitOffset = mod(vPathPosition.y + offset, unitLength);\n\n    if (gapLength > 0.0 && unitOffset > solidLength) {\n      if (capType <= 0.5) {\n        if (!(dashGapPickable && picking_uActive)) {\n          discard;\n        }\n      } else {\n        float distToEnd = length(vec2(\n          min(unitOffset - solidLength, unitLength - unitOffset),\n          vPathPosition.x\n        ));\n        if (distToEnd > 1.0) {\n          if (!(dashGapPickable && picking_uActive)) {\n            discard;\n          }\n        }\n      }\n    }\n  }\n"
  }
};
var offsetShaders = {
  inject: {
    "vs:#decl": "\nattribute float instanceOffsets;\n",
    "vs:DECKGL_FILTER_SIZE": "\n  float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;\n  size *= offsetWidth;\n",
    "vs:#main-end": "\n  float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;\n  float offsetDir = sign(instanceOffsets);\n  vPathPosition.x = (vPathPosition.x + offsetDir) * offsetWidth - offsetDir;\n  vPathPosition.y *= offsetWidth;\n  vPathLength *= offsetWidth;\n",
    "fs:#main-start": "\n  float isInside;\n  isInside = step(-1.0, vPathPosition.x) * step(vPathPosition.x, 1.0);\n  if (isInside == 0.0) {\n    discard;\n  }\n"
  }
};

// node_modules/@deck.gl/extensions/dist/esm/path-style/path-style-extension.js
var defaultProps17 = {
  getDashArray: {
    type: "accessor",
    value: [0, 0]
  },
  getOffset: {
    type: "accessor",
    value: 0
  },
  dashJustified: false,
  dashGapPickable: false
};
var PathStyleExtension = class extends LayerExtension {
  constructor({
    dash = false,
    offset = false,
    highPrecisionDash = false
  } = {}) {
    super({
      dash: dash || highPrecisionDash,
      offset,
      highPrecisionDash
    });
  }
  isEnabled(layer) {
    return "pathTesselator" in layer.state;
  }
  getShaders(extension) {
    if (!extension.isEnabled(this)) {
      return null;
    }
    let result = {};
    if (extension.opts.dash) {
      result = mergeShaders(result, dashShaders);
    }
    if (extension.opts.offset) {
      result = mergeShaders(result, offsetShaders);
    }
    return result;
  }
  initializeState(context, extension) {
    const attributeManager = this.getAttributeManager();
    if (!attributeManager || !extension.isEnabled(this)) {
      return;
    }
    if (extension.opts.dash) {
      attributeManager.addInstanced({
        instanceDashArrays: {
          size: 2,
          accessor: "getDashArray"
        }
      });
    }
    if (extension.opts.highPrecisionDash) {
      attributeManager.addInstanced({
        instanceDashOffsets: {
          size: 1,
          accessor: "getPath",
          transform: extension.getDashOffsets.bind(this)
        }
      });
    }
    if (extension.opts.offset) {
      attributeManager.addInstanced({
        instanceOffsets: {
          size: 1,
          accessor: "getOffset"
        }
      });
    }
  }
  updateState(params, extension) {
    if (!extension.isEnabled(this)) {
      return;
    }
    const uniforms = {};
    if (extension.opts.dash) {
      uniforms.dashAlignMode = this.props.dashJustified ? 1 : 0;
      uniforms.dashGapPickable = Boolean(this.props.dashGapPickable);
    }
    this.state.model.setUniforms(uniforms);
  }
  getDashOffsets(path) {
    const result = [0];
    const positionSize = this.props.positionFormat === "XY" ? 2 : 3;
    const isNested = Array.isArray(path[0]);
    const geometrySize = isNested ? path.length : path.length / positionSize;
    let p;
    let prevP;
    for (let i2 = 0; i2 < geometrySize - 1; i2++) {
      p = isNested ? path[i2] : path.slice(i2 * positionSize, i2 * positionSize + positionSize);
      p = this.projectPosition(p);
      if (i2 > 0) {
        result[i2] = result[i2 - 1] + dist(prevP, p);
      }
      prevP = p;
    }
    return result;
  }
};
_defineProperty(PathStyleExtension, "defaultProps", defaultProps17);
_defineProperty(PathStyleExtension, "extensionName", "PathStyleExtension");

// node_modules/@deck.gl/extensions/dist/esm/fill-style/shaders.glsl.js
var patternVs = "\n#ifdef NON_INSTANCED_MODEL\n  #define FILL_PATTERN_FRAME_ATTRIB fillPatternFrames\n  #define FILL_PATTERN_SCALE_ATTRIB fillPatternScales\n  #define FILL_PATTERN_OFFSET_ATTRIB fillPatternOffsets\n#else\n  #define FILL_PATTERN_FRAME_ATTRIB instanceFillPatternFrames\n  #define FILL_PATTERN_SCALE_ATTRIB instanceFillPatternScales\n  #define FILL_PATTERN_OFFSET_ATTRIB instanceFillPatternOffsets\n#endif\n\nattribute vec4 FILL_PATTERN_FRAME_ATTRIB;\nattribute float FILL_PATTERN_SCALE_ATTRIB;\nattribute vec2 FILL_PATTERN_OFFSET_ATTRIB;\n\nuniform bool fill_patternEnabled;\nuniform vec2 fill_patternTextureSize;\n\nvarying vec2 fill_uv;\nvarying vec4 fill_patternBounds;\nvarying vec4 fill_patternPlacement;\n";
var patternFs = "\nuniform bool fill_patternEnabled;\nuniform bool fill_patternMask;\nuniform sampler2D fill_patternTexture;\nuniform vec2 fill_uvCoordinateOrigin;\nuniform vec2 fill_uvCoordinateOrigin64Low;\n\nvarying vec4 fill_patternBounds;\nvarying vec4 fill_patternPlacement;\nvarying vec2 fill_uv;\n\nconst float FILL_UV_SCALE = 512.0 / 40000000.0;\n";
var inject3 = {
  "vs:DECKGL_FILTER_GL_POSITION": "\n    fill_uv = geometry.position.xy;\n  ",
  "vs:DECKGL_FILTER_COLOR": "\n    if (fill_patternEnabled) {\n      fill_patternBounds = FILL_PATTERN_FRAME_ATTRIB / vec4(fill_patternTextureSize, fill_patternTextureSize);\n      fill_patternPlacement.xy = FILL_PATTERN_OFFSET_ATTRIB;\n      fill_patternPlacement.zw = FILL_PATTERN_SCALE_ATTRIB * FILL_PATTERN_FRAME_ATTRIB.zw;\n    }\n  ",
  "fs:DECKGL_FILTER_COLOR": "\n    if (fill_patternEnabled) {\n      vec2 scale = FILL_UV_SCALE * fill_patternPlacement.zw;\n      vec2 patternUV = mod(mod(fill_uvCoordinateOrigin, scale) + fill_uvCoordinateOrigin64Low + fill_uv, scale) / scale;\n      patternUV = mod(fill_patternPlacement.xy + patternUV, 1.0);\n\n      vec2 texCoords = fill_patternBounds.xy + fill_patternBounds.zw * patternUV;\n\n      vec4 patternColor = texture2D(fill_patternTexture, texCoords);\n      color.a *= patternColor.a;\n      if (!fill_patternMask) {\n        color.rgb = patternColor.rgb;\n      }\n    }\n  "
};
function getPatternUniforms(opts, uniforms) {
  if (!opts) {
    return {};
  }
  if ("fillPatternTexture" in opts) {
    const {
      fillPatternTexture
    } = opts;
    return {
      fill_patternTexture: fillPatternTexture,
      fill_patternTextureSize: [fillPatternTexture.width, fillPatternTexture.height]
    };
  }
  if ("viewport" in opts) {
    const {
      fillPatternMask = true,
      fillPatternEnabled = true
    } = opts;
    const {
      project_uCommonOrigin: coordinateOriginCommon
    } = uniforms;
    const coordinateOriginCommon64Low = [fp64LowPart(coordinateOriginCommon[0]), fp64LowPart(coordinateOriginCommon[1])];
    return {
      fill_uvCoordinateOrigin: coordinateOriginCommon.slice(0, 2),
      fill_uvCoordinateOrigin64Low: coordinateOriginCommon64Low,
      fill_patternMask: fillPatternMask,
      fill_patternEnabled: fillPatternEnabled
    };
  }
  return {};
}
var patternShaders = {
  name: "fill-pattern",
  vs: patternVs,
  fs: patternFs,
  inject: inject3,
  dependencies: [project_default],
  getUniforms: getPatternUniforms
};

// node_modules/@deck.gl/extensions/dist/esm/fill-style/fill-style-extension.js
var defaultProps18 = {
  fillPatternEnabled: true,
  fillPatternAtlas: {
    type: "image",
    value: null,
    async: true,
    parameters: {
      [10241]: 9729
    }
  },
  fillPatternMapping: {
    type: "object",
    value: {},
    async: true
  },
  fillPatternMask: true,
  getFillPattern: {
    type: "accessor",
    value: (d) => d.pattern
  },
  getFillPatternScale: {
    type: "accessor",
    value: 1
  },
  getFillPatternOffset: {
    type: "accessor",
    value: [0, 0]
  }
};
var FillStyleExtension = class extends LayerExtension {
  constructor({
    pattern = false
  } = {}) {
    super({
      pattern
    });
  }
  isEnabled(layer) {
    return layer.getAttributeManager() !== null && !("pathTesselator" in layer.state);
  }
  getShaders(extension) {
    if (!extension.isEnabled(this)) {
      return null;
    }
    return {
      modules: [extension.opts.pattern && patternShaders].filter(Boolean)
    };
  }
  initializeState(context, extension) {
    if (!extension.isEnabled(this)) {
      return;
    }
    const attributeManager = this.getAttributeManager();
    if (extension.opts.pattern) {
      attributeManager.add({
        fillPatternFrames: {
          size: 4,
          accessor: "getFillPattern",
          transform: extension.getPatternFrame.bind(this),
          shaderAttributes: {
            fillPatternFrames: {
              divisor: 0
            },
            instanceFillPatternFrames: {
              divisor: 1
            }
          }
        },
        fillPatternScales: {
          size: 1,
          accessor: "getFillPatternScale",
          defaultValue: 1,
          shaderAttributes: {
            fillPatternScales: {
              divisor: 0
            },
            instanceFillPatternScales: {
              divisor: 1
            }
          }
        },
        fillPatternOffsets: {
          size: 2,
          accessor: "getFillPatternOffset",
          shaderAttributes: {
            fillPatternOffsets: {
              divisor: 0
            },
            instanceFillPatternOffsets: {
              divisor: 1
            }
          }
        }
      });
    }
    this.setState({
      emptyTexture: new Texture2D(this.context.gl, {
        data: new Uint8Array(4),
        width: 1,
        height: 1
      })
    });
  }
  updateState({
    props,
    oldProps
  }, extension) {
    if (!extension.isEnabled(this)) {
      return;
    }
    if (props.fillPatternMapping && props.fillPatternMapping !== oldProps.fillPatternMapping) {
      this.getAttributeManager().invalidate("getFillPattern");
    }
  }
  draw(params, extension) {
    if (!extension.isEnabled(this)) {
      return;
    }
    const {
      fillPatternAtlas
    } = this.props;
    this.setModuleParameters({
      fillPatternTexture: fillPatternAtlas || this.state.emptyTexture
    });
  }
  finalizeState() {
    const {
      emptyTexture
    } = this.state;
    emptyTexture === null || emptyTexture === void 0 ? void 0 : emptyTexture.delete();
  }
  getPatternFrame(name) {
    const {
      fillPatternMapping
    } = this.getCurrentLayer().props;
    const def = fillPatternMapping && fillPatternMapping[name];
    return def ? [def.x, def.y, def.width, def.height] : [0, 0, 0, 0];
  }
};
_defineProperty(FillStyleExtension, "defaultProps", defaultProps18);
_defineProperty(FillStyleExtension, "extensionName", "FillStyleExtension");

// node_modules/@deck.gl/extensions/dist/esm/clip/clip-extension.js
var defaultProps19 = {
  clipBounds: [0, 0, 1, 1],
  clipByInstance: void 0
};
var shaderFunction = "\nuniform vec4 clip_bounds;\n\nbool clip_isInBounds(vec2 position) {\n  return position.x >= clip_bounds[0] && position.y >= clip_bounds[1] && position.x < clip_bounds[2] && position.y < clip_bounds[3];\n}\n";
var shaderModuleVs = {
  name: "clip-vs",
  vs: shaderFunction
};
var injectionVs = {
  "vs:#decl": "\nvarying float clip_isVisible;\n",
  "vs:DECKGL_FILTER_GL_POSITION": "\n  clip_isVisible = float(clip_isInBounds(geometry.worldPosition.xy));\n",
  "fs:#decl": "\nvarying float clip_isVisible;\n",
  "fs:DECKGL_FILTER_COLOR": "\n  if (clip_isVisible < 0.5) discard;\n"
};
var shaderModuleFs = {
  name: "clip-fs",
  fs: shaderFunction
};
var injectionFs = {
  "vs:#decl": "\nvarying vec2 clip_commonPosition;\n",
  "vs:DECKGL_FILTER_GL_POSITION": "\n  clip_commonPosition = geometry.position.xy;\n",
  "fs:#decl": "\nvarying vec2 clip_commonPosition;\n",
  "fs:DECKGL_FILTER_COLOR": "\n  if (!clip_isInBounds(clip_commonPosition)) discard;\n"
};
var ClipExtension = class extends LayerExtension {
  getShaders() {
    let clipByInstance = "instancePositions" in this.getAttributeManager().attributes;
    if (this.props.clipByInstance !== void 0) {
      clipByInstance = Boolean(this.props.clipByInstance);
    }
    this.state.clipByInstance = clipByInstance;
    return clipByInstance ? {
      modules: [shaderModuleVs],
      inject: injectionVs
    } : {
      modules: [shaderModuleFs],
      inject: injectionFs
    };
  }
  draw({
    uniforms
  }) {
    const {
      clipBounds
    } = this.props;
    if (this.state.clipByInstance) {
      uniforms.clip_bounds = clipBounds;
    } else {
      const corner0 = this.projectPosition([clipBounds[0], clipBounds[1], 0]);
      const corner1 = this.projectPosition([clipBounds[2], clipBounds[3], 0]);
      uniforms.clip_bounds = [Math.min(corner0[0], corner1[0]), Math.min(corner0[1], corner1[1]), Math.max(corner0[0], corner1[0]), Math.max(corner0[1], corner1[1])];
    }
  }
};
_defineProperty(ClipExtension, "defaultProps", defaultProps19);
_defineProperty(ClipExtension, "extensionName", "ClipExtension");

// node_modules/@deck.gl/extensions/dist/esm/collision-filter/shader-module.js
var vs4 = "\n#ifdef NON_INSTANCED_MODEL\nattribute float collisionPriorities;\n#else\nattribute float instanceCollisionPriorities;\n#endif\n\nuniform sampler2D collision_texture;\nuniform bool collision_sort;\nuniform bool collision_enabled;\n\nvec2 collision_getCoords(vec4 position) {\n  vec4 collision_clipspace = project_common_position_to_clipspace(position);\n  return (1.0 + collision_clipspace.xy / collision_clipspace.w) / 2.0;\n}\n\nfloat collision_match(vec2 tex, vec3 pickingColor) {\n  vec4 collision_pickingColor = texture2D(collision_texture, tex);\n  float delta = dot(abs(collision_pickingColor.rgb - pickingColor), vec3(1.0));\n  float e = 0.001;\n  return step(delta, e);\n}\n\nfloat collision_isVisible(vec2 texCoords, vec3 pickingColor) {\n  if (!collision_enabled) {\n    return 1.0;\n  }\n\n  // Visibility test, sample area of 5x5 pixels in order to fade in/out.\n  // Due to the locality, the lookups will be cached\n  // This reduces the flicker present when objects are shown/hidden\n  const int N = 2;\n  float accumulator = 0.0;\n  vec2 step = vec2(1.0 / project_uViewportSize);\n\n  const float floatN = float(N);\n  vec2 delta = -floatN * step;\n  for(int i = -N; i <= N; i++) {\n    delta.x = -step.x * floatN;\n    for(int j = -N; j <= N; j++) {\n      accumulator += collision_match(texCoords + delta, pickingColor);\n      delta.x += step.x;\n    }\n    delta.y += step.y;\n  }\n\n  float W = 2.0 * floatN + 1.0;\n  return pow(accumulator / (W * W), 2.2);\n}\n";
var inject4 = {
  "vs:#decl": "\n  float collision_fade = 1.0;\n",
  "vs:DECKGL_FILTER_GL_POSITION": "\n  if (collision_sort) {\n    #ifdef NON_INSTANCED_MODEL\n    float collisionPriority = collisionPriorities;\n    #else\n    float collisionPriority = instanceCollisionPriorities;\n    #endif\n    position.z = -0.001 * collisionPriority * position.w; // Support range -1000 -> 1000\n  }\n\n  if (collision_enabled) {\n    vec4 collision_common_position = project_position(vec4(geometry.worldPosition, 1.0));\n    vec2 collision_texCoords = collision_getCoords(collision_common_position);\n    collision_fade = collision_isVisible(collision_texCoords, geometry.pickingColor / 255.0);\n    if (collision_fade < 0.0001) {\n      // Position outside clip space bounds to discard\n      position = vec4(0.0, 0.0, 2.0, 1.0);\n    }\n  }\n  ",
  "vs:DECKGL_FILTER_COLOR": "\n  color.a *= collision_fade;\n  "
};
var getCollisionUniforms = (opts, uniforms) => {
  if (!opts || !("dummyCollisionMap" in opts)) {
    return {};
  }
  const {
    collisionFBO,
    drawToCollisionMap,
    dummyCollisionMap
  } = opts;
  return {
    collision_sort: Boolean(drawToCollisionMap),
    collision_texture: !drawToCollisionMap && collisionFBO ? collisionFBO : dummyCollisionMap
  };
};
var shader_module_default2 = {
  name: "collision",
  dependencies: [project_default],
  vs: vs4,
  inject: inject4,
  getUniforms: getCollisionUniforms
};

// node_modules/@deck.gl/extensions/dist/esm/collision-filter/collision-filter-pass.js
var CollisionFilterPass = class extends LayersPass {
  renderCollisionMap(target, options) {
    const gl = this.gl;
    const padding = 1;
    return withParameters(gl, {
      scissorTest: true,
      scissor: [padding, padding, target.width - 2 * padding, target.height - 2 * padding],
      clearColor: [0, 0, 0, 0],
      blend: false,
      depthTest: true,
      depthRange: [0, 1]
    }, () => this.render({
      ...options,
      target,
      pass: "collision"
    }));
  }
  getModuleParameters() {
    return {
      drawToCollisionMap: true,
      pickingActive: 1,
      pickingAttribute: false,
      lightSources: {}
    };
  }
};

// node_modules/@deck.gl/extensions/dist/esm/mask/mask-pass.js
var MaskPass = class extends LayersPass {
  constructor(gl, props) {
    super(gl, props);
    _defineProperty(this, "maskMap", void 0);
    _defineProperty(this, "fbo", void 0);
    const {
      mapSize = 2048
    } = props;
    this.maskMap = new Texture2D(gl, {
      width: mapSize,
      height: mapSize,
      parameters: {
        [10241]: 9729,
        [10240]: 9729,
        [10242]: 33071,
        [10243]: 33071
      }
    });
    this.fbo = new Framebuffer(gl, {
      id: "maskmap",
      width: mapSize,
      height: mapSize,
      attachments: {
        [36064]: this.maskMap
      }
    });
  }
  render(options) {
    const gl = this.gl;
    const colorMask = [false, false, false, false];
    colorMask[options.channel] = true;
    return withParameters(gl, {
      clearColor: [255, 255, 255, 255],
      blend: true,
      blendFunc: [0, 1],
      blendEquation: 32778,
      colorMask,
      depthTest: false
    }, () => super.render({
      ...options,
      target: this.fbo,
      pass: "mask"
    }));
  }
  shouldDrawLayer(layer) {
    return layer.props.operation.includes("mask");
  }
  delete() {
    this.fbo.delete();
    this.maskMap.delete();
  }
};

// node_modules/@deck.gl/extensions/dist/esm/utils/projection-utils.js
function joinLayerBounds(layers, viewport) {
  const bounds = [Infinity, Infinity, -Infinity, -Infinity];
  for (const layer of layers) {
    const layerBounds = layer.getBounds();
    if (layerBounds) {
      const bottomLeftCommon = layer.projectPosition(layerBounds[0], {
        viewport,
        autoOffset: false
      });
      const topRightCommon = layer.projectPosition(layerBounds[1], {
        viewport,
        autoOffset: false
      });
      bounds[0] = Math.min(bounds[0], bottomLeftCommon[0]);
      bounds[1] = Math.min(bounds[1], bottomLeftCommon[1]);
      bounds[2] = Math.max(bounds[2], topRightCommon[0]);
      bounds[3] = Math.max(bounds[3], topRightCommon[1]);
    }
  }
  if (Number.isFinite(bounds[0])) {
    return bounds;
  }
  return null;
}
var MAX_VIEWPORT_SIZE = 2048;
function makeViewport(opts) {
  const {
    bounds,
    viewport,
    border = 0
  } = opts;
  const {
    isGeospatial
  } = viewport;
  if (bounds[2] <= bounds[0] || bounds[3] <= bounds[1]) {
    return null;
  }
  const centerWorld = viewport.unprojectPosition([(bounds[0] + bounds[2]) / 2, (bounds[1] + bounds[3]) / 2, 0]);
  let {
    width,
    height,
    zoom
  } = opts;
  if (zoom === void 0) {
    width = width - border * 2;
    height = height - border * 2;
    const scale = Math.min(width / (bounds[2] - bounds[0]), height / (bounds[3] - bounds[1]));
    zoom = Math.min(Math.log2(scale), 20);
  } else if (!width || !height) {
    const scale = 2 ** zoom;
    width = Math.round(Math.abs(bounds[2] - bounds[0]) * scale);
    height = Math.round(Math.abs(bounds[3] - bounds[1]) * scale);
    const maxSize = MAX_VIEWPORT_SIZE - border * 2;
    if (width > maxSize || height > maxSize) {
      const r = maxSize / Math.max(width, height);
      width = Math.round(width * r);
      height = Math.round(height * r);
      zoom += Math.log2(r);
    }
  }
  return isGeospatial ? new WebMercatorViewport({
    id: viewport.id,
    x: border,
    y: border,
    width,
    height,
    longitude: centerWorld[0],
    latitude: centerWorld[1],
    zoom,
    orthographic: true
  }) : new OrthographicViewport({
    id: viewport.id,
    x: border,
    y: border,
    width,
    height,
    target: centerWorld,
    zoom,
    flipY: false
  });
}
function getViewportBounds(viewport, zRange) {
  let viewportBoundsWorld;
  if (zRange && zRange.length === 2) {
    const [minZ, maxZ] = zRange;
    const bounds0 = viewport.getBounds({
      z: minZ
    });
    const bounds1 = viewport.getBounds({
      z: maxZ
    });
    viewportBoundsWorld = [Math.min(bounds0[0], bounds1[0]), Math.min(bounds0[1], bounds1[1]), Math.max(bounds0[2], bounds1[2]), Math.max(bounds0[3], bounds1[3])];
  } else {
    viewportBoundsWorld = viewport.getBounds();
  }
  const viewportBottomLeftCommon = viewport.projectPosition(viewportBoundsWorld.slice(0, 2));
  const viewportTopRightCommon = viewport.projectPosition(viewportBoundsWorld.slice(2, 4));
  return [viewportBottomLeftCommon[0], viewportBottomLeftCommon[1], viewportTopRightCommon[0], viewportTopRightCommon[1]];
}
function getRenderBounds(layerBounds, viewport, zRange) {
  if (!layerBounds) {
    return [0, 0, 1, 1];
  }
  const viewportBounds = getViewportBounds(viewport, zRange);
  const paddedBounds = doubleBounds(viewportBounds);
  if (layerBounds[2] - layerBounds[0] <= paddedBounds[2] - paddedBounds[0] && layerBounds[3] - layerBounds[1] <= paddedBounds[3] - paddedBounds[1]) {
    return layerBounds;
  }
  return [Math.max(layerBounds[0], paddedBounds[0]), Math.max(layerBounds[1], paddedBounds[1]), Math.min(layerBounds[2], paddedBounds[2]), Math.min(layerBounds[3], paddedBounds[3])];
}
function doubleBounds(bounds) {
  const dx = bounds[2] - bounds[0];
  const dy = bounds[3] - bounds[1];
  const centerX = (bounds[0] + bounds[2]) / 2;
  const centerY = (bounds[1] + bounds[3]) / 2;
  return [centerX - dx, centerY - dy, centerX + dx, centerY + dy];
}

// node_modules/@deck.gl/extensions/dist/esm/mask/mask-effect.js
var MaskEffect = class {
  constructor() {
    _defineProperty(this, "id", "mask-effect");
    _defineProperty(this, "props", null);
    _defineProperty(this, "useInPicking", true);
    _defineProperty(this, "order", 0);
    _defineProperty(this, "dummyMaskMap", void 0);
    _defineProperty(this, "channels", []);
    _defineProperty(this, "masks", null);
    _defineProperty(this, "maskPass", void 0);
    _defineProperty(this, "maskMap", void 0);
    _defineProperty(this, "lastViewport", void 0);
  }
  preRender(gl, {
    layers,
    layerFilter,
    viewports,
    onViewportActive,
    views,
    isPicking
  }) {
    let didRender = false;
    if (!this.dummyMaskMap) {
      this.dummyMaskMap = new Texture2D(gl, {
        width: 1,
        height: 1
      });
    }
    if (isPicking) {
      return {
        didRender
      };
    }
    const maskLayers = layers.filter((l) => l.props.visible && l.props.operation.includes("mask"));
    if (maskLayers.length === 0) {
      this.masks = null;
      this.channels.length = 0;
      return {
        didRender
      };
    }
    this.masks = {};
    if (!this.maskPass) {
      this.maskPass = new MaskPass(gl, {
        id: "default-mask"
      });
      this.maskMap = this.maskPass.maskMap;
    }
    const channelMap = this._sortMaskChannels(maskLayers);
    const viewport = viewports[0];
    const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport);
    if (viewport.resolution !== void 0) {
      log_default.warn("MaskExtension is not supported in GlobeView")();
      return {
        didRender
      };
    }
    for (const maskId in channelMap) {
      const result = this._renderChannel(channelMap[maskId], {
        layerFilter,
        onViewportActive,
        views,
        viewport,
        viewportChanged
      });
      didRender || (didRender = result);
    }
    return {
      didRender
    };
  }
  _renderChannel(channelInfo, {
    layerFilter,
    onViewportActive,
    views,
    viewport,
    viewportChanged
  }) {
    let didRender = false;
    const oldChannelInfo = this.channels[channelInfo.index];
    if (!oldChannelInfo) {
      return didRender;
    }
    const maskChanged = channelInfo === oldChannelInfo || channelInfo.layers.length !== oldChannelInfo.layers.length || channelInfo.layers.some((layer, i2) => layer !== oldChannelInfo.layers[i2] || layer.props.transitions) || channelInfo.layerBounds.some((b, i2) => b !== oldChannelInfo.layerBounds[i2]);
    channelInfo.bounds = oldChannelInfo.bounds;
    channelInfo.maskBounds = oldChannelInfo.maskBounds;
    this.channels[channelInfo.index] = channelInfo;
    if (maskChanged || viewportChanged) {
      this.lastViewport = viewport;
      const layerBounds = joinLayerBounds(channelInfo.layers, viewport);
      channelInfo.bounds = layerBounds && getRenderBounds(layerBounds, viewport);
      if (maskChanged || !equals(channelInfo.bounds, oldChannelInfo.bounds)) {
        const {
          maskPass,
          maskMap
        } = this;
        const maskViewport = layerBounds && makeViewport({
          bounds: channelInfo.bounds,
          viewport,
          width: maskMap.width,
          height: maskMap.height,
          border: 1
        });
        channelInfo.maskBounds = maskViewport ? maskViewport.getBounds() : [0, 0, 1, 1];
        maskPass.render({
          pass: "mask",
          channel: channelInfo.index,
          layers: channelInfo.layers,
          layerFilter,
          viewports: maskViewport ? [maskViewport] : [],
          onViewportActive,
          views,
          moduleParameters: {
            devicePixelRatio: 1
          }
        });
        didRender = true;
      }
    }
    this.masks[channelInfo.id] = {
      index: channelInfo.index,
      bounds: channelInfo.maskBounds,
      coordinateOrigin: channelInfo.coordinateOrigin,
      coordinateSystem: channelInfo.coordinateSystem
    };
    return didRender;
  }
  _sortMaskChannels(maskLayers) {
    const channelMap = {};
    let channelCount = 0;
    for (const layer of maskLayers) {
      const {
        id
      } = layer.root;
      let channelInfo = channelMap[id];
      if (!channelInfo) {
        if (++channelCount > 4) {
          log_default.warn("Too many mask layers. The max supported is 4")();
          continue;
        }
        channelInfo = {
          id,
          index: this.channels.findIndex((c) => (c === null || c === void 0 ? void 0 : c.id) === id),
          layers: [],
          layerBounds: [],
          coordinateOrigin: layer.root.props.coordinateOrigin,
          coordinateSystem: layer.root.props.coordinateSystem
        };
        channelMap[id] = channelInfo;
      }
      channelInfo.layers.push(layer);
      channelInfo.layerBounds.push(layer.getBounds());
    }
    for (let i2 = 0; i2 < 4; i2++) {
      const channelInfo = this.channels[i2];
      if (!channelInfo || !(channelInfo.id in channelMap)) {
        this.channels[i2] = null;
      }
    }
    for (const maskId in channelMap) {
      const channelInfo = channelMap[maskId];
      if (channelInfo.index < 0) {
        channelInfo.index = this.channels.findIndex((c) => !c);
        this.channels[channelInfo.index] = channelInfo;
      }
    }
    return channelMap;
  }
  getModuleParameters() {
    return {
      maskMap: this.masks ? this.maskMap : this.dummyMaskMap,
      maskChannels: this.masks
    };
  }
  cleanup() {
    if (this.dummyMaskMap) {
      this.dummyMaskMap.delete();
      this.dummyMaskMap = void 0;
    }
    if (this.maskPass) {
      this.maskPass.delete();
      this.maskPass = void 0;
      this.maskMap = void 0;
    }
    this.lastViewport = void 0;
    this.masks = null;
    this.channels.length = 0;
  }
};

// node_modules/@deck.gl/extensions/dist/esm/collision-filter/collision-filter-effect.js
var DOWNSCALE = 2;
var CollisionFilterEffect = class {
  constructor() {
    _defineProperty(this, "id", "collision-filter-effect");
    _defineProperty(this, "props", null);
    _defineProperty(this, "useInPicking", true);
    _defineProperty(this, "order", 1);
    _defineProperty(this, "channels", {});
    _defineProperty(this, "collisionFilterPass", void 0);
    _defineProperty(this, "collisionFBOs", {});
    _defineProperty(this, "dummyCollisionMap", void 0);
    _defineProperty(this, "lastViewport", void 0);
  }
  preRender(gl, {
    effects: allEffects,
    layers,
    layerFilter,
    viewports,
    onViewportActive,
    views,
    isPicking,
    preRenderStats = {}
  }) {
    var _preRenderStats$mask;
    if (!this.dummyCollisionMap) {
      this.dummyCollisionMap = new Texture2D(gl, {
        width: 1,
        height: 1
      });
    }
    if (isPicking) {
      return;
    }
    const collisionLayers = layers.filter(({
      props: {
        visible,
        collisionEnabled
      }
    }) => visible && collisionEnabled);
    if (collisionLayers.length === 0) {
      this.channels = {};
      return;
    }
    if (!this.collisionFilterPass) {
      this.collisionFilterPass = new CollisionFilterPass(gl, {
        id: "default-collision-filter"
      });
    }
    const effects = allEffects === null || allEffects === void 0 ? void 0 : allEffects.filter((e) => e.constructor === MaskEffect);
    const maskEffectRendered = (_preRenderStats$mask = preRenderStats["mask-effect"]) === null || _preRenderStats$mask === void 0 ? void 0 : _preRenderStats$mask.didRender;
    const channels = this._groupByCollisionGroup(gl, collisionLayers);
    const viewport = viewports[0];
    const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport) || maskEffectRendered;
    for (const collisionGroup in channels) {
      const collisionFBO = this.collisionFBOs[collisionGroup];
      const renderInfo = channels[collisionGroup];
      collisionFBO.resize({
        width: gl.canvas.width / DOWNSCALE,
        height: gl.canvas.height / DOWNSCALE
      });
      this._render(renderInfo, {
        effects,
        layerFilter,
        onViewportActive,
        views,
        viewport,
        viewportChanged
      });
    }
  }
  _render(renderInfo, {
    effects,
    layerFilter,
    onViewportActive,
    views,
    viewport,
    viewportChanged
  }) {
    const {
      collisionGroup
    } = renderInfo;
    const oldRenderInfo = this.channels[collisionGroup];
    if (!oldRenderInfo) {
      return;
    }
    const needsRender = viewportChanged || renderInfo === oldRenderInfo || !deepEqual(oldRenderInfo.layers, renderInfo.layers, 1) || renderInfo.layerBounds.some((b, i2) => !equals(b, oldRenderInfo.layerBounds[i2])) || renderInfo.allLayersLoaded !== oldRenderInfo.allLayersLoaded || renderInfo.layers.some((layer) => layer.props.transitions);
    this.channels[collisionGroup] = renderInfo;
    if (needsRender) {
      this.lastViewport = viewport;
      const collisionFBO = this.collisionFBOs[collisionGroup];
      this.collisionFilterPass.renderCollisionMap(collisionFBO, {
        pass: "collision-filter",
        isPicking: true,
        layers: renderInfo.layers,
        effects,
        layerFilter,
        viewports: viewport ? [viewport] : [],
        onViewportActive,
        views,
        moduleParameters: {
          dummyCollisionMap: this.dummyCollisionMap,
          devicePixelRatio: cssToDeviceRatio(collisionFBO.gl) / DOWNSCALE
        }
      });
    }
  }
  _groupByCollisionGroup(gl, collisionLayers) {
    const channelMap = {};
    for (const layer of collisionLayers) {
      const {
        collisionGroup
      } = layer.props;
      let channelInfo = channelMap[collisionGroup];
      if (!channelInfo) {
        channelInfo = {
          collisionGroup,
          layers: [],
          layerBounds: [],
          allLayersLoaded: true
        };
        channelMap[collisionGroup] = channelInfo;
      }
      channelInfo.layers.push(layer);
      channelInfo.layerBounds.push(layer.getBounds());
      if (!layer.isLoaded) {
        channelInfo.allLayersLoaded = false;
      }
    }
    for (const collisionGroup of Object.keys(channelMap)) {
      if (!this.collisionFBOs[collisionGroup]) {
        this.createFBO(gl, collisionGroup);
      }
      if (!this.channels[collisionGroup]) {
        this.channels[collisionGroup] = channelMap[collisionGroup];
      }
    }
    for (const collisionGroup of Object.keys(this.collisionFBOs)) {
      if (!channelMap[collisionGroup]) {
        this.destroyFBO(collisionGroup);
      }
    }
    return channelMap;
  }
  getModuleParameters(layer) {
    const {
      collisionGroup
    } = layer.props;
    const {
      collisionFBOs,
      dummyCollisionMap
    } = this;
    return {
      collisionFBO: collisionFBOs[collisionGroup],
      dummyCollisionMap
    };
  }
  cleanup() {
    if (this.dummyCollisionMap) {
      this.dummyCollisionMap.delete();
      this.dummyCollisionMap = void 0;
    }
    this.channels = {};
    for (const collisionGroup of Object.keys(this.collisionFBOs)) {
      this.destroyFBO(collisionGroup);
    }
    this.collisionFBOs = {};
    this.lastViewport = void 0;
  }
  createFBO(gl, collisionGroup) {
    const {
      width,
      height
    } = gl.canvas;
    const collisionMap = new Texture2D(gl, {
      width,
      height,
      parameters: {
        [10241]: 9728,
        [10240]: 9728,
        [10242]: 33071,
        [10243]: 33071
      }
    });
    const depthBuffer = new Renderbuffer(gl, {
      format: 33189,
      width,
      height
    });
    this.collisionFBOs[collisionGroup] = new Framebuffer(gl, {
      id: "Collision-".concat(collisionGroup),
      width,
      height,
      attachments: {
        [36064]: collisionMap,
        [36096]: depthBuffer
      }
    });
  }
  destroyFBO(collisionGroup) {
    const fbo = this.collisionFBOs[collisionGroup];
    for (const attachment of Object.values(fbo.attachments)) {
      attachment.delete();
    }
    fbo.delete();
    delete this.collisionFBOs[collisionGroup];
  }
};

// node_modules/@deck.gl/extensions/dist/esm/collision-filter/collision-filter-extension.js
var defaultProps20 = {
  getCollisionPriority: {
    type: "accessor",
    value: 0
  },
  collisionEnabled: true,
  collisionGroup: {
    type: "string",
    value: "default"
  },
  collisionTestProps: {}
};
var CollisionFilterExtension = class extends LayerExtension {
  getShaders() {
    return {
      modules: [shader_module_default2]
    };
  }
  draw({
    uniforms,
    context,
    moduleParameters
  }) {
    const {
      collisionEnabled
    } = this.props;
    const {
      collisionFBO,
      drawToCollisionMap
    } = moduleParameters;
    const enabled = collisionEnabled && Boolean(collisionFBO);
    uniforms.collision_enabled = enabled;
    if (drawToCollisionMap) {
      this.props = this.clone(this.props.collisionTestProps).props;
    }
  }
  initializeState(context, extension) {
    var _this$context$deck;
    if (this.getAttributeManager() === null) {
      return;
    }
    (_this$context$deck = this.context.deck) === null || _this$context$deck === void 0 ? void 0 : _this$context$deck._addDefaultEffect(new CollisionFilterEffect());
    const attributeManager = this.getAttributeManager();
    attributeManager.add({
      collisionPriorities: {
        size: 1,
        accessor: "getCollisionPriority",
        shaderAttributes: {
          collisionPriorities: {
            divisor: 0
          },
          instanceCollisionPriorities: {
            divisor: 1
          }
        }
      }
    });
  }
  getNeedsPickingBuffer() {
    return this.props.collisionEnabled;
  }
};
_defineProperty(CollisionFilterExtension, "defaultProps", defaultProps20);
_defineProperty(CollisionFilterExtension, "extensionName", "CollisionFilterExtension");

// node_modules/@deck.gl/extensions/dist/esm/mask/shader-module.js
var vs5 = "\nuniform vec4 mask_bounds;\nuniform bool mask_maskByInstance;\nvec2 mask_getCoords(vec4 position) {\n  return (position.xy - mask_bounds.xy) / (mask_bounds.zw - mask_bounds.xy);\n}\n";
var fs4 = "\nuniform sampler2D mask_texture;\nuniform int mask_channel;\nuniform bool mask_enabled;\nuniform bool mask_inverted;\nbool mask_isInBounds(vec2 texCoords) {\n  if (!mask_enabled) {\n    return true;\n  }\n  vec4 maskColor = texture2D(mask_texture, texCoords);\n  float maskValue = 1.0;\n  if (mask_channel == 0) {\n    maskValue = maskColor.r;\n  } else if (mask_channel == 1) {\n    maskValue = maskColor.g;\n  } else if (mask_channel == 2) {\n    maskValue = maskColor.b;\n  } else if (mask_channel == 3) {\n    maskValue = maskColor.a;\n  }\n\n  if (mask_inverted) {\n    return maskValue >= 0.5;\n  } else {\n    return maskValue < 0.5;\n  }\n}\n";
var inject5 = {
  "vs:#decl": "\nvarying vec2 mask_texCoords;\n",
  "vs:#main-end": "\n   vec4 mask_common_position;\n   if (mask_maskByInstance) {\n     mask_common_position = project_position(vec4(geometry.worldPosition, 1.0));\n   } else {\n     mask_common_position = geometry.position;\n   }\n   mask_texCoords = mask_getCoords(mask_common_position);\n",
  "fs:#decl": "\nvarying vec2 mask_texCoords;\n",
  "fs:#main-start": "\n  if (mask_enabled) {\n    bool mask = mask_isInBounds(mask_texCoords);\n\n    // Debug: show extent of render target\n    // gl_FragColor = vec4(mask_texCoords, 0.0, 1.0);\n    gl_FragColor = texture2D(mask_texture, mask_texCoords);\n\n    if (!mask) discard;\n  }\n"
};
var getMaskUniforms = (opts) => {
  if (opts && "maskMap" in opts) {
    return {
      mask_texture: opts.maskMap
    };
  }
  return {};
};
var shader_module_default3 = {
  name: "mask",
  dependencies: [project_default],
  vs: vs5,
  fs: fs4,
  inject: inject5,
  getUniforms: getMaskUniforms
};

// node_modules/@deck.gl/extensions/dist/esm/mask/mask-extension.js
var defaultProps21 = {
  maskId: "",
  maskByInstance: void 0,
  maskInverted: false
};
var MaskExtension = class extends LayerExtension {
  initializeState() {
    var _this$context$deck;
    (_this$context$deck = this.context.deck) === null || _this$context$deck === void 0 ? void 0 : _this$context$deck._addDefaultEffect(new MaskEffect());
  }
  getShaders() {
    let maskByInstance = "instancePositions" in this.getAttributeManager().attributes;
    if (this.props.maskByInstance !== void 0) {
      maskByInstance = Boolean(this.props.maskByInstance);
    }
    this.state.maskByInstance = maskByInstance;
    return {
      modules: [shader_module_default3]
    };
  }
  draw({
    uniforms,
    context,
    moduleParameters
  }) {
    uniforms.mask_maskByInstance = this.state.maskByInstance;
    const {
      maskId,
      maskInverted
    } = this.props;
    const {
      maskChannels
    } = moduleParameters;
    const {
      viewport
    } = context;
    if (maskChannels && maskChannels[maskId]) {
      const {
        index,
        bounds,
        coordinateOrigin: fromCoordinateOrigin
      } = maskChannels[maskId];
      let {
        coordinateSystem: fromCoordinateSystem
      } = maskChannels[maskId];
      uniforms.mask_enabled = true;
      uniforms.mask_channel = index;
      uniforms.mask_inverted = maskInverted;
      if (fromCoordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
        fromCoordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;
      }
      const opts = {
        modelMatrix: null,
        fromCoordinateOrigin,
        fromCoordinateSystem
      };
      const bl = this.projectPosition([bounds[0], bounds[1], 0], opts);
      const tr = this.projectPosition([bounds[2], bounds[3], 0], opts);
      uniforms.mask_bounds = [bl[0], bl[1], tr[0], tr[1]];
    } else {
      if (maskId) {
        log_default.warn("Could not find a mask layer with id: ".concat(maskId))();
      }
      uniforms.mask_enabled = false;
    }
  }
};
_defineProperty(MaskExtension, "defaultProps", defaultProps21);
_defineProperty(MaskExtension, "extensionName", "MaskExtension");

// node_modules/@deck.gl/extensions/dist/esm/terrain/shader-module.js
var TERRAIN_MODE = {
  NONE: 0,
  WRITE_HEIGHT_MAP: 1,
  USE_HEIGHT_MAP: 2,
  USE_COVER: 3,
  USE_COVER_ONLY: 4,
  SKIP: 5
};
var TERRAIN_MODE_CONSTANTS = Object.keys(TERRAIN_MODE).map((key) => "const float TERRAIN_MODE_".concat(key, " = ").concat(TERRAIN_MODE[key], ".0;")).join("\n");
var terrainModule = {
  name: "terrain",
  dependencies: [project_default],
  inject: {
    "vs:#decl": "\nuniform float terrain_mode;\nuniform sampler2D terrain_map;\nuniform vec4 terrain_bounds;\nvarying vec3 commonPos;\n".concat(TERRAIN_MODE_CONSTANTS, "\n    "),
    "vs:#main-start": "\nif (terrain_mode == TERRAIN_MODE_SKIP) {\n  gl_Position = vec4(0.0);\n  return;\n}\n",
    "vs:DECKGL_FILTER_GL_POSITION": "\ncommonPos = geometry.position.xyz;\nif (terrain_mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {\n  vec2 texCoords = (commonPos.xy - terrain_bounds.xy) / terrain_bounds.zw;\n  position = vec4(texCoords * 2.0 - 1.0, 0.0, 1.0);\n  commonPos.z += project_uCommonOrigin.z;\n}\nif (terrain_mode == TERRAIN_MODE_USE_HEIGHT_MAP) {\n  vec3 anchor = geometry.worldPosition;\n  anchor.z = 0.0;\n  vec3 anchorCommon = project_position(anchor);\n  vec2 texCoords = (anchorCommon.xy - terrain_bounds.xy) / terrain_bounds.zw;\n  if (texCoords.x >= 0.0 && texCoords.y >= 0.0 && texCoords.x <= 1.0 && texCoords.y <= 1.0) {\n    float terrainZ = texture2D(terrain_map, texCoords).r;\n    geometry.position.z += terrainZ;\n    position = project_common_position_to_clipspace(geometry.position);\n  }\n}\n    ",
    "fs:#decl": "\nuniform float terrain_mode;\nuniform sampler2D terrain_map;\nuniform vec4 terrain_bounds;\nvarying vec3 commonPos;\n".concat(TERRAIN_MODE_CONSTANTS, "\n    "),
    "fs:#main-start": "\nif (terrain_mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {\n  gl_FragColor = vec4(commonPos.z, 0.0, 0.0, 1.0);\n  return;\n}\n    ",
    "fs:DECKGL_FILTER_COLOR": "\nif ((terrain_mode == TERRAIN_MODE_USE_COVER) || (terrain_mode == TERRAIN_MODE_USE_COVER_ONLY)) {\n  vec2 texCoords = (commonPos.xy - terrain_bounds.xy) / terrain_bounds.zw;\n  vec4 pixel = texture2D(terrain_map, texCoords);\n  if (terrain_mode == TERRAIN_MODE_USE_COVER_ONLY) {\n    color = pixel;\n  } else {\n    // pixel is premultiplied\n    color = pixel + color * (1.0 - pixel.a);\n  }\n  return;\n}\n    "
  },
  getUniforms: (opts = {}, uniforms) => {
    if ("dummyHeightMap" in opts) {
      const {
        drawToTerrainHeightMap,
        heightMap,
        heightMapBounds,
        dummyHeightMap,
        terrainCover,
        useTerrainHeightMap,
        terrainSkipRender
      } = opts;
      const {
        project_uCommonOrigin
      } = uniforms;
      let mode = terrainSkipRender ? TERRAIN_MODE.SKIP : TERRAIN_MODE.NONE;
      let sampler = dummyHeightMap;
      let bounds = null;
      if (drawToTerrainHeightMap) {
        mode = TERRAIN_MODE.WRITE_HEIGHT_MAP;
        bounds = heightMapBounds;
      } else if (useTerrainHeightMap && heightMap) {
        mode = TERRAIN_MODE.USE_HEIGHT_MAP;
        sampler = heightMap;
        bounds = heightMapBounds;
      } else if (terrainCover) {
        const isPicking = opts.pickingActive;
        sampler = isPicking ? terrainCover.getPickingFramebuffer() : terrainCover.getRenderFramebuffer();
        if (isPicking) {
          mode = TERRAIN_MODE.SKIP;
        }
        if (sampler) {
          mode = mode === TERRAIN_MODE.SKIP ? TERRAIN_MODE.USE_COVER_ONLY : TERRAIN_MODE.USE_COVER;
          bounds = terrainCover.bounds;
        } else {
          sampler = dummyHeightMap;
        }
      }
      return {
        terrain_mode: mode,
        terrain_map: sampler,
        terrain_bounds: bounds ? [bounds[0] - project_uCommonOrigin[0], bounds[1] - project_uCommonOrigin[1], bounds[2] - bounds[0], bounds[3] - bounds[1]] : [0, 0, 0, 0]
      };
    }
    return null;
  }
};

// node_modules/@deck.gl/extensions/dist/esm/terrain/utils.js
function createRenderTarget(gl, opts) {
  return new Framebuffer(gl, {
    id: opts.id,
    attachments: {
      [36064]: new Texture2D(gl, {
        ...opts.float && {
          format: isWebGL2(gl) ? 34836 : 6408,
          type: 5126
        },
        mipmaps: false,
        parameters: {
          [10241]: 9729,
          [10240]: 9729,
          [10242]: 33071,
          [10243]: 33071
        }
      })
    }
  });
}

// node_modules/@deck.gl/extensions/dist/esm/terrain/terrain-cover.js
var TerrainCover = class {
  constructor(targetLayer) {
    _defineProperty(this, "isDirty", true);
    _defineProperty(this, "targetLayer", void 0);
    _defineProperty(this, "renderViewport", null);
    _defineProperty(this, "bounds", null);
    _defineProperty(this, "fbo", void 0);
    _defineProperty(this, "pickingFbo", void 0);
    _defineProperty(this, "layers", []);
    _defineProperty(this, "tile", void 0);
    _defineProperty(this, "targetBounds", null);
    _defineProperty(this, "targetBoundsCommon", null);
    this.targetLayer = targetLayer;
    this.tile = getTile(targetLayer);
  }
  get id() {
    return this.targetLayer.id;
  }
  get isActive() {
    return Boolean(this.targetLayer.getCurrentLayer());
  }
  shouldUpdate({
    targetLayer,
    viewport,
    layers,
    layerNeedsRedraw
  }) {
    if (targetLayer) {
      this.targetLayer = targetLayer;
    }
    const sizeChanged = viewport ? this._updateViewport(viewport) : false;
    let layersChanged = layers ? this._updateLayers(layers) : false;
    if (layerNeedsRedraw) {
      for (const id of this.layers) {
        if (layerNeedsRedraw[id]) {
          layersChanged = true;
          break;
        }
      }
    }
    return layersChanged || sizeChanged;
  }
  _updateLayers(layers) {
    let needsRedraw = false;
    layers = this.tile ? getIntersectingLayers(this.tile, layers) : layers;
    if (layers.length !== this.layers.length) {
      needsRedraw = true;
    } else {
      for (let i2 = 0; i2 < layers.length; i2++) {
        const id = layers[i2].id;
        if (id !== this.layers[i2]) {
          needsRedraw = true;
          break;
        }
      }
    }
    if (needsRedraw) {
      this.layers = layers.map((layer) => layer.id);
    }
    return needsRedraw;
  }
  _updateViewport(viewport) {
    const targetLayer = this.targetLayer;
    let shouldRedraw = false;
    if (this.tile && "boundingBox" in this.tile) {
      if (!this.targetBounds) {
        shouldRedraw = true;
        this.targetBounds = this.tile.boundingBox;
        const bottomLeftCommon = viewport.projectPosition(this.targetBounds[0]);
        const topRightCommon = viewport.projectPosition(this.targetBounds[1]);
        this.targetBoundsCommon = [bottomLeftCommon[0], bottomLeftCommon[1], topRightCommon[0], topRightCommon[1]];
      }
    } else if (this.targetBounds !== targetLayer.getBounds()) {
      shouldRedraw = true;
      this.targetBounds = targetLayer.getBounds();
      this.targetBoundsCommon = joinLayerBounds([targetLayer], viewport);
    }
    if (!this.targetBoundsCommon) {
      return false;
    }
    const newZoom = Math.ceil(viewport.zoom + 0.5);
    if (this.tile) {
      this.bounds = this.targetBoundsCommon;
    } else {
      var _this$renderViewport;
      const oldZoom = (_this$renderViewport = this.renderViewport) === null || _this$renderViewport === void 0 ? void 0 : _this$renderViewport.zoom;
      shouldRedraw = shouldRedraw || newZoom !== oldZoom;
      const newBounds = getRenderBounds(this.targetBoundsCommon, viewport);
      const oldBounds = this.bounds;
      shouldRedraw = shouldRedraw || !oldBounds || newBounds.some((x2, i2) => x2 !== oldBounds[i2]);
      this.bounds = newBounds;
    }
    if (shouldRedraw) {
      this.renderViewport = makeViewport({
        bounds: this.bounds,
        zoom: newZoom,
        viewport
      });
    }
    return shouldRedraw;
  }
  getRenderFramebuffer() {
    if (!this.renderViewport || this.layers.length === 0) {
      return null;
    }
    if (!this.fbo) {
      this.fbo = createRenderTarget(this.targetLayer.context.gl, {
        id: this.id
      });
    }
    return this.fbo;
  }
  getPickingFramebuffer() {
    if (!this.renderViewport || this.layers.length === 0 && !this.targetLayer.props.pickable) {
      return null;
    }
    if (!this.pickingFbo) {
      this.pickingFbo = createRenderTarget(this.targetLayer.context.gl, {
        id: "".concat(this.id, "-picking")
      });
    }
    return this.pickingFbo;
  }
  filterLayers(layers) {
    return layers.filter(({
      id
    }) => this.layers.includes(id));
  }
  delete() {
    const {
      fbo,
      pickingFbo
    } = this;
    if (fbo) {
      fbo.texture.delete();
      fbo.delete();
    }
    if (pickingFbo) {
      pickingFbo.texture.delete();
      pickingFbo.delete();
    }
  }
};
function getIntersectingLayers(sourceTile, layers) {
  return layers.filter((layer) => {
    const tile = getTile(layer);
    if (tile) {
      return intersect(sourceTile.boundingBox, tile.boundingBox);
    }
    return true;
  });
}
function getTile(layer) {
  while (layer) {
    const {
      tile
    } = layer.props;
    if (tile) {
      return tile;
    }
    layer = layer.parent;
  }
  return null;
}
function intersect(b1, b2) {
  if (b1 && b2) {
    return b1[0][0] < b2[1][0] && b2[0][0] < b1[1][0] && b1[0][1] < b2[1][1] && b2[0][1] < b1[1][1];
  }
  return false;
}

// node_modules/@deck.gl/extensions/dist/esm/terrain/terrain-pass.js
var TerrainPass = class extends LayersPass {
  getRenderableLayers(viewport, opts) {
    const {
      layers
    } = opts;
    const result = [];
    const drawParamsByIndex = this._getDrawLayerParams(viewport, opts, true);
    for (let i2 = 0; i2 < layers.length; i2++) {
      const layer = layers[i2];
      if (!layer.isComposite && drawParamsByIndex[i2].shouldDrawLayer) {
        result.push(layer);
      }
    }
    return result;
  }
  renderHeightMap(heightMap, opts) {
    const target = heightMap.getRenderFramebuffer();
    const viewport = heightMap.renderViewport;
    if (!target || !viewport) {
      return;
    }
    target.resize(viewport);
    withParameters(this.gl, {
      clearColor: [0, 0, 0, 0],
      blend: true,
      blendFunc: [1, 1],
      blendEquation: 32776,
      depthTest: false
    }, () => this.render({
      ...opts,
      target,
      pass: "terrain-height-map",
      layers: opts.layers,
      viewports: [viewport],
      effects: []
    }));
  }
  renderTerrainCover(terrainCover, opts) {
    const target = terrainCover.getRenderFramebuffer();
    const viewport = terrainCover.renderViewport;
    if (!target || !viewport) {
      return;
    }
    const layers = terrainCover.filterLayers(opts.layers);
    target.resize(viewport);
    withParameters(this.gl, {
      clearColor: [0, 0, 0, 0],
      depthTest: false
    }, () => this.render({
      ...opts,
      target,
      pass: "terrain-cover-".concat(terrainCover.id),
      layers,
      effects: [],
      viewports: [viewport]
    }));
  }
};

// node_modules/@deck.gl/extensions/dist/esm/terrain/terrain-picking-pass.js
var TerrainPickingPass = class extends PickLayersPass {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "drawParameters", {});
  }
  getRenderableLayers(viewport, opts) {
    const {
      layers
    } = opts;
    const result = [];
    this.drawParameters = {};
    this._resetColorEncoder(opts.pickZ);
    const drawParamsByIndex = this._getDrawLayerParams(viewport, opts);
    for (let i2 = 0; i2 < layers.length; i2++) {
      const layer = layers[i2];
      if (!layer.isComposite && drawParamsByIndex[i2].shouldDrawLayer) {
        result.push(layer);
        this.drawParameters[layer.id] = drawParamsByIndex[i2].layerParameters;
      }
    }
    return result;
  }
  renderTerrainCover(terrainCover, opts) {
    const target = terrainCover.getPickingFramebuffer();
    const viewport = terrainCover.renderViewport;
    if (!target || !viewport) {
      return;
    }
    const layers = terrainCover.filterLayers(opts.layers);
    const terrainLayer = terrainCover.targetLayer;
    if (terrainLayer.props.pickable) {
      layers.unshift(terrainLayer);
    }
    target.resize(viewport);
    withParameters(this.gl, {
      depthTest: false
    }, () => this.render({
      ...opts,
      pickingFBO: target,
      pass: "terrain-cover-picking-".concat(terrainCover.id),
      layers,
      effects: [],
      viewports: [viewport],
      cullRect: void 0,
      deviceRect: viewport,
      pickZ: false
    }));
  }
  getLayerParameters(layer, layerIndex, viewport) {
    if (this.drawParameters[layer.id]) {
      return this.drawParameters[layer.id];
    }
    const parameters2 = super.getLayerParameters(layer, layerIndex, viewport);
    parameters2.blend = true;
    return parameters2;
  }
};

// node_modules/@deck.gl/extensions/dist/esm/terrain/height-map-builder.js
var MAP_MAX_SIZE = 2048;
var HeightMapBuilder = class {
  static isSupported(gl) {
    return Framebuffer.isSupported(gl, {
      colorBufferFloat: true
    });
  }
  constructor(gl) {
    _defineProperty(this, "renderViewport", null);
    _defineProperty(this, "bounds", null);
    _defineProperty(this, "fbo", void 0);
    _defineProperty(this, "gl", void 0);
    _defineProperty(this, "layers", []);
    _defineProperty(this, "layersBounds", []);
    _defineProperty(this, "layersBoundsCommon", null);
    _defineProperty(this, "lastViewport", null);
    this.gl = gl;
  }
  getRenderFramebuffer() {
    if (!this.renderViewport) {
      return null;
    }
    if (!this.fbo) {
      this.fbo = createRenderTarget(this.gl, {
        id: "height-map",
        float: true
      });
    }
    return this.fbo;
  }
  shouldUpdate({
    layers,
    viewport
  }) {
    const layersChanged = layers.length !== this.layers.length || layers.some((layer, i2) => layer !== this.layers[i2] || layer.props.transitions || layer.getBounds() !== this.layersBounds[i2]);
    if (layersChanged) {
      this.layers = layers;
      this.layersBounds = layers.map((layer) => layer.getBounds());
      this.layersBoundsCommon = joinLayerBounds(layers, viewport);
    }
    const viewportChanged = !this.lastViewport || !viewport.equals(this.lastViewport);
    if (!this.layersBoundsCommon) {
      this.renderViewport = null;
    } else if (layersChanged || viewportChanged) {
      const bounds = getRenderBounds(this.layersBoundsCommon, viewport);
      if (bounds[2] <= bounds[0] || bounds[3] <= bounds[1]) {
        this.renderViewport = null;
        return false;
      }
      this.bounds = bounds;
      this.lastViewport = viewport;
      const scale = viewport.scale;
      const pixelWidth = (bounds[2] - bounds[0]) * scale;
      const pixelHeight = (bounds[3] - bounds[1]) * scale;
      this.renderViewport = pixelWidth > 0 || pixelHeight > 0 ? makeViewport({
        bounds: [viewport.center[0] - 1, viewport.center[1] - 1, viewport.center[0] + 1, viewport.center[1] + 1],
        zoom: viewport.zoom,
        width: Math.min(pixelWidth, MAP_MAX_SIZE),
        height: Math.min(pixelHeight, MAP_MAX_SIZE),
        viewport
      }) : null;
      return true;
    }
    return false;
  }
  delete() {
    if (this.fbo) {
      this.fbo.color.delete();
      this.fbo.delete();
    }
  }
};

// node_modules/@deck.gl/extensions/dist/esm/terrain/terrain-effect.js
var TerrainEffect = class {
  constructor() {
    _defineProperty(this, "id", "terrain-effect");
    _defineProperty(this, "props", null);
    _defineProperty(this, "useInPicking", true);
    _defineProperty(this, "isPicking", false);
    _defineProperty(this, "isDrapingEnabled", false);
    _defineProperty(this, "dummyHeightMap", void 0);
    _defineProperty(this, "heightMap", void 0);
    _defineProperty(this, "terrainPass", void 0);
    _defineProperty(this, "terrainPickingPass", void 0);
    _defineProperty(this, "terrainCovers", /* @__PURE__ */ new Map());
  }
  initialize(gl) {
    this.dummyHeightMap = new Texture2D(gl, {
      width: 1,
      height: 1,
      data: new Uint8Array([0, 0, 0, 0])
    });
    this.terrainPass = new TerrainPass(gl, {
      id: "terrain"
    });
    this.terrainPickingPass = new TerrainPickingPass(gl, {
      id: "terrain-picking"
    });
    if (HeightMapBuilder.isSupported(gl)) {
      this.heightMap = new HeightMapBuilder(gl);
    } else {
      log_default.warn("Terrain offset mode is not supported by this browser")();
    }
    ProgramManager.getDefaultProgramManager(gl).addDefaultModule(terrainModule);
  }
  preRender(gl, opts) {
    if (!this.dummyHeightMap) {
      this.initialize(gl);
      for (const layer of opts.layers) {
        if (layer.props.operation.includes("terrain")) {
          layer.setChangeFlags({
            extensionsChanged: true
          });
        }
      }
    }
    if (opts.pickZ) {
      this.isDrapingEnabled = false;
      return;
    }
    const {
      viewports,
      isPicking = false
    } = opts;
    this.isPicking = isPicking;
    this.isDrapingEnabled = true;
    const viewport = viewports[0];
    const layers = (isPicking ? this.terrainPickingPass : this.terrainPass).getRenderableLayers(viewport, opts);
    const terrainLayers = layers.filter((l) => l.props.operation.includes("terrain"));
    if (terrainLayers.length === 0) {
      return;
    }
    if (!isPicking) {
      const offsetLayers = layers.filter((l) => l.state.terrainDrawMode === "offset");
      if (offsetLayers.length > 0) {
        this._updateHeightMap(terrainLayers, viewport, opts);
      }
    }
    const drapeLayers = layers.filter((l) => l.state.terrainDrawMode === "drape");
    this._updateTerrainCovers(terrainLayers, drapeLayers, viewport, opts);
  }
  getModuleParameters(layer) {
    var _this$heightMap, _this$heightMap2;
    const {
      terrainDrawMode
    } = layer.state;
    return {
      heightMap: (_this$heightMap = this.heightMap) === null || _this$heightMap === void 0 ? void 0 : _this$heightMap.getRenderFramebuffer(),
      heightMapBounds: (_this$heightMap2 = this.heightMap) === null || _this$heightMap2 === void 0 ? void 0 : _this$heightMap2.bounds,
      dummyHeightMap: this.dummyHeightMap,
      terrainCover: this.isDrapingEnabled ? this.terrainCovers.get(layer.id) : null,
      useTerrainHeightMap: terrainDrawMode === "offset",
      terrainSkipRender: terrainDrawMode === "drape" || !layer.props.operation.includes("draw")
    };
  }
  cleanup() {
    if (this.dummyHeightMap) {
      this.dummyHeightMap.delete();
      this.dummyHeightMap = void 0;
    }
    if (this.heightMap) {
      this.heightMap.delete();
      this.heightMap = void 0;
    }
    for (const terrainCover of this.terrainCovers.values()) {
      terrainCover.delete();
    }
    this.terrainCovers.clear();
  }
  _updateHeightMap(terrainLayers, viewport, opts) {
    if (!this.heightMap) {
      return;
    }
    const shouldUpdate = this.heightMap.shouldUpdate({
      layers: terrainLayers,
      viewport
    });
    if (!shouldUpdate) {
      return;
    }
    this.terrainPass.renderHeightMap(this.heightMap, {
      ...opts,
      layers: terrainLayers,
      moduleParameters: {
        heightMapBounds: this.heightMap.bounds,
        dummyHeightMap: this.dummyHeightMap,
        devicePixelRatio: 1,
        drawToTerrainHeightMap: true
      }
    });
  }
  _updateTerrainCovers(terrainLayers, drapeLayers, viewport, opts) {
    const layerNeedsRedraw = {};
    for (const layer of drapeLayers) {
      if (layer.state.terrainCoverNeedsRedraw) {
        layerNeedsRedraw[layer.id] = true;
        layer.state.terrainCoverNeedsRedraw = false;
      }
    }
    for (const terrainCover of this.terrainCovers.values()) {
      terrainCover.isDirty = terrainCover.isDirty || terrainCover.shouldUpdate({
        layerNeedsRedraw
      });
    }
    for (const layer of terrainLayers) {
      this._updateTerrainCover(layer, drapeLayers, viewport, opts);
    }
    if (!this.isPicking) {
      this._pruneTerrainCovers();
    }
  }
  _updateTerrainCover(terrainLayer, drapeLayers, viewport, opts) {
    const renderPass = this.isPicking ? this.terrainPickingPass : this.terrainPass;
    let terrainCover = this.terrainCovers.get(terrainLayer.id);
    if (!terrainCover) {
      terrainCover = new TerrainCover(terrainLayer);
      this.terrainCovers.set(terrainLayer.id, terrainCover);
    }
    try {
      const isDirty = terrainCover.shouldUpdate({
        targetLayer: terrainLayer,
        viewport,
        layers: drapeLayers
      });
      if (this.isPicking || terrainCover.isDirty || isDirty) {
        renderPass.renderTerrainCover(terrainCover, {
          ...opts,
          layers: drapeLayers,
          moduleParameters: {
            dummyHeightMap: this.dummyHeightMap,
            terrainSkipRender: false,
            devicePixelRatio: 1
          }
        });
        terrainCover.isDirty = false;
      }
    } catch (err) {
      terrainLayer.raiseError(err, "Error rendering terrain cover ".concat(terrainCover.id));
    }
  }
  _pruneTerrainCovers() {
    const idsToRemove = [];
    for (const [id, terrainCover] of this.terrainCovers) {
      if (!terrainCover.isActive) {
        idsToRemove.push(id);
      }
    }
    for (const id of idsToRemove) {
      this.terrainCovers.delete(id);
    }
  }
};

// node_modules/@deck.gl/extensions/dist/esm/terrain/terrain-extension.js
var defaultProps22 = {
  terrainDrawMode: void 0
};
var TerrainExtension = class extends LayerExtension {
  getShaders() {
    return {
      modules: [terrainModule]
    };
  }
  initializeState() {
    var _this$context$deck;
    (_this$context$deck = this.context.deck) === null || _this$context$deck === void 0 ? void 0 : _this$context$deck._addDefaultEffect(new TerrainEffect());
  }
  updateState(params) {
    const {
      props,
      oldProps
    } = params;
    if (this.state.terrainDrawMode && props.terrainDrawMode === oldProps.terrainDrawMode && props.extruded === oldProps.extruded) {
      return;
    }
    let {
      terrainDrawMode
    } = props;
    if (!terrainDrawMode) {
      var _this$getAttributeMan;
      const is3d = this.props.extruded;
      const attributes = (_this$getAttributeMan = this.getAttributeManager()) === null || _this$getAttributeMan === void 0 ? void 0 : _this$getAttributeMan.attributes;
      const hasAnchor = attributes && "instancePositions" in attributes;
      terrainDrawMode = is3d || hasAnchor ? "offset" : "drape";
    }
    this.setState({
      terrainDrawMode
    });
  }
  onNeedsRedraw() {
    const state = this.state;
    if (state.terrainDrawMode === "drape") {
      state.terrainCoverNeedsRedraw = true;
    }
  }
};
_defineProperty(TerrainExtension, "defaultProps", defaultProps22);
_defineProperty(TerrainExtension, "extensionName", "TerrainExtension");

// node_modules/@loaders.gl/gis/dist/esm/lib/flat-geojson-to-binary.js
function flatGeojsonToBinary(features, geometryInfo, options) {
  const propArrayTypes = extractNumericPropTypes(features);
  const numericPropKeys = Object.keys(propArrayTypes).filter((k) => propArrayTypes[k] !== Array);
  return fillArrays(features, {
    propArrayTypes,
    ...geometryInfo
  }, {
    numericPropKeys: options && options.numericPropKeys || numericPropKeys,
    PositionDataType: options ? options.PositionDataType : Float32Array,
    triangulate: options ? options.triangulate : true
  });
}
function extractNumericPropTypes(features) {
  const propArrayTypes = {};
  for (const feature2 of features) {
    if (feature2.properties) {
      for (const key in feature2.properties) {
        const val2 = feature2.properties[key];
        propArrayTypes[key] = deduceArrayType(val2, propArrayTypes[key]);
      }
    }
  }
  return propArrayTypes;
}
function fillArrays(features, geometryInfo, options) {
  const {
    pointPositionsCount,
    pointFeaturesCount,
    linePositionsCount,
    linePathsCount,
    lineFeaturesCount,
    polygonPositionsCount,
    polygonObjectsCount,
    polygonRingsCount,
    polygonFeaturesCount,
    propArrayTypes,
    coordLength
  } = geometryInfo;
  const {
    numericPropKeys = [],
    PositionDataType = Float32Array,
    triangulate = true
  } = options;
  const hasGlobalId = features[0] && "id" in features[0];
  const GlobalFeatureIdsDataType = features.length > 65535 ? Uint32Array : Uint16Array;
  const points = {
    type: "Point",
    positions: new PositionDataType(pointPositionsCount * coordLength),
    globalFeatureIds: new GlobalFeatureIdsDataType(pointPositionsCount),
    featureIds: pointFeaturesCount > 65535 ? new Uint32Array(pointPositionsCount) : new Uint16Array(pointPositionsCount),
    numericProps: {},
    properties: [],
    fields: []
  };
  const lines = {
    type: "LineString",
    pathIndices: linePositionsCount > 65535 ? new Uint32Array(linePathsCount + 1) : new Uint16Array(linePathsCount + 1),
    positions: new PositionDataType(linePositionsCount * coordLength),
    globalFeatureIds: new GlobalFeatureIdsDataType(linePositionsCount),
    featureIds: lineFeaturesCount > 65535 ? new Uint32Array(linePositionsCount) : new Uint16Array(linePositionsCount),
    numericProps: {},
    properties: [],
    fields: []
  };
  const polygons = {
    type: "Polygon",
    polygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonObjectsCount + 1) : new Uint16Array(polygonObjectsCount + 1),
    primitivePolygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonRingsCount + 1) : new Uint16Array(polygonRingsCount + 1),
    positions: new PositionDataType(polygonPositionsCount * coordLength),
    globalFeatureIds: new GlobalFeatureIdsDataType(polygonPositionsCount),
    featureIds: polygonFeaturesCount > 65535 ? new Uint32Array(polygonPositionsCount) : new Uint16Array(polygonPositionsCount),
    numericProps: {},
    properties: [],
    fields: []
  };
  if (triangulate) {
    polygons.triangles = [];
  }
  for (const object of [points, lines, polygons]) {
    for (const propName of numericPropKeys) {
      const T = propArrayTypes[propName];
      object.numericProps[propName] = new T(object.positions.length / coordLength);
    }
  }
  lines.pathIndices[linePathsCount] = linePositionsCount;
  polygons.polygonIndices[polygonObjectsCount] = polygonPositionsCount;
  polygons.primitivePolygonIndices[polygonRingsCount] = polygonPositionsCount;
  const indexMap = {
    pointPosition: 0,
    pointFeature: 0,
    linePosition: 0,
    linePath: 0,
    lineFeature: 0,
    polygonPosition: 0,
    polygonObject: 0,
    polygonRing: 0,
    polygonFeature: 0,
    feature: 0
  };
  for (const feature2 of features) {
    const geometry = feature2.geometry;
    const properties = feature2.properties || {};
    switch (geometry.type) {
      case "Point":
        handlePoint(geometry, points, indexMap, coordLength, properties);
        points.properties.push(keepStringProperties(properties, numericPropKeys));
        if (hasGlobalId) {
          points.fields.push({
            id: feature2.id
          });
        }
        indexMap.pointFeature++;
        break;
      case "LineString":
        handleLineString(geometry, lines, indexMap, coordLength, properties);
        lines.properties.push(keepStringProperties(properties, numericPropKeys));
        if (hasGlobalId) {
          lines.fields.push({
            id: feature2.id
          });
        }
        indexMap.lineFeature++;
        break;
      case "Polygon":
        handlePolygon(geometry, polygons, indexMap, coordLength, properties);
        polygons.properties.push(keepStringProperties(properties, numericPropKeys));
        if (hasGlobalId) {
          polygons.fields.push({
            id: feature2.id
          });
        }
        indexMap.polygonFeature++;
        break;
      default:
        throw new Error("Invalid geometry type");
    }
    indexMap.feature++;
  }
  return makeAccessorObjects(points, lines, polygons, coordLength);
}
function handlePoint(geometry, points, indexMap, coordLength, properties) {
  points.positions.set(geometry.data, indexMap.pointPosition * coordLength);
  const nPositions = geometry.data.length / coordLength;
  fillNumericProperties(points, properties, indexMap.pointPosition, nPositions);
  points.globalFeatureIds.fill(indexMap.feature, indexMap.pointPosition, indexMap.pointPosition + nPositions);
  points.featureIds.fill(indexMap.pointFeature, indexMap.pointPosition, indexMap.pointPosition + nPositions);
  indexMap.pointPosition += nPositions;
}
function handleLineString(geometry, lines, indexMap, coordLength, properties) {
  lines.positions.set(geometry.data, indexMap.linePosition * coordLength);
  const nPositions = geometry.data.length / coordLength;
  fillNumericProperties(lines, properties, indexMap.linePosition, nPositions);
  lines.globalFeatureIds.fill(indexMap.feature, indexMap.linePosition, indexMap.linePosition + nPositions);
  lines.featureIds.fill(indexMap.lineFeature, indexMap.linePosition, indexMap.linePosition + nPositions);
  for (let i2 = 0, il = geometry.indices.length; i2 < il; ++i2) {
    const start = geometry.indices[i2];
    const end = i2 === il - 1 ? geometry.data.length : geometry.indices[i2 + 1];
    lines.pathIndices[indexMap.linePath++] = indexMap.linePosition;
    indexMap.linePosition += (end - start) / coordLength;
  }
}
function handlePolygon(geometry, polygons, indexMap, coordLength, properties) {
  polygons.positions.set(geometry.data, indexMap.polygonPosition * coordLength);
  const nPositions = geometry.data.length / coordLength;
  fillNumericProperties(polygons, properties, indexMap.polygonPosition, nPositions);
  polygons.globalFeatureIds.fill(indexMap.feature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);
  polygons.featureIds.fill(indexMap.polygonFeature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);
  for (let l = 0, ll = geometry.indices.length; l < ll; ++l) {
    const startPosition = indexMap.polygonPosition;
    polygons.polygonIndices[indexMap.polygonObject++] = startPosition;
    const areas = geometry.areas[l];
    const indices = geometry.indices[l];
    const nextIndices = geometry.indices[l + 1];
    for (let i2 = 0, il = indices.length; i2 < il; ++i2) {
      const start = indices[i2];
      const end = i2 === il - 1 ? nextIndices === void 0 ? geometry.data.length : nextIndices[0] : indices[i2 + 1];
      polygons.primitivePolygonIndices[indexMap.polygonRing++] = indexMap.polygonPosition;
      indexMap.polygonPosition += (end - start) / coordLength;
    }
    const endPosition = indexMap.polygonPosition;
    triangulatePolygon(polygons, areas, indices, {
      startPosition,
      endPosition,
      coordLength
    });
  }
}
function triangulatePolygon(polygons, areas, indices, _ref) {
  let {
    startPosition,
    endPosition,
    coordLength
  } = _ref;
  if (!polygons.triangles) {
    return;
  }
  const start = startPosition * coordLength;
  const end = endPosition * coordLength;
  const polygonPositions = polygons.positions.subarray(start, end);
  const offset = indices[0];
  const holes = indices.slice(1).map((n) => (n - offset) / coordLength);
  const triangles = earcut(polygonPositions, holes, coordLength, areas);
  for (let t = 0, tl = triangles.length; t < tl; ++t) {
    polygons.triangles.push(startPosition + triangles[t]);
  }
}
function wrapProps(obj, size) {
  const returnObj = {};
  for (const key in obj) {
    returnObj[key] = {
      value: obj[key],
      size
    };
  }
  return returnObj;
}
function makeAccessorObjects(points, lines, polygons, coordLength) {
  const binaryFeatures = {
    points: {
      ...points,
      positions: {
        value: points.positions,
        size: coordLength
      },
      globalFeatureIds: {
        value: points.globalFeatureIds,
        size: 1
      },
      featureIds: {
        value: points.featureIds,
        size: 1
      },
      numericProps: wrapProps(points.numericProps, 1)
    },
    lines: {
      ...lines,
      positions: {
        value: lines.positions,
        size: coordLength
      },
      pathIndices: {
        value: lines.pathIndices,
        size: 1
      },
      globalFeatureIds: {
        value: lines.globalFeatureIds,
        size: 1
      },
      featureIds: {
        value: lines.featureIds,
        size: 1
      },
      numericProps: wrapProps(lines.numericProps, 1)
    },
    polygons: {
      ...polygons,
      positions: {
        value: polygons.positions,
        size: coordLength
      },
      polygonIndices: {
        value: polygons.polygonIndices,
        size: 1
      },
      primitivePolygonIndices: {
        value: polygons.primitivePolygonIndices,
        size: 1
      },
      globalFeatureIds: {
        value: polygons.globalFeatureIds,
        size: 1
      },
      featureIds: {
        value: polygons.featureIds,
        size: 1
      },
      numericProps: wrapProps(polygons.numericProps, 1)
    }
  };
  if (polygons.triangles) {
    binaryFeatures.polygons.triangles = {
      value: new Uint32Array(polygons.triangles),
      size: 1
    };
  }
  return binaryFeatures;
}
function fillNumericProperties(object, properties, index, length2) {
  for (const numericPropName in object.numericProps) {
    if (numericPropName in properties) {
      const value = properties[numericPropName];
      object.numericProps[numericPropName].fill(value, index, index + length2);
    }
  }
}
function keepStringProperties(properties, numericKeys) {
  const props = {};
  for (const key in properties) {
    if (!numericKeys.includes(key)) {
      props[key] = properties[key];
    }
  }
  return props;
}
function deduceArrayType(x2, constructor) {
  if (constructor === Array || !Number.isFinite(x2)) {
    return Array;
  }
  return constructor === Float64Array || Math.fround(x2) !== x2 ? Float64Array : Float32Array;
}

// node_modules/@loaders.gl/gis/dist/esm/lib/binary-to-geojson.js
function binaryToGeojson(data, options) {
  const globalFeatureId = options === null || options === void 0 ? void 0 : options.globalFeatureId;
  if (globalFeatureId !== void 0) {
    return getSingleFeature(data, globalFeatureId);
  }
  return parseFeatures(data, options === null || options === void 0 ? void 0 : options.type);
}
function getSingleFeature(data, globalFeatureId) {
  const dataArray = normalizeInput(data);
  for (const data2 of dataArray) {
    let lastIndex = 0;
    let lastValue = data2.featureIds.value[0];
    for (let i2 = 0; i2 < data2.featureIds.value.length; i2++) {
      const currValue = data2.featureIds.value[i2];
      if (currValue === lastValue) {
        continue;
      }
      if (globalFeatureId === data2.globalFeatureIds.value[lastIndex]) {
        return parseFeature(data2, lastIndex, i2);
      }
      lastIndex = i2;
      lastValue = currValue;
    }
    if (globalFeatureId === data2.globalFeatureIds.value[lastIndex]) {
      return parseFeature(data2, lastIndex, data2.featureIds.value.length);
    }
  }
  throw new Error("featureId:".concat(globalFeatureId, " not found"));
}
function parseFeatures(data, type) {
  const dataArray = normalizeInput(data, type);
  return parseFeatureCollection(dataArray);
}
function binaryToGeometry(data, startIndex, endIndex) {
  switch (data.type) {
    case "Point":
      return pointToGeoJson(data, startIndex, endIndex);
    case "LineString":
      return lineStringToGeoJson(data, startIndex, endIndex);
    case "Polygon":
      return polygonToGeoJson(data, startIndex, endIndex);
    default:
      const unexpectedInput = data;
      throw new Error("Unsupported geometry type: ".concat(unexpectedInput === null || unexpectedInput === void 0 ? void 0 : unexpectedInput.type));
  }
}
function normalizeInput(data, type) {
  const isHeterogeneousType = Boolean(data.points || data.lines || data.polygons);
  if (!isHeterogeneousType) {
    data.type = type || parseType(data);
    return [data];
  }
  const features = [];
  if (data.points) {
    data.points.type = "Point";
    features.push(data.points);
  }
  if (data.lines) {
    data.lines.type = "LineString";
    features.push(data.lines);
  }
  if (data.polygons) {
    data.polygons.type = "Polygon";
    features.push(data.polygons);
  }
  return features;
}
function parseFeatureCollection(dataArray) {
  const features = [];
  for (const data of dataArray) {
    if (data.featureIds.value.length === 0) {
      continue;
    }
    let lastIndex = 0;
    let lastValue = data.featureIds.value[0];
    for (let i2 = 0; i2 < data.featureIds.value.length; i2++) {
      const currValue = data.featureIds.value[i2];
      if (currValue === lastValue) {
        continue;
      }
      features.push(parseFeature(data, lastIndex, i2));
      lastIndex = i2;
      lastValue = currValue;
    }
    features.push(parseFeature(data, lastIndex, data.featureIds.value.length));
  }
  return features;
}
function parseFeature(data, startIndex, endIndex) {
  const geometry = binaryToGeometry(data, startIndex, endIndex);
  const properties = parseProperties(data, startIndex, endIndex);
  const fields = parseFields(data, startIndex, endIndex);
  return {
    type: "Feature",
    geometry,
    properties,
    ...fields
  };
}
function parseFields(data) {
  let startIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  let endIndex = arguments.length > 2 ? arguments[2] : void 0;
  return data.fields && data.fields[data.featureIds.value[startIndex]];
}
function parseProperties(data) {
  let startIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  let endIndex = arguments.length > 2 ? arguments[2] : void 0;
  const properties = Object.assign({}, data.properties[data.featureIds.value[startIndex]]);
  for (const key in data.numericProps) {
    properties[key] = data.numericProps[key].value[startIndex];
  }
  return properties;
}
function polygonToGeoJson(data) {
  let startIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -Infinity;
  let endIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Infinity;
  const {
    positions
  } = data;
  const polygonIndices = data.polygonIndices.value.filter((x2) => x2 >= startIndex && x2 <= endIndex);
  const primitivePolygonIndices = data.primitivePolygonIndices.value.filter((x2) => x2 >= startIndex && x2 <= endIndex);
  const multi = polygonIndices.length > 2;
  if (!multi) {
    const coordinates2 = [];
    for (let i2 = 0; i2 < primitivePolygonIndices.length - 1; i2++) {
      const startRingIndex = primitivePolygonIndices[i2];
      const endRingIndex = primitivePolygonIndices[i2 + 1];
      const ringCoordinates = ringToGeoJson(positions, startRingIndex, endRingIndex);
      coordinates2.push(ringCoordinates);
    }
    return {
      type: "Polygon",
      coordinates: coordinates2
    };
  }
  const coordinates = [];
  for (let i2 = 0; i2 < polygonIndices.length - 1; i2++) {
    const startPolygonIndex = polygonIndices[i2];
    const endPolygonIndex = polygonIndices[i2 + 1];
    const polygonCoordinates = polygonToGeoJson(data, startPolygonIndex, endPolygonIndex).coordinates;
    coordinates.push(polygonCoordinates);
  }
  return {
    type: "MultiPolygon",
    coordinates
  };
}
function lineStringToGeoJson(data) {
  let startIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -Infinity;
  let endIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Infinity;
  const {
    positions
  } = data;
  const pathIndices = data.pathIndices.value.filter((x2) => x2 >= startIndex && x2 <= endIndex);
  const multi = pathIndices.length > 2;
  if (!multi) {
    const coordinates2 = ringToGeoJson(positions, pathIndices[0], pathIndices[1]);
    return {
      type: "LineString",
      coordinates: coordinates2
    };
  }
  const coordinates = [];
  for (let i2 = 0; i2 < pathIndices.length - 1; i2++) {
    const ringCoordinates = ringToGeoJson(positions, pathIndices[i2], pathIndices[i2 + 1]);
    coordinates.push(ringCoordinates);
  }
  return {
    type: "MultiLineString",
    coordinates
  };
}
function pointToGeoJson(data, startIndex, endIndex) {
  const {
    positions
  } = data;
  const coordinates = ringToGeoJson(positions, startIndex, endIndex);
  const multi = coordinates.length > 1;
  if (multi) {
    return {
      type: "MultiPoint",
      coordinates
    };
  }
  return {
    type: "Point",
    coordinates: coordinates[0]
  };
}
function ringToGeoJson(positions, startIndex, endIndex) {
  startIndex = startIndex || 0;
  endIndex = endIndex || positions.value.length / positions.size;
  const ringCoordinates = [];
  for (let j = startIndex; j < endIndex; j++) {
    const coord = Array();
    for (let k = j * positions.size; k < (j + 1) * positions.size; k++) {
      coord.push(Number(positions.value[k]));
    }
    ringCoordinates.push(coord);
  }
  return ringCoordinates;
}
function parseType(data) {
  if (data.pathIndices) {
    return "LineString";
  }
  if (data.polygonIndices) {
    return "Polygon";
  }
  return "Point";
}

// node_modules/@loaders.gl/mvt/dist/esm/lib/parse-mvt.js
var import_pbf = __toESM(require_pbf());

// node_modules/@loaders.gl/mvt/dist/esm/helpers/mapbox-util-functions.js
function classifyRings(rings) {
  const len = rings.length;
  if (len <= 1)
    return [rings];
  const polygons = [];
  let polygon;
  let ccw;
  for (let i2 = 0; i2 < len; i2++) {
    const area = signedArea(rings[i2]);
    if (area === 0)
      continue;
    if (ccw === void 0)
      ccw = area < 0;
    if (ccw === area < 0) {
      if (polygon)
        polygons.push(polygon);
      polygon = [rings[i2]];
    } else if (polygon)
      polygon.push(rings[i2]);
  }
  if (polygon)
    polygons.push(polygon);
  return polygons;
}
function signedArea(ring) {
  let sum = 0;
  for (let i2 = 0, j = ring.length - 1, p1, p2; i2 < ring.length; j = i2++) {
    p1 = ring[i2];
    p2 = ring[j];
    sum += (p2[0] - p1[0]) * (p1[1] + p2[1]);
  }
  return sum;
}
function readFeature(tag, feature2, pbf) {
  if (feature2 && pbf) {
    if (tag === 1)
      feature2.id = pbf.readVarint();
    else if (tag === 2)
      readTag(pbf, feature2);
    else if (tag === 3)
      feature2.type = pbf.readVarint();
    else if (tag === 4)
      feature2._geometry = pbf.pos;
  }
}
function readTag(pbf, feature2) {
  const end = pbf.readVarint() + pbf.pos;
  while (pbf.pos < end) {
    const key = feature2._keys[pbf.readVarint()];
    const value = feature2._values[pbf.readVarint()];
    feature2.properties[key] = value;
  }
}

// node_modules/@loaders.gl/mvt/dist/esm/lib/mapbox-vector-tile/vector-tile-feature.js
var VectorTileFeature = class _VectorTileFeature {
  static get types() {
    return ["Unknown", "Point", "LineString", "Polygon"];
  }
  constructor(pbf, end, extent, keys, values) {
    _defineProperty(this, "properties", void 0);
    _defineProperty(this, "extent", void 0);
    _defineProperty(this, "type", void 0);
    _defineProperty(this, "id", void 0);
    _defineProperty(this, "_pbf", void 0);
    _defineProperty(this, "_geometry", void 0);
    _defineProperty(this, "_keys", void 0);
    _defineProperty(this, "_values", void 0);
    this.properties = {};
    this.extent = extent;
    this.type = 0;
    this.id = null;
    this._pbf = pbf;
    this._geometry = -1;
    this._keys = keys;
    this._values = values;
    pbf.readFields(readFeature, this, end);
  }
  loadGeometry() {
    const pbf = this._pbf;
    pbf.pos = this._geometry;
    const end = pbf.readVarint() + pbf.pos;
    let cmd2 = 1;
    let length2 = 0;
    let x2 = 0;
    let y2 = 0;
    const lines = [];
    let line;
    while (pbf.pos < end) {
      if (length2 <= 0) {
        const cmdLen2 = pbf.readVarint();
        cmd2 = cmdLen2 & 7;
        length2 = cmdLen2 >> 3;
      }
      length2--;
      if (cmd2 === 1 || cmd2 === 2) {
        x2 += pbf.readSVarint();
        y2 += pbf.readSVarint();
        if (cmd2 === 1) {
          if (line)
            lines.push(line);
          line = [];
        }
        if (line)
          line.push([x2, y2]);
      } else if (cmd2 === 7) {
        if (line) {
          line.push(line[0].slice());
        }
      } else {
        throw new Error("unknown command ".concat(cmd2));
      }
    }
    if (line)
      lines.push(line);
    return lines;
  }
  bbox() {
    const pbf = this._pbf;
    pbf.pos = this._geometry;
    const end = pbf.readVarint() + pbf.pos;
    let cmd2 = 1;
    let length2 = 0;
    let x2 = 0;
    let y2 = 0;
    let x1 = Infinity;
    let x22 = -Infinity;
    let y1 = Infinity;
    let y22 = -Infinity;
    while (pbf.pos < end) {
      if (length2 <= 0) {
        const cmdLen2 = pbf.readVarint();
        cmd2 = cmdLen2 & 7;
        length2 = cmdLen2 >> 3;
      }
      length2--;
      if (cmd2 === 1 || cmd2 === 2) {
        x2 += pbf.readSVarint();
        y2 += pbf.readSVarint();
        if (x2 < x1)
          x1 = x2;
        if (x2 > x22)
          x22 = x2;
        if (y2 < y1)
          y1 = y2;
        if (y2 > y22)
          y22 = y2;
      } else if (cmd2 !== 7) {
        throw new Error("unknown command ".concat(cmd2));
      }
    }
    return [x1, y1, x22, y22];
  }
  _toGeoJSON(transform2) {
    let coords = this.loadGeometry();
    let type = _VectorTileFeature.types[this.type];
    let i2;
    let j;
    switch (this.type) {
      case 1:
        const points = [];
        for (i2 = 0; i2 < coords.length; i2++) {
          points[i2] = coords[i2][0];
        }
        coords = points;
        transform2(coords, this);
        break;
      case 2:
        for (i2 = 0; i2 < coords.length; i2++) {
          transform2(coords[i2], this);
        }
        break;
      case 3:
        coords = classifyRings(coords);
        for (i2 = 0; i2 < coords.length; i2++) {
          for (j = 0; j < coords[i2].length; j++) {
            transform2(coords[i2][j], this);
          }
        }
        break;
    }
    if (coords.length === 1) {
      coords = coords[0];
    } else {
      type = "Multi".concat(type);
    }
    const result = {
      type: "Feature",
      geometry: {
        type,
        coordinates: coords
      },
      properties: this.properties
    };
    if (this.id !== null) {
      result.id = this.id;
    }
    return result;
  }
  toGeoJSON(options) {
    if (typeof options === "function") {
      return this._toGeoJSON(options);
    }
    const {
      x: x2,
      y: y2,
      z
    } = options;
    const size = this.extent * Math.pow(2, z);
    const x0 = this.extent * x2;
    const y0 = this.extent * y2;
    function project2(line) {
      for (let j = 0; j < line.length; j++) {
        const p = line[j];
        p[0] = (p[0] + x0) * 360 / size - 180;
        const y22 = 180 - (p[1] + y0) * 360 / size;
        p[1] = 360 / Math.PI * Math.atan(Math.exp(y22 * Math.PI / 180)) - 90;
      }
    }
    return this._toGeoJSON(project2);
  }
};

// node_modules/@loaders.gl/mvt/dist/esm/lib/mapbox-vector-tile/vector-tile-layer.js
var VectorTileLayer = class {
  constructor(pbf, end) {
    _defineProperty(this, "version", void 0);
    _defineProperty(this, "name", void 0);
    _defineProperty(this, "extent", void 0);
    _defineProperty(this, "length", void 0);
    _defineProperty(this, "_pbf", void 0);
    _defineProperty(this, "_keys", void 0);
    _defineProperty(this, "_values", void 0);
    _defineProperty(this, "_features", void 0);
    this.version = 1;
    this.name = "";
    this.extent = 4096;
    this.length = 0;
    this._pbf = pbf;
    this._keys = [];
    this._values = [];
    this._features = [];
    pbf.readFields(readLayer, this, end);
    this.length = this._features.length;
  }
  feature(i2) {
    if (i2 < 0 || i2 >= this._features.length) {
      throw new Error("feature index out of bounds");
    }
    this._pbf.pos = this._features[i2];
    const end = this._pbf.readVarint() + this._pbf.pos;
    return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values);
  }
};
function readLayer(tag, layer, pbf) {
  if (layer && pbf) {
    if (tag === 15)
      layer.version = pbf.readVarint();
    else if (tag === 1)
      layer.name = pbf.readString();
    else if (tag === 5)
      layer.extent = pbf.readVarint();
    else if (tag === 2)
      layer._features.push(pbf.pos);
    else if (tag === 3)
      layer._keys.push(pbf.readString());
    else if (tag === 4)
      layer._values.push(readValueMessage(pbf));
  }
}
function readValueMessage(pbf) {
  let value = null;
  const end = pbf.readVarint() + pbf.pos;
  while (pbf.pos < end) {
    const tag = pbf.readVarint() >> 3;
    value = tag === 1 ? pbf.readString() : tag === 2 ? pbf.readFloat() : tag === 3 ? pbf.readDouble() : tag === 4 ? pbf.readVarint64() : tag === 5 ? pbf.readVarint() : tag === 6 ? pbf.readSVarint() : tag === 7 ? pbf.readBoolean() : null;
  }
  return value;
}

// node_modules/@loaders.gl/mvt/dist/esm/lib/mapbox-vector-tile/vector-tile.js
var VectorTile = class {
  constructor(pbf, end) {
    _defineProperty(this, "layers", void 0);
    this.layers = pbf.readFields(readTile, {}, end);
  }
};
function readTile(tag, layers, pbf) {
  if (tag === 3) {
    if (pbf) {
      const layer = new VectorTileLayer(pbf, pbf.readVarint() + pbf.pos);
      if (layer.length && layers) {
        layers[layer.name] = layer;
      }
    }
  }
}

// node_modules/@loaders.gl/mvt/dist/esm/helpers/binary-util-functions.js
function classifyRings2(geom) {
  const len = geom.indices.length;
  const type = "Polygon";
  if (len <= 1) {
    return {
      type,
      data: geom.data,
      areas: [[getPolygonSignedArea(geom.data)]],
      indices: [geom.indices]
    };
  }
  const areas = [];
  const polygons = [];
  let ringAreas = [];
  let polygon = [];
  let ccw;
  let offset = 0;
  for (let endIndex, i2 = 0, startIndex; i2 < len; i2++) {
    startIndex = geom.indices[i2] - offset;
    endIndex = geom.indices[i2 + 1] - offset || geom.data.length;
    const shape = geom.data.slice(startIndex, endIndex);
    const area = getPolygonSignedArea(shape);
    if (area === 0) {
      const before = geom.data.slice(0, startIndex);
      const after = geom.data.slice(endIndex);
      geom.data = before.concat(after);
      offset += endIndex - startIndex;
      continue;
    }
    if (ccw === void 0)
      ccw = area < 0;
    if (ccw === area < 0) {
      if (polygon.length) {
        areas.push(ringAreas);
        polygons.push(polygon);
      }
      polygon = [startIndex];
      ringAreas = [area];
    } else {
      ringAreas.push(area);
      polygon.push(startIndex);
    }
  }
  if (ringAreas)
    areas.push(ringAreas);
  if (polygon.length)
    polygons.push(polygon);
  return {
    type,
    areas,
    indices: polygons,
    data: geom.data
  };
}
function project(data, x0, y0, size) {
  for (let j = 0, jl = data.length; j < jl; j += 2) {
    data[j] = (data[j] + x0) * 360 / size - 180;
    const y2 = 180 - (data[j + 1] + y0) * 360 / size;
    data[j + 1] = 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;
  }
}
function readFeature2(tag, feature2, pbf) {
  if (feature2 && pbf) {
    if (tag === 1)
      feature2.id = pbf.readVarint();
    else if (tag === 2)
      readTag2(pbf, feature2);
    else if (tag === 3)
      feature2.type = pbf.readVarint();
    else if (tag === 4)
      feature2._geometry = pbf.pos;
  }
}
function readTag2(pbf, feature2) {
  const end = pbf.readVarint() + pbf.pos;
  while (pbf.pos < end) {
    const key = feature2._keys[pbf.readVarint()];
    const value = feature2._values[pbf.readVarint()];
    feature2.properties[key] = value;
  }
}

// node_modules/@loaders.gl/mvt/dist/esm/lib/binary-vector-tile/vector-tile-feature.js
var endPos;
var cmd;
var cmdLen;
var length;
var x;
var y;
var i;
var VectorTileFeature2 = class {
  constructor(pbf, end, extent, keys, values, geometryInfo) {
    _defineProperty(this, "properties", void 0);
    _defineProperty(this, "extent", void 0);
    _defineProperty(this, "type", void 0);
    _defineProperty(this, "id", void 0);
    _defineProperty(this, "_pbf", void 0);
    _defineProperty(this, "_geometry", void 0);
    _defineProperty(this, "_keys", void 0);
    _defineProperty(this, "_values", void 0);
    _defineProperty(this, "_geometryInfo", void 0);
    this.properties = {};
    this.extent = extent;
    this.type = 0;
    this.id = null;
    this._pbf = pbf;
    this._geometry = -1;
    this._keys = keys;
    this._values = values;
    this._geometryInfo = geometryInfo;
    pbf.readFields(readFeature2, this, end);
  }
  loadGeometry() {
    const pbf = this._pbf;
    pbf.pos = this._geometry;
    endPos = pbf.readVarint() + pbf.pos;
    cmd = 1;
    length = 0;
    x = 0;
    y = 0;
    i = 0;
    const indices = [];
    const data = [];
    while (pbf.pos < endPos) {
      if (length <= 0) {
        cmdLen = pbf.readVarint();
        cmd = cmdLen & 7;
        length = cmdLen >> 3;
      }
      length--;
      if (cmd === 1 || cmd === 2) {
        x += pbf.readSVarint();
        y += pbf.readSVarint();
        if (cmd === 1) {
          indices.push(i);
        }
        data.push(x, y);
        i += 2;
      } else if (cmd === 7) {
        if (i > 0) {
          const start = indices[indices.length - 1];
          data.push(data[start], data[start + 1]);
          i += 2;
        }
      } else {
        throw new Error("unknown command ".concat(cmd));
      }
    }
    return {
      data,
      indices
    };
  }
  _toBinaryCoordinates(transform2) {
    const geom = this.loadGeometry();
    let geometry;
    transform2(geom.data, this);
    const coordLength = 2;
    switch (this.type) {
      case 1:
        this._geometryInfo.pointFeaturesCount++;
        this._geometryInfo.pointPositionsCount += geom.indices.length;
        geometry = {
          type: "Point",
          ...geom
        };
        break;
      case 2:
        this._geometryInfo.lineFeaturesCount++;
        this._geometryInfo.linePathsCount += geom.indices.length;
        this._geometryInfo.linePositionsCount += geom.data.length / coordLength;
        geometry = {
          type: "LineString",
          ...geom
        };
        break;
      case 3:
        geometry = classifyRings2(geom);
        this._geometryInfo.polygonFeaturesCount++;
        this._geometryInfo.polygonObjectsCount += geometry.indices.length;
        for (const indices of geometry.indices) {
          this._geometryInfo.polygonRingsCount += indices.length;
        }
        this._geometryInfo.polygonPositionsCount += geometry.data.length / coordLength;
        break;
      default:
        throw new Error("Invalid geometry type: ".concat(this.type));
    }
    const result = {
      type: "Feature",
      geometry,
      properties: this.properties
    };
    if (this.id !== null) {
      result.id = this.id;
    }
    return result;
  }
  toBinaryCoordinates(options) {
    if (typeof options === "function") {
      return this._toBinaryCoordinates(options);
    }
    const {
      x: x2,
      y: y2,
      z
    } = options;
    const size = this.extent * Math.pow(2, z);
    const x0 = this.extent * x2;
    const y0 = this.extent * y2;
    return this._toBinaryCoordinates((data) => project(data, x0, y0, size));
  }
};

// node_modules/@loaders.gl/mvt/dist/esm/lib/binary-vector-tile/vector-tile-layer.js
var VectorTileLayer2 = class {
  constructor(pbf, end) {
    _defineProperty(this, "version", void 0);
    _defineProperty(this, "name", void 0);
    _defineProperty(this, "extent", void 0);
    _defineProperty(this, "length", void 0);
    _defineProperty(this, "_pbf", void 0);
    _defineProperty(this, "_keys", void 0);
    _defineProperty(this, "_values", void 0);
    _defineProperty(this, "_features", void 0);
    this.version = 1;
    this.name = "";
    this.extent = 4096;
    this.length = 0;
    this._pbf = pbf;
    this._keys = [];
    this._values = [];
    this._features = [];
    pbf.readFields(readLayer2, this, end);
    this.length = this._features.length;
  }
  feature(i2, geometryInfo) {
    if (i2 < 0 || i2 >= this._features.length) {
      throw new Error("feature index out of bounds");
    }
    this._pbf.pos = this._features[i2];
    const end = this._pbf.readVarint() + this._pbf.pos;
    return new VectorTileFeature2(this._pbf, end, this.extent, this._keys, this._values, geometryInfo);
  }
};
function readLayer2(tag, layer, pbf) {
  if (layer && pbf) {
    if (tag === 15)
      layer.version = pbf.readVarint();
    else if (tag === 1)
      layer.name = pbf.readString();
    else if (tag === 5)
      layer.extent = pbf.readVarint();
    else if (tag === 2)
      layer._features.push(pbf.pos);
    else if (tag === 3)
      layer._keys.push(pbf.readString());
    else if (tag === 4)
      layer._values.push(readValueMessage2(pbf));
  }
}
function readValueMessage2(pbf) {
  let value = null;
  const end = pbf.readVarint() + pbf.pos;
  while (pbf.pos < end) {
    const tag = pbf.readVarint() >> 3;
    value = tag === 1 ? pbf.readString() : tag === 2 ? pbf.readFloat() : tag === 3 ? pbf.readDouble() : tag === 4 ? pbf.readVarint64() : tag === 5 ? pbf.readVarint() : tag === 6 ? pbf.readSVarint() : tag === 7 ? pbf.readBoolean() : null;
  }
  return value;
}

// node_modules/@loaders.gl/mvt/dist/esm/lib/binary-vector-tile/vector-tile.js
var VectorTile2 = class {
  constructor(pbf, end) {
    _defineProperty(this, "layers", void 0);
    this.layers = pbf.readFields(readTile2, {}, end);
  }
};
function readTile2(tag, layers, pbf) {
  if (tag === 3) {
    if (pbf) {
      const layer = new VectorTileLayer2(pbf, pbf.readVarint() + pbf.pos);
      if (layer.length && layers) {
        layers[layer.name] = layer;
      }
    }
  }
}

// node_modules/@loaders.gl/mvt/dist/esm/lib/parse-mvt.js
function parseMVT(arrayBuffer, options) {
  var _options$gis, _options$mvt;
  const mvtOptions = normalizeOptions(options);
  const shape = (options === null || options === void 0 ? void 0 : (_options$gis = options.gis) === null || _options$gis === void 0 ? void 0 : _options$gis.format) || (options === null || options === void 0 ? void 0 : (_options$mvt = options.mvt) === null || _options$mvt === void 0 ? void 0 : _options$mvt.shape);
  switch (shape) {
    case "columnar-table":
      return {
        shape: "columnar-table",
        data: parseToBinary(arrayBuffer, mvtOptions)
      };
    case "geojson-row-table": {
      const table = {
        shape: "geojson-row-table",
        data: parseToGeojson(arrayBuffer, mvtOptions)
      };
      return table;
    }
    case "geojson":
      return parseToGeojson(arrayBuffer, mvtOptions);
    case "binary-geometry":
      return parseToBinary(arrayBuffer, mvtOptions);
    case "binary":
      return parseToBinary(arrayBuffer, mvtOptions);
    default:
      throw new Error(shape);
  }
}
function parseToBinary(arrayBuffer, options) {
  const [flatGeoJsonFeatures, geometryInfo] = parseToFlatGeoJson(arrayBuffer, options);
  const binaryData = flatGeojsonToBinary(flatGeoJsonFeatures, geometryInfo);
  binaryData.byteLength = arrayBuffer.byteLength;
  return binaryData;
}
function parseToFlatGeoJson(arrayBuffer, options) {
  const features = [];
  const geometryInfo = {
    coordLength: 2,
    pointPositionsCount: 0,
    pointFeaturesCount: 0,
    linePositionsCount: 0,
    linePathsCount: 0,
    lineFeaturesCount: 0,
    polygonPositionsCount: 0,
    polygonObjectsCount: 0,
    polygonRingsCount: 0,
    polygonFeaturesCount: 0
  };
  if (arrayBuffer.byteLength <= 0) {
    return [features, geometryInfo];
  }
  const tile = new VectorTile2(new import_pbf.default(arrayBuffer));
  const selectedLayers = options && Array.isArray(options.layers) ? options.layers : Object.keys(tile.layers);
  selectedLayers.forEach((layerName) => {
    const vectorTileLayer = tile.layers[layerName];
    if (!vectorTileLayer) {
      return;
    }
    for (let i2 = 0; i2 < vectorTileLayer.length; i2++) {
      const vectorTileFeature = vectorTileLayer.feature(i2, geometryInfo);
      const decodedFeature = getDecodedFeatureBinary(vectorTileFeature, options, layerName);
      features.push(decodedFeature);
    }
  });
  return [features, geometryInfo];
}
function parseToGeojson(arrayBuffer, options) {
  if (arrayBuffer.byteLength <= 0) {
    return [];
  }
  const features = [];
  const tile = new VectorTile(new import_pbf.default(arrayBuffer));
  const selectedLayers = Array.isArray(options.layers) ? options.layers : Object.keys(tile.layers);
  selectedLayers.forEach((layerName) => {
    const vectorTileLayer = tile.layers[layerName];
    if (!vectorTileLayer) {
      return;
    }
    for (let i2 = 0; i2 < vectorTileLayer.length; i2++) {
      const vectorTileFeature = vectorTileLayer.feature(i2);
      const decodedFeature = getDecodedFeature(vectorTileFeature, options, layerName);
      features.push(decodedFeature);
    }
  });
  return features;
}
function normalizeOptions(options) {
  var _options$mvt2;
  if (!(options !== null && options !== void 0 && options.mvt)) {
    throw new Error("mvt options required");
  }
  const wgs84Coordinates = ((_options$mvt2 = options.mvt) === null || _options$mvt2 === void 0 ? void 0 : _options$mvt2.coordinates) === "wgs84";
  const {
    tileIndex
  } = options.mvt;
  const hasTileIndex = tileIndex && Number.isFinite(tileIndex.x) && Number.isFinite(tileIndex.y) && Number.isFinite(tileIndex.z);
  if (wgs84Coordinates && !hasTileIndex) {
    throw new Error("MVT Loader: WGS84 coordinates need tileIndex property");
  }
  return options.mvt;
}
function getDecodedFeature(feature2, options, layerName) {
  const decodedFeature = feature2.toGeoJSON(options.coordinates === "wgs84" ? options.tileIndex : transformToLocalCoordinates);
  if (options.layerProperty) {
    decodedFeature.properties[options.layerProperty] = layerName;
  }
  return decodedFeature;
}
function getDecodedFeatureBinary(feature2, options, layerName) {
  const decodedFeature = feature2.toBinaryCoordinates(options.coordinates === "wgs84" ? options.tileIndex : transformToLocalCoordinatesBinary);
  if (options.layerProperty && decodedFeature.properties) {
    decodedFeature.properties[options.layerProperty] = layerName;
  }
  return decodedFeature;
}
function transformToLocalCoordinates(line, feature2) {
  const {
    extent
  } = feature2;
  for (let i2 = 0; i2 < line.length; i2++) {
    const p = line[i2];
    p[0] /= extent;
    p[1] /= extent;
  }
}
function transformToLocalCoordinatesBinary(data, feature2) {
  const {
    extent
  } = feature2;
  for (let i2 = 0, il = data.length; i2 < il; ++i2) {
    data[i2] /= extent;
  }
}

// node_modules/@loaders.gl/mvt/dist/esm/mvt-loader.js
var VERSION8 = true ? "3.4.9" : "latest";
var DEFAULT_MVT_LOADER_OPTIONS = {
  mvt: {
    shape: "geojson",
    coordinates: "local",
    layerProperty: "layerName",
    layers: void 0,
    tileIndex: null
  }
};
var MVTWorkerLoader = {
  name: "Mapbox Vector Tile",
  id: "mvt",
  module: "mvt",
  version: VERSION8,
  extensions: ["mvt", "pbf"],
  mimeTypes: ["application/vnd.mapbox-vector-tile", "application/x-protobuf"],
  worker: true,
  category: "geometry",
  options: DEFAULT_MVT_LOADER_OPTIONS
};
var MVTLoader = {
  ...MVTWorkerLoader,
  parse: async (arrayBuffer, options) => parseMVT(arrayBuffer, options),
  parseSync: parseMVT,
  binary: true
};

// node_modules/@deck.gl/geo-layers/dist/esm/mvt-layer/coordinate-transform.js
var availableTransformations = {
  Point,
  MultiPoint,
  LineString,
  MultiLineString,
  Polygon,
  MultiPolygon
};
function Point([pointX, pointY], [nw, se], viewport) {
  const x2 = lerp(nw[0], se[0], pointX);
  const y2 = lerp(nw[1], se[1], pointY);
  return viewport.unprojectFlat([x2, y2]);
}
function getPoints(geometry, bbox, viewport) {
  return geometry.map((g) => Point(g, bbox, viewport));
}
function MultiPoint(multiPoint, bbox, viewport) {
  return getPoints(multiPoint, bbox, viewport);
}
function LineString(line, bbox, viewport) {
  return getPoints(line, bbox, viewport);
}
function MultiLineString(multiLineString, bbox, viewport) {
  return multiLineString.map((lineString2) => LineString(lineString2, bbox, viewport));
}
function Polygon(polygon, bbox, viewport) {
  return polygon.map((polygonRing) => getPoints(polygonRing, bbox, viewport));
}
function MultiPolygon(multiPolygon, bbox, viewport) {
  return multiPolygon.map((polygon) => Polygon(polygon, bbox, viewport));
}
function transform(geometry, bbox, viewport) {
  const nw = viewport.projectFlat([bbox.west, bbox.north]);
  const se = viewport.projectFlat([bbox.east, bbox.south]);
  const projectedBbox = [nw, se];
  return {
    ...geometry,
    coordinates: availableTransformations[geometry.type](geometry.coordinates, projectedBbox, viewport)
  };
}

// node_modules/@deck.gl/geo-layers/dist/esm/mvt-layer/find-index-binary.js
var GEOM_TYPES = ["points", "lines", "polygons"];
function findIndexBinary(data, uniqueIdProperty, featureId, layerName) {
  for (const gt of GEOM_TYPES) {
    const index = data[gt] && findIndexByType(data[gt], uniqueIdProperty, featureId, layerName);
    if (index >= 0) {
      return index;
    }
  }
  return -1;
}
function findIndexByType(geomData, uniqueIdProperty, featureId, layerName) {
  const featureIds = geomData.featureIds.value;
  if (!featureIds.length) {
    return -1;
  }
  let startFeatureIndex = 0;
  let endFeatureIndex = featureIds[featureIds.length - 1] + 1;
  if (layerName) {
    const layerRange = getLayerRange(geomData, layerName);
    if (layerRange) {
      startFeatureIndex = layerRange[0];
      endFeatureIndex = layerRange[1] + 1;
    } else {
      return -1;
    }
  }
  let featureIndex = -1;
  if (uniqueIdProperty in geomData.numericProps) {
    const vertexIndex = geomData.numericProps[uniqueIdProperty].value.findIndex((x2, i2) => x2 === featureId && featureIds[i2] >= startFeatureIndex && featureIds[i2] < endFeatureIndex);
    return vertexIndex >= 0 ? geomData.globalFeatureIds.value[vertexIndex] : -1;
  } else if (uniqueIdProperty) {
    featureIndex = findIndex(geomData.properties, (elem) => elem[uniqueIdProperty] === featureId, startFeatureIndex, endFeatureIndex);
  } else if (geomData.fields) {
    featureIndex = findIndex(geomData.fields, (elem) => elem.id === featureId, startFeatureIndex, endFeatureIndex);
  }
  return featureIndex >= 0 ? getGlobalFeatureId(geomData, featureIndex) : -1;
}
function getLayerRange(geomData, layerName) {
  if (!geomData.__layers) {
    const layerNames = {};
    const {
      properties
    } = geomData;
    for (let i2 = 0; i2 < properties.length; i2++) {
      const {
        layerName: key
      } = properties[i2];
      if (!key) {
      } else if (layerNames[key]) {
        layerNames[key][1] = i2;
      } else {
        layerNames[key] = [i2, i2];
      }
    }
    geomData.__layers = layerNames;
  }
  return geomData.__layers[layerName];
}
function getGlobalFeatureId(geomData, featureIndex) {
  if (!geomData.__ids) {
    const result = [];
    const featureIds = geomData.featureIds.value;
    const globalFeatureIds = geomData.globalFeatureIds.value;
    for (let i2 = 0; i2 < featureIds.length; i2++) {
      result[featureIds[i2]] = globalFeatureIds[i2];
    }
    geomData.__ids = result;
  }
  return geomData.__ids[featureIndex];
}
function findIndex(array, predicate, startIndex, endIndex) {
  for (let i2 = startIndex; i2 < endIndex; i2++) {
    if (predicate(array[i2], i2)) {
      return i2;
    }
  }
  return -1;
}

// node_modules/@deck.gl/geo-layers/dist/esm/mvt-layer/mvt-layer.js
var WORLD_SIZE = 512;
var defaultProps23 = {
  ...GeoJsonLayer.defaultProps,
  data: urlType,
  onDataLoad: {
    type: "function",
    value: null,
    optional: true,
    compare: false
  },
  uniqueIdProperty: "",
  highlightedFeatureId: null,
  loaders: [MVTWorkerLoader],
  binary: true
};
var MVTLayer = class extends TileLayer {
  initializeState() {
    super.initializeState();
    const binary = this.context.viewport.resolution !== void 0 ? false : this.props.binary;
    this.setState({
      binary,
      data: null,
      tileJSON: null
    });
  }
  get isLoaded() {
    return this.state && this.state.data && this.state.tileset && super.isLoaded;
  }
  updateState({
    props,
    oldProps,
    context,
    changeFlags
  }) {
    var _this$state;
    if (changeFlags.dataChanged) {
      this._updateTileData();
    }
    if ((_this$state = this.state) !== null && _this$state !== void 0 && _this$state.data) {
      super.updateState({
        props,
        oldProps,
        context,
        changeFlags
      });
      this._setWGS84PropertyForTiles();
    }
    const {
      highlightColor
    } = props;
    if (highlightColor !== oldProps.highlightColor && Array.isArray(highlightColor)) {
      this.setState({
        highlightColor
      });
    }
  }
  async _updateTileData() {
    let data = this.props.data;
    let tileJSON = null;
    if (typeof data === "string" && !isURLTemplate(data)) {
      const {
        onDataLoad,
        fetch: fetch2
      } = this.props;
      this.setState({
        data: null,
        tileJSON: null
      });
      try {
        tileJSON = await fetch2(data, {
          propName: "data",
          layer: this,
          loaders: []
        });
      } catch (error) {
        this.raiseError(error, "loading TileJSON");
        data = null;
      }
      if (onDataLoad) {
        onDataLoad(tileJSON, {
          propName: "data",
          layer: this
        });
      }
    } else if (data.tilejson) {
      tileJSON = data;
    }
    if (tileJSON) {
      data = tileJSON.tiles;
    }
    this.setState({
      data,
      tileJSON
    });
  }
  _getTilesetOptions() {
    const opts = super._getTilesetOptions();
    const tileJSON = this.state.tileJSON;
    const {
      minZoom,
      maxZoom
    } = this.props;
    if (tileJSON) {
      if (Number.isFinite(tileJSON.minzoom) && tileJSON.minzoom > minZoom) {
        opts.minZoom = tileJSON.minzoom;
      }
      if (Number.isFinite(tileJSON.maxzoom) && (!Number.isFinite(maxZoom) || tileJSON.maxzoom < maxZoom)) {
        opts.maxZoom = tileJSON.maxzoom;
      }
    }
    return opts;
  }
  renderLayers() {
    var _this$state2;
    if (!((_this$state2 = this.state) !== null && _this$state2 !== void 0 && _this$state2.data))
      return null;
    return super.renderLayers();
  }
  getTileData(loadProps) {
    var _loadOptions;
    const {
      data,
      binary
    } = this.state;
    const {
      index,
      signal
    } = loadProps;
    const url = getURLFromTemplate(data, loadProps);
    if (!url) {
      return Promise.reject("Invalid URL");
    }
    let loadOptions = this.getLoadOptions();
    const {
      fetch: fetch2
    } = this.props;
    loadOptions = {
      ...loadOptions,
      mimeType: "application/x-protobuf",
      mvt: {
        ...(_loadOptions = loadOptions) === null || _loadOptions === void 0 ? void 0 : _loadOptions.mvt,
        coordinates: this.context.viewport.resolution ? "wgs84" : "local",
        tileIndex: index
      },
      gis: binary ? {
        format: "binary"
      } : {}
    };
    return fetch2(url, {
      propName: "data",
      layer: this,
      loadOptions,
      signal
    });
  }
  renderSubLayers(props) {
    const {
      x: x2,
      y: y2,
      z
    } = props.tile.index;
    const worldScale = Math.pow(2, z);
    const xScale = WORLD_SIZE / worldScale;
    const yScale = -xScale;
    const xOffset = WORLD_SIZE * x2 / worldScale;
    const yOffset = WORLD_SIZE * (1 - y2 / worldScale);
    const modelMatrix2 = new Matrix4().scale([xScale, yScale, 1]);
    props.autoHighlight = false;
    if (!this.context.viewport.resolution) {
      props.modelMatrix = modelMatrix2;
      props.coordinateOrigin = [xOffset, yOffset, 0];
      props.coordinateSystem = COORDINATE_SYSTEM.CARTESIAN;
      props.extensions = [...props.extensions || [], new ClipExtension()];
    }
    const subLayers = super.renderSubLayers(props);
    if (this.state.binary && !(subLayers instanceof GeoJsonLayer)) {
      log_default.warn("renderSubLayers() must return GeoJsonLayer when using binary:true")();
    }
    return subLayers;
  }
  _updateAutoHighlight(info) {
    const {
      uniqueIdProperty
    } = this.props;
    const {
      hoveredFeatureId,
      hoveredFeatureLayerName
    } = this.state;
    const hoveredFeature = info.object;
    let newHoveredFeatureId;
    let newHoveredFeatureLayerName;
    if (hoveredFeature) {
      newHoveredFeatureId = getFeatureUniqueId(hoveredFeature, uniqueIdProperty);
      newHoveredFeatureLayerName = getFeatureLayerName(hoveredFeature);
    }
    let {
      highlightColor
    } = this.props;
    if (typeof highlightColor === "function") {
      highlightColor = highlightColor(info);
    }
    if (hoveredFeatureId !== newHoveredFeatureId || hoveredFeatureLayerName !== newHoveredFeatureLayerName) {
      this.setState({
        highlightColor,
        hoveredFeatureId: newHoveredFeatureId,
        hoveredFeatureLayerName: newHoveredFeatureLayerName
      });
    }
  }
  getPickingInfo(params) {
    const info = super.getPickingInfo(params);
    const isWGS84 = Boolean(this.context.viewport.resolution);
    if (this.state.binary && info.index !== -1) {
      const {
        data
      } = params.sourceLayer.props;
      info.object = binaryToGeojson(data, {
        globalFeatureId: info.index
      });
    }
    if (info.object && !isWGS84) {
      info.object = transformTileCoordsToWGS84(info.object, info.tile.bbox, this.context.viewport);
    }
    return info;
  }
  getSubLayerPropsByTile(tile) {
    return {
      highlightedObjectIndex: this.getHighlightedObjectIndex(tile),
      highlightColor: this.state.highlightColor
    };
  }
  getHighlightedObjectIndex(tile) {
    const {
      hoveredFeatureId,
      hoveredFeatureLayerName,
      binary
    } = this.state;
    const {
      uniqueIdProperty,
      highlightedFeatureId
    } = this.props;
    const data = tile.content;
    const isHighlighted = isFeatureIdDefined(highlightedFeatureId);
    const isFeatureIdPresent = isFeatureIdDefined(hoveredFeatureId) || isHighlighted;
    if (!isFeatureIdPresent) {
      return -1;
    }
    const featureIdToHighlight = isHighlighted ? highlightedFeatureId : hoveredFeatureId;
    if (Array.isArray(data)) {
      return data.findIndex((feature2) => {
        const isMatchingId = getFeatureUniqueId(feature2, uniqueIdProperty) === featureIdToHighlight;
        const isMatchingLayer = isHighlighted || getFeatureLayerName(feature2) === hoveredFeatureLayerName;
        return isMatchingId && isMatchingLayer;
      });
    } else if (data && binary) {
      return findIndexBinary(data, uniqueIdProperty, featureIdToHighlight, isHighlighted ? "" : hoveredFeatureLayerName);
    }
    return -1;
  }
  _pickObjects(maxObjects) {
    const {
      deck,
      viewport
    } = this.context;
    const width = viewport.width;
    const height = viewport.height;
    const x2 = viewport.x;
    const y2 = viewport.y;
    const layerIds = [this.id];
    return deck.pickObjects({
      x: x2,
      y: y2,
      width,
      height,
      layerIds,
      maxObjects
    });
  }
  getRenderedFeatures(maxFeatures = null) {
    const features = this._pickObjects(maxFeatures);
    const featureCache = /* @__PURE__ */ new Set();
    const renderedFeatures = [];
    for (const f of features) {
      const featureId = getFeatureUniqueId(f.object, this.props.uniqueIdProperty);
      if (featureId === void 0) {
        renderedFeatures.push(f.object);
      } else if (!featureCache.has(featureId)) {
        featureCache.add(featureId);
        renderedFeatures.push(f.object);
      }
    }
    return renderedFeatures;
  }
  _setWGS84PropertyForTiles() {
    const propName = "dataInWGS84";
    const tileset = this.state.tileset;
    tileset.selectedTiles.forEach((tile) => {
      if (!tile.hasOwnProperty(propName)) {
        Object.defineProperty(tile, propName, {
          get: () => {
            if (!tile.content) {
              return null;
            }
            if (this.state.binary && Array.isArray(tile.content) && !tile.content.length) {
              return [];
            }
            const {
              bbox
            } = tile;
            if (tile._contentWGS84 === void 0 && isGeoBoundingBox(bbox)) {
              const content = this.state.binary ? binaryToGeojson(tile.content) : tile.content;
              tile._contentWGS84 = content.map((feature2) => transformTileCoordsToWGS84(feature2, bbox, this.context.viewport));
            }
            return tile._contentWGS84;
          }
        });
      }
    });
  }
};
_defineProperty(MVTLayer, "layerName", "MVTLayer");
_defineProperty(MVTLayer, "defaultProps", defaultProps23);
function getFeatureUniqueId(feature2, uniqueIdProperty) {
  if (feature2.properties && uniqueIdProperty) {
    return feature2.properties[uniqueIdProperty];
  }
  if ("id" in feature2) {
    return feature2.id;
  }
  return void 0;
}
function getFeatureLayerName(feature2) {
  var _feature$properties;
  return ((_feature$properties = feature2.properties) === null || _feature$properties === void 0 ? void 0 : _feature$properties.layerName) || null;
}
function isFeatureIdDefined(value) {
  return value !== void 0 && value !== null && value !== "";
}
function transformTileCoordsToWGS84(object, bbox, viewport) {
  const feature2 = {
    ...object,
    geometry: {
      type: object.geometry.type
    }
  };
  Object.defineProperty(feature2.geometry, "coordinates", {
    get: () => {
      const wgs84Geom = transform(object.geometry, bbox, viewport);
      return wgs84Geom.coordinates;
    }
  });
  return feature2;
}

// node_modules/@deck.gl/geo-layers/dist/esm/geohash-layer/geohash-utils.js
var BASE32_CODES = "0123456789bcdefghjkmnpqrstuvwxyz";
var BASE32_CODES_DICT = {};
for (let i2 = 0; i2 < BASE32_CODES.length; i2++) {
  BASE32_CODES_DICT[BASE32_CODES.charAt(i2)] = i2;
}
var MIN_LAT = -90;
var MAX_LAT = 90;
var MIN_LON = -180;
var MAX_LON = 180;
function getGeohashBounds(geohash) {
  let isLon = true;
  let maxLat = MAX_LAT;
  let minLat = MIN_LAT;
  let maxLon = MAX_LON;
  let minLon = MIN_LON;
  let mid;
  let hashValue = 0;
  for (let i2 = 0, l = geohash.length; i2 < l; i2++) {
    const code = geohash[i2].toLowerCase();
    hashValue = BASE32_CODES_DICT[code];
    for (let bits = 4; bits >= 0; bits--) {
      const bit = hashValue >> bits & 1;
      if (isLon) {
        mid = (maxLon + minLon) / 2;
        if (bit === 1) {
          minLon = mid;
        } else {
          maxLon = mid;
        }
      } else {
        mid = (maxLat + minLat) / 2;
        if (bit === 1) {
          minLat = mid;
        } else {
          maxLat = mid;
        }
      }
      isLon = !isLon;
    }
  }
  return [minLat, minLon, maxLat, maxLon];
}
function getGeohashPolygon(geohash) {
  const [s, w, n, e] = getGeohashBounds(geohash);
  return [e, n, e, s, w, s, w, n, e, n];
}

// node_modules/@deck.gl/geo-layers/dist/esm/geohash-layer/geohash-layer.js
var defaultProps24 = {
  getGeohash: {
    type: "accessor",
    value: (d) => d.geohash
  }
};
var GeohashLayer = class extends GeoCellLayer {
  indexToBounds() {
    const {
      data,
      getGeohash
    } = this.props;
    return {
      data,
      _normalize: false,
      positionFormat: "XY",
      getPolygon: (x2, objectInfo) => getGeohashPolygon(getGeohash(x2, objectInfo))
    };
  }
};
_defineProperty(GeohashLayer, "layerName", "GeohashLayer");
_defineProperty(GeohashLayer, "defaultProps", defaultProps24);
export {
  GeohashLayer,
  GreatCircleLayer,
  H3ClusterLayer,
  H3HexagonLayer,
  MVTLayer,
  QuadkeyLayer,
  S2Layer,
  TerrainLayer,
  Tile3DLayer,
  TileLayer,
  TripsLayer,
  GeoCellLayer as _GeoCellLayer,
  Tile2DHeader as _Tile2DHeader,
  Tileset2D as _Tileset2D,
  WMSLayer as _WMSLayer,
  getURLFromTemplate as _getURLFromTemplate
};
/*! Bundled license information:

long/dist/long.js:
  (**
   * @license long.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
   * Released under the Apache License, Version 2.0
   * see: https://github.com/dcodeIO/long.js for details
   *)

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
//# sourceMappingURL=@deck__gl_geo-layers.js.map
